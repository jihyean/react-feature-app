{"ast":null,"code":"/** @returns {void} */\nfunction noop() {}\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nfunction assign(tar, src) {\n  // @ts-ignore\n  for (const k in src) tar[k] = src[k];\n  return /** @type {T & S} */tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction run_all(fns) {\n  fns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nfunction is_function(thing) {\n  return typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';\n}\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n  if (element_src === url) return true;\n  if (!src_url_equal_anchor) {\n    src_url_equal_anchor = document.createElement('a');\n  }\n  // This is actually faster than doing URL(..).href\n  src_url_equal_anchor.href = url;\n  return element_src === src_url_equal_anchor.href;\n}\n\n/** @returns {boolean} */\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction subscribe(store, ...callbacks) {\n  if (store == null) {\n    for (const callback of callbacks) {\n      callback(undefined);\n    }\n    return noop;\n  }\n  const unsub = store.subscribe(...callbacks);\n  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nfunction get_store_value(store) {\n  let value;\n  subscribe(store, _ => value = _)();\n  return value;\n}\n\n/** @returns {void} */\nfunction component_subscribe(component, store, callback) {\n  component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === undefined) {\n      return lets;\n    }\n    if (typeof lets === 'object') {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\n\n/** @returns {void} */\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\n\n/** @returns {any[] | -1} */\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\n\n/** @returns {{}} */\nfunction exclude_internal_props(props) {\n  const result = {};\n  for (const k in props) if (k[0] !== '$') result[k] = props[k];\n  return result;\n}\n\n/** @returns {{}} */\nfunction compute_rest_props(props, keys) {\n  const rest = {};\n  keys = new Set(keys);\n  for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n  return rest;\n}\nfunction null_to_empty(value) {\n  return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n  store.set(value);\n  return ret;\n}\nfunction action_destroyer(action_result) {\n  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction append(target, node) {\n  target.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * @returns {void} */\nfunction destroy_each(iterations, detaching) {\n  for (let i = 0; i < iterations.length; i += 1) {\n    if (iterations[i]) iterations[i].d(detaching);\n  }\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nfunction element(name) {\n  return document.createElement(name);\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nfunction svg_element(name) {\n  return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nfunction text(data) {\n  return document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nfunction space() {\n  return text(' ');\n}\n\n/**\n * @returns {Text} */\nfunction empty() {\n  return text('');\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction stop_propagation(fn) {\n  return function (event) {\n    event.stopPropagation();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nfunction attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.data === data) return;\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @returns {void} */\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? 'important' : '');\n  }\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nfunction is_crossorigin() {\n  if (crossorigin === undefined) {\n    crossorigin = false;\n    try {\n      if (typeof window !== 'undefined' && window.parent) {\n        void window.parent.document;\n      }\n    } catch (error) {\n      crossorigin = true;\n    }\n  }\n  return crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nfunction add_iframe_resize_listener(node, fn) {\n  const computed_style = getComputedStyle(node);\n  if (computed_style.position === 'static') {\n    node.style.position = 'relative';\n  }\n  const iframe = element('iframe');\n  iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n  iframe.setAttribute('aria-hidden', 'true');\n  iframe.tabIndex = -1;\n  const crossorigin = is_crossorigin();\n\n  /**\n   * @type {() => void}\n   */\n  let unsubscribe;\n  if (crossorigin) {\n    iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n    unsubscribe = listen(window, 'message', /** @param {MessageEvent} event */event => {\n      if (event.source === iframe.contentWindow) fn();\n    });\n  } else {\n    iframe.src = 'about:blank';\n    iframe.onload = () => {\n      unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n      // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n      // see https://github.com/sveltejs/svelte/issues/4233\n      fn();\n    };\n  }\n  append(node, iframe);\n  return () => {\n    if (crossorigin) {\n      unsubscribe();\n    } else if (unsubscribe && iframe.contentWindow) {\n      unsubscribe();\n    }\n    detach(iframe);\n  };\n}\n\n/**\n * @returns {void} */\nfunction toggle_class(element, name, toggle) {\n  // The `!!` is required because an `undefined` flag means flipping the current state.\n  element.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nfunction custom_event(type, detail, {\n  bubbles = false,\n  cancelable = false\n} = {}) {\n  return new CustomEvent(type, {\n    detail,\n    bubbles,\n    cancelable\n  });\n}\n/** */\nclass HtmlTag {\n  /**\n   * @private\n   * @default false\n   */\n  is_svg = false;\n  /** parent for creating node */\n  e = undefined;\n  /** html tag nodes */\n  n = undefined;\n  /** target */\n  t = undefined;\n  /** anchor */\n  a = undefined;\n  constructor(is_svg = false) {\n    this.is_svg = is_svg;\n    this.e = this.n = null;\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  c(html) {\n    this.h(html);\n  }\n\n  /**\n   * @param {string} html\n   * @param {HTMLElement | SVGElement} target\n   * @param {HTMLElement | SVGElement} anchor\n   * @returns {void}\n   */\n  m(html, target, anchor = null) {\n    if (!this.e) {\n      if (this.is_svg) this.e = svg_element( /** @type {keyof SVGElementTagNameMap} */target.nodeName);\n      /** #7364  target for <template> may be provided as #document-fragment(11) */else this.e = element( /** @type {keyof HTMLElementTagNameMap} */\n      target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);\n      this.t = target.tagName !== 'TEMPLATE' ? target : /** @type {HTMLTemplateElement} */target.content;\n      this.c(html);\n    }\n    this.i(anchor);\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  h(html) {\n    this.e.innerHTML = html;\n    this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n  }\n\n  /**\n   * @returns {void} */\n  i(anchor) {\n    for (let i = 0; i < this.n.length; i += 1) {\n      insert(this.t, this.n[i], anchor);\n    }\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  p(html) {\n    this.d();\n    this.h(html);\n    this.i(this.a);\n  }\n\n  /**\n   * @returns {void} */\n  d() {\n    this.n.forEach(detach);\n  }\n}\nfunction construct_svelte_component(component, props) {\n  return new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n\nlet current_component;\n\n/** @returns {void} */\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component) throw new Error('Function called outside component initialization');\n  return current_component;\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nfunction onDestroy(fn) {\n  get_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nfunction createEventDispatcher() {\n  const component = get_current_component();\n  return (type, detail, {\n    cancelable = false\n  } = {}) => {\n    const callbacks = component.$$.callbacks[type];\n    if (callbacks) {\n      // TODO are there situations where events could be dispatched\n      // in a server (non-DOM) environment?\n      const event = custom_event( /** @type {string} */type, detail, {\n        cancelable\n      });\n      callbacks.slice().forEach(fn => {\n        fn.call(component, event);\n      });\n      return !event.defaultPrevented;\n    }\n    return true;\n  };\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nfunction setContext(key, context) {\n  get_current_component().$$.context.set(key, context);\n  return context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nfunction getContext(key) {\n  return get_current_component().$$.context.get(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nfunction bubble(component, event) {\n  const callbacks = component.$$.callbacks[event.type];\n  if (callbacks) {\n    // @ts-ignore\n    callbacks.slice().forEach(fn => fn.call(this, event));\n  }\n}\nconst dirty_components = [];\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */Promise.resolve();\nlet update_scheduled = false;\n\n/** @returns {void} */\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\n/** @returns {Promise<void>} */\nfunction tick() {\n  schedule_update();\n  return resolved_promise;\n}\n\n/** @returns {void} */\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nfunction flush() {\n  // Do not reenter flush while dirty components are updated, as this can\n  // result in an infinite loop. Instead, let the inner flush handle it.\n  // Reentrancy is ok afterwards for bindings etc.\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      // reset dirty state to not end up in a deadlocked state and then rethrow\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length) binding_callbacks.pop()();\n    // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach(c => c());\n  render_callbacks = filtered;\n}\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nfunction group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n  };\n}\n\n/**\n * @returns {void} */\nfunction check_outros() {\n  if (!outros.r) {\n    run_all(outros.c);\n  }\n  outros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nfunction transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n\n// general each functions:\n\nfunction ensure_array_like(array_like_or_iterator) {\n  return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);\n}\n\n/** @returns {void} */\nfunction outro_and_destroy_block(block, lookup) {\n  transition_out(block, 1, 1, () => {\n    lookup.delete(block.key);\n  });\n}\n\n/** @returns {any[]} */\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n  let o = old_blocks.length;\n  let n = list.length;\n  let i = o;\n  const old_indexes = {};\n  while (i--) old_indexes[old_blocks[i].key] = i;\n  const new_blocks = [];\n  const new_lookup = new Map();\n  const deltas = new Map();\n  const updates = [];\n  i = n;\n  while (i--) {\n    const child_ctx = get_context(ctx, list, i);\n    const key = get_key(child_ctx);\n    let block = lookup.get(key);\n    if (!block) {\n      block = create_each_block(key, child_ctx);\n      block.c();\n    } else if (dynamic) {\n      // defer updates until all the DOM shuffling is done\n      updates.push(() => block.p(child_ctx, dirty));\n    }\n    new_lookup.set(key, new_blocks[i] = block);\n    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n  }\n  const will_move = new Set();\n  const did_move = new Set();\n  /** @returns {void} */\n  function insert(block) {\n    transition_in(block, 1);\n    block.m(node, next);\n    lookup.set(block.key, block);\n    next = block.first;\n    n--;\n  }\n  while (o && n) {\n    const new_block = new_blocks[n - 1];\n    const old_block = old_blocks[o - 1];\n    const new_key = new_block.key;\n    const old_key = old_block.key;\n    if (new_block === old_block) {\n      // do nothing\n      next = new_block.first;\n      o--;\n      n--;\n    } else if (!new_lookup.has(old_key)) {\n      // remove old block\n      destroy(old_block, lookup);\n      o--;\n    } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n      insert(new_block);\n    } else if (did_move.has(old_key)) {\n      o--;\n    } else if (deltas.get(new_key) > deltas.get(old_key)) {\n      did_move.add(new_key);\n      insert(new_block);\n    } else {\n      will_move.add(old_key);\n      o--;\n    }\n  }\n  while (o--) {\n    const old_block = old_blocks[o];\n    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n  }\n  while (n) insert(new_blocks[n - 1]);\n  run_all(updates);\n  return new_blocks;\n}\n\n/** @returns {{}} */\nfunction get_spread_update(levels, updates) {\n  const update = {};\n  const to_null_out = {};\n  const accounted_for = {\n    $$scope: 1\n  };\n  let i = levels.length;\n  while (i--) {\n    const o = levels[i];\n    const n = updates[i];\n    if (n) {\n      for (const key in o) {\n        if (!(key in n)) to_null_out[key] = 1;\n      }\n      for (const key in n) {\n        if (!accounted_for[key]) {\n          update[key] = n[key];\n          accounted_for[key] = 1;\n        }\n      }\n      levels[i] = n;\n    } else {\n      for (const key in o) {\n        accounted_for[key] = 1;\n      }\n    }\n  }\n  for (const key in to_null_out) {\n    if (!(key in update)) update[key] = undefined;\n  }\n  return update;\n}\nfunction get_spread_object(spread_props) {\n  return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n/** @returns {void} */\nfunction create_component(block) {\n  block && block.c();\n}\n\n/** @returns {void} */\nfunction mount_component(component, target, anchor) {\n  const {\n    fragment,\n    after_update\n  } = component.$$;\n  fragment && fragment.m(target, anchor);\n  // onMount happens before the initial afterUpdate\n  add_render_callback(() => {\n    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n    // if the component was destroyed immediately\n    // it will update the `$$.on_destroy` reference to `null`.\n    // the destructured on_destroy may still reference to the old array\n    if (component.$$.on_destroy) {\n      component.$$.on_destroy.push(...new_on_destroy);\n    } else {\n      // Edge case - component was destroyed immediately,\n      // most likely as a result of a binding initialising\n      run_all(new_on_destroy);\n    }\n    component.$$.on_mount = [];\n  });\n  after_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles = null, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  /** @type {import('./private.js').T$$} */\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  // `false` as a special case of no DOM component\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      // TODO: what is the correct type here?\n      // @ts-expect-error\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro) transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor);\n    flush();\n  }\n  set_current_component(parent_component);\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nclass SvelteComponent {\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$ = undefined;\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$set = undefined;\n\n  /** @returns {void} */\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) callbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(props) {\n    if (this.$$set && !is_empty(props)) {\n      this.$$.skip_bound = true;\n      this.$$set(props);\n      this.$$.skip_bound = false;\n    }\n  }\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n\n// generated during release, do not modify\nconst PUBLIC_VERSION = '4';\nif (typeof window !== 'undefined')\n  // @ts-ignore\n  (window.__svelte || (window.__svelte = {\n    v: new Set()\n  })).v.add(PUBLIC_VERSION);\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction readable(value, start) {\n  return {\n    subscribe: writable(value, start).subscribe\n  };\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nfunction writable(value, start = noop) {\n  /** @type {import('./public.js').Unsubscriber} */\n  let stop;\n  /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n  const subscribers = new Set();\n  /** @param {T} new_value\n   * @returns {void}\n   */\n  function set(new_value) {\n    if (safe_not_equal(value, new_value)) {\n      value = new_value;\n      if (stop) {\n        // store is ready\n        const run_queue = !subscriber_queue.length;\n        for (const subscriber of subscribers) {\n          subscriber[1]();\n          subscriber_queue.push(subscriber, value);\n        }\n        if (run_queue) {\n          for (let i = 0; i < subscriber_queue.length; i += 2) {\n            subscriber_queue[i][0](subscriber_queue[i + 1]);\n          }\n          subscriber_queue.length = 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import('./public.js').Updater<T>} fn\n   * @returns {void}\n   */\n  function update(fn) {\n    set(fn(value));\n  }\n\n  /**\n   * @param {import('./public.js').Subscriber<T>} run\n   * @param {import('./private.js').Invalidator<T>} [invalidate]\n   * @returns {import('./public.js').Unsubscriber}\n   */\n  function subscribe(run, invalidate = noop) {\n    /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n    const subscriber = [run, invalidate];\n    subscribers.add(subscriber);\n    if (subscribers.size === 1) {\n      stop = start(set, update) || noop;\n    }\n    run(value);\n    return () => {\n      subscribers.delete(subscriber);\n      if (subscribers.size === 0 && stop) {\n        stop();\n        stop = null;\n      }\n    };\n  }\n  return {\n    set,\n    update,\n    subscribe\n  };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction derived(stores, fn, initial_value) {\n  const single = !Array.isArray(stores);\n  /** @type {Array<import('./public.js').Readable<any>>} */\n  const stores_array = single ? [stores] : stores;\n  if (!stores_array.every(Boolean)) {\n    throw new Error('derived() expects stores as input, got a falsy value');\n  }\n  const auto = fn.length < 2;\n  return readable(initial_value, (set, update) => {\n    let started = false;\n    const values = [];\n    let pending = 0;\n    let cleanup = noop;\n    const sync = () => {\n      if (pending) {\n        return;\n      }\n      cleanup();\n      const result = fn(single ? values[0] : values, set, update);\n      if (auto) {\n        set(result);\n      } else {\n        cleanup = is_function(result) ? result : noop;\n      }\n    };\n    const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {\n      values[i] = value;\n      pending &= ~(1 << i);\n      if (started) {\n        sync();\n      }\n    }, () => {\n      pending |= 1 << i;\n    }));\n    started = true;\n    sync();\n    return function stop() {\n      run_all(unsubscribers);\n      cleanup();\n      // We need to set this to false because callbacks can still happen despite having unsubscribed:\n      // Callbacks might already be placed in the queue which doesn't know it should no longer\n      // invoke this derived store.\n      started = false;\n    };\n  });\n}\nfunction createEntityStore() {\n  const {\n    subscribe,\n    set,\n    update\n  } = writable({\n    ids: [],\n    entities: {}\n  });\n  return {\n    set,\n    _update: update,\n    subscribe,\n    add: item => update(({\n      ids,\n      entities\n    }) => ({\n      ids: [...ids, item.model.id],\n      entities: {\n        ...entities,\n        [item.model.id]: item\n      }\n    })),\n    delete: id => update(state => {\n      const {\n        [id]: _,\n        ...entities\n      } = state.entities;\n      return {\n        ids: state.ids.filter(i => i !== id),\n        entities\n      };\n    }),\n    deleteAll: ids => update(state => {\n      const entities = {\n        ...state.entities\n      };\n      const idSet = new Set(ids);\n      for (let i = 0; i < state.ids.length; i++) {\n        if (idSet.has(state.ids[i])) {\n          delete entities[state.ids[i]];\n        }\n      }\n      return {\n        ids: state.ids.filter(i => !idSet.has(i)),\n        entities\n      };\n    }),\n    update: item => update(({\n      ids,\n      entities\n    }) => ({\n      ids,\n      entities: {\n        ...entities,\n        [item.model.id]: item\n      }\n    })),\n    upsert: item => update(({\n      ids,\n      entities\n    }) => {\n      const hasIndex = ids.indexOf(item.model.id) !== -1;\n      return {\n        ids: hasIndex ? ids : [...ids, item.model.id],\n        entities: {\n          ...entities,\n          [item.model.id]: item\n        }\n      };\n    }),\n    upsertAll: items => update(state => {\n      const entities = {\n        ...state.entities\n      };\n      const ids = [...state.ids];\n      for (let i = 0; i < items.length; i++) {\n        if (ids.indexOf(items[i].model.id) === -1) {\n          ids.push(items[i].model.id);\n        }\n        entities[items[i].model.id] = items[i];\n      }\n      return {\n        ids,\n        entities\n      };\n    }),\n    addAll: items => {\n      const ids = [];\n      const entities = {};\n      for (let i = 0; i < items.length; i++) {\n        ids.push(items[i].model.id);\n        entities[items[i].model.id] = items[i];\n      }\n      set({\n        ids,\n        entities\n      });\n    },\n    refresh: () => update(store => ({\n      ...store\n    }))\n  };\n}\nfunction all(store) {\n  return derived(store, ({\n    ids,\n    entities\n  }) => {\n    const results = [];\n    for (let i = 0; i < ids.length; i++) {\n      results.push(entities[ids[i]]);\n    }\n    return results;\n  });\n}\nfunction createDataStore() {\n  const taskStore = createEntityStore();\n  const rowStore = createEntityStore();\n  const timeRangeStore = createEntityStore();\n  const allTasks = all(taskStore);\n  const allRows = all(rowStore);\n  const allTimeRanges = all(timeRangeStore);\n  const rowTaskCache = derived(allTasks, $allTasks => {\n    const cache = {};\n    for (let i = 0; i < $allTasks.length; i++) {\n      const task = $allTasks[i];\n      if (!cache[task.model.resourceId]) {\n        cache[task.model.resourceId] = [];\n      }\n      cache[task.model.resourceId].push(task.model.id);\n    }\n    return cache;\n  });\n  const draggingTaskCache = writable({});\n  return {\n    taskStore,\n    rowStore,\n    timeRangeStore,\n    allTasks,\n    allRows,\n    allTimeRanges,\n    rowTaskCache,\n    draggingTaskCache\n  };\n}\nclass TaskFactory {\n  columnService;\n  rowPadding;\n  rowEntities;\n  constructor(columnService) {\n    this.columnService = columnService;\n  }\n  createTask(model) {\n    // id of task, every task needs to have a unique one\n    //task.id = task.id || undefined;\n    // completion %, indicated on task\n    model.amountDone = model.amountDone || 0;\n    // css classes\n    model.classes = model.classes || '';\n    // date task starts on\n    model.from = model.from || null;\n    // date task ends on\n    model.to = model.to || null;\n    // label of task\n    model.label = model.label || undefined;\n    // html content of task, will override label\n    model.html = model.html || undefined;\n    // show button bar\n    model.showButton = model.showButton || false;\n    // button classes, useful for fontawesome icons\n    model.buttonClasses = model.buttonClasses || '';\n    // html content of button\n    model.buttonHtml = model.buttonHtml || '';\n    // enable dragging of task\n    model.enableDragging = model.enableDragging === undefined ? true : model.enableDragging;\n    const left = this.columnService.getPositionByDate(model.from) | 0;\n    const right = this.columnService.getPositionByDate(model.to) | 0;\n    return {\n      model,\n      left: left,\n      width: right - left,\n      height: this.getHeight(model),\n      top: this.getPosY(model),\n      reflections: []\n    };\n  }\n  createTasks(tasks) {\n    return tasks.map(task => this.createTask(task));\n  }\n  row(resourceId) {\n    return this.rowEntities[resourceId];\n  }\n  getHeight(model) {\n    return this.row(model.resourceId).height - 2 * this.rowPadding;\n  }\n  getPosY(model) {\n    return this.row(model.resourceId).y + this.rowPadding;\n  }\n}\nfunction reflectTask(task, row, options) {\n  const reflectedId = `reflected-task-${task.model.id}-${row.model.id}`;\n  const model = {\n    ...task.model,\n    resourceId: row.model.id,\n    id: reflectedId,\n    enableDragging: false\n  };\n  return {\n    ...task,\n    model,\n    top: row.y + options.rowPadding,\n    reflected: true,\n    reflectedOnParent: false,\n    reflectedOnChild: true,\n    originalId: task.model.id\n  };\n}\nfunction isLeftClick(event) {\n  return event.which === 1;\n}\n/**\n * Gets mouse position within an element\n * @param node\n * @param event\n */\nfunction getRelativePos(node, event) {\n  const rect = node.getBoundingClientRect();\n  const x = event.clientX - rect.left; //x position within the element.\n  const y = event.clientY - rect.top; //y position within the element.\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Adds an event listener that triggers once.\n * @param target\n * @param type\n * @param listener\n * @param addOptions\n * @param removeOptions\n */\nfunction addEventListenerOnce(target, type, listener, addOptions, removeOptions) {\n  target.addEventListener(type, function fn() {\n    target.removeEventListener(type, fn, removeOptions);\n    listener.apply(this, arguments, addOptions);\n  });\n}\n/**\n * Sets the cursor on an element. Globally by default.\n * @param cursor\n * @param node\n */\nfunction setCursor(cursor, node = document.body) {\n  node.style.cursor = cursor;\n}\nfunction normalizeClassAttr(classes) {\n  if (!classes) {\n    return '';\n  }\n  if (typeof classes === 'string') {\n    return classes;\n  }\n  if (Array.isArray(classes)) {\n    return classes.join(' ');\n  }\n  return '';\n}\nfunction throttle(func, limit) {\n  let wait = false;\n  return function () {\n    if (!wait) {\n      func.apply(null, arguments);\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n      }, limit);\n    }\n  };\n}\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\nvar css_248z$e = \".sg-label-bottom.svelte-1f5vvpk.svelte-1f5vvpk{position:absolute;top:calc(100% + 10px);color:#888}.debug.svelte-1f5vvpk.svelte-1f5vvpk{position:absolute;top:-10px;right:0;font-size:8px;color:black}.sg-task.svelte-1f5vvpk.svelte-1f5vvpk{position:absolute;border-radius:2px;white-space:nowrap;transition:background-color 0.2s,\\r\\n            opacity 0.2s;pointer-events:all}.sg-task-background.svelte-1f5vvpk.svelte-1f5vvpk{position:absolute;height:100%;top:0}.sg-task-content.svelte-1f5vvpk.svelte-1f5vvpk{position:absolute;height:100%;top:0;padding-left:14px;font-size:14px;display:flex;align-items:center;justify-content:flex-start;user-select:none}.sg-task.svelte-1f5vvpk.svelte-1f5vvpk:not(.moving){transition:left 0.2s, top 0.2s,\\r\\n            transform 0.2s,\\r\\n            background-color 0.2s,\\r\\n            width 0.2s, \\r\\n            height 0.2s}.sg-task--sticky.svelte-1f5vvpk.svelte-1f5vvpk:not(.moving){transition:left 0.2s, top 0.2s,\\r\\n            transform 0.2s,\\r\\n            background-color 0.2s,\\r\\n            width 0.2s, \\r\\n            height 0.2s}.sg-task--sticky.svelte-1f5vvpk>.sg-task-content.svelte-1f5vvpk{position:sticky;left:0;max-width:100px}.sg-task.moving.svelte-1f5vvpk.svelte-1f5vvpk{z-index:10000;opacity:0.5}.sg-task.resize-enabled.svelte-1f5vvpk.svelte-1f5vvpk:hover::before{content:'';width:4px;height:50%;top:25%;position:absolute;border-style:solid;border-color:rgba(255, 255, 255, 0.5);cursor:ew-resize;margin-left:3px;left:0;border-width:0 1px;z-index:1}.sg-task.resize-enabled.svelte-1f5vvpk.svelte-1f5vvpk:hover::after{content:'';width:4px;height:50%;top:25%;position:absolute;border-style:solid;border-color:rgba(255, 255, 255, 0.5);cursor:ew-resize;margin-right:3px;right:0;border-width:0 1px;z-index:1}.sg-task-reflected.svelte-1f5vvpk.svelte-1f5vvpk{opacity:0.5}.sg-task-background.svelte-1f5vvpk.svelte-1f5vvpk{background:rgba(0, 0, 0, 0.2)}.sg-task{color:white;background:rgb(116, 191, 255)}.sg-task:hover{background:rgb(98, 161, 216)}.sg-task.selected{background:rgb(69, 112, 150)}.sg-milestone.svelte-1f5vvpk.svelte-1f5vvpk{width:20px !important;min-width:40px;margin-left:-20px}.sg-task.sg-milestone.svelte-1f5vvpk.svelte-1f5vvpk{background:transparent}.sg-milestone.svelte-1f5vvpk .sg-milestone__diamond.svelte-1f5vvpk{position:relative}.sg-milestone.svelte-1f5vvpk .sg-milestone__diamond.svelte-1f5vvpk:before{position:absolute;top:0;left:50%;content:' ';height:28px;width:28px;transform-origin:0 0;transform:rotate(45deg)}.sg-milestone__diamond:before{background:rgb(116, 191, 255)}\";\nstyleInject(css_248z$e);\n\n/* src\\entities\\Task.svelte generated by Svelte v4.2.1 */\n\nfunction create_if_block_5$1(ctx) {\n  let div;\n  return {\n    c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"sg-milestone__diamond svelte-1f5vvpk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (240:4) {#if model.amountDone}\nfunction create_if_block_4$1(ctx) {\n  let div;\n  return {\n    c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"sg-task-background svelte-1f5vvpk\");\n      set_style(div, \"width\", /*model*/ctx[0].amountDone + \"%\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1) {\n        set_style(div, \"width\", /*model*/ctx[0].amountDone + \"%\");\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (248:8) {:else}\nfunction create_else_block$3(ctx) {\n  let t_value = /*model*/ctx[0].label + \"\";\n  let t;\n  return {\n    c() {\n      t = text(t_value);\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1 && t_value !== (t_value = /*model*/ctx[0].label + \"\")) set_data(t, t_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\n\n// (246:30) \nfunction create_if_block_3$1(ctx) {\n  let html_tag;\n  let raw_value = /*taskContent*/ctx[12]( /*model*/ctx[0]) + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1 && raw_value !== (raw_value = /*taskContent*/ctx[12]( /*model*/ctx[0]) + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (244:8) {#if model.html}\nfunction create_if_block_2$1(ctx) {\n  let html_tag;\n  let raw_value = /*model*/ctx[0].html + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1 && raw_value !== (raw_value = /*model*/ctx[0].html + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (252:8) {#if model.showButton}\nfunction create_if_block_1$2(ctx) {\n  let span;\n  let raw_value = /*model*/ctx[0].buttonHtml + \"\";\n  let span_class_value;\n  let mounted;\n  let dispose;\n  return {\n    c() {\n      span = element(\"span\");\n      attr(span, \"class\", span_class_value = \"sg-task-button \" + /*model*/ctx[0].buttonClasses + \" svelte-1f5vvpk\");\n      attr(span, \"role\", \"button\");\n      attr(span, \"tabindex\", \"0\");\n    },\n    m(target, anchor) {\n      insert(target, span, anchor);\n      span.innerHTML = raw_value;\n      if (!mounted) {\n        dispose = listen(span, \"click\", /*onClick*/ctx[17]);\n        mounted = true;\n      }\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1 && raw_value !== (raw_value = /*model*/ctx[0].buttonHtml + \"\")) span.innerHTML = raw_value;\n      if (dirty[0] & /*model*/1 && span_class_value !== (span_class_value = \"sg-task-button \" + /*model*/ctx[0].buttonClasses + \" svelte-1f5vvpk\")) {\n        attr(span, \"class\", span_class_value);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(span);\n      }\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\n// (260:4) {#if model.labelBottom}\nfunction create_if_block$6(ctx) {\n  let label;\n  let t_value = /*model*/ctx[0].labelBottom + \"\";\n  let t;\n  return {\n    c() {\n      label = element(\"label\");\n      t = text(t_value);\n      attr(label, \"class\", \"sg-label-bottom svelte-1f5vvpk\");\n    },\n    m(target, anchor) {\n      insert(target, label, anchor);\n      append(label, t);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*model*/1 && t_value !== (t_value = /*model*/ctx[0].labelBottom + \"\")) set_data(t, t_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(label);\n      }\n    }\n  };\n}\nfunction create_fragment$d(ctx) {\n  let div1;\n  let t0;\n  let t1;\n  let div0;\n  let t2;\n  let t3;\n  let div1_data_task_id_value;\n  let div1_class_value;\n  let taskElement_action;\n  let mounted;\n  let dispose;\n  let if_block0 = /*model*/ctx[0].type === 'milestone' && create_if_block_5$1();\n  let if_block1 = /*model*/ctx[0].amountDone && create_if_block_4$1(ctx);\n  function select_block_type(ctx, dirty) {\n    if ( /*model*/ctx[0].html) return create_if_block_2$1;\n    if ( /*taskContent*/ctx[12]) return create_if_block_3$1;\n    return create_else_block$3;\n  }\n  let current_block_type = select_block_type(ctx);\n  let if_block2 = current_block_type(ctx);\n  let if_block3 = /*model*/ctx[0].showButton && create_if_block_1$2(ctx);\n  let if_block4 = /*model*/ctx[0].labelBottom && create_if_block$6(ctx);\n  return {\n    c() {\n      div1 = element(\"div\");\n      if (if_block0) if_block0.c();\n      t0 = space();\n      if (if_block1) if_block1.c();\n      t1 = space();\n      div0 = element(\"div\");\n      if_block2.c();\n      t2 = space();\n      if (if_block3) if_block3.c();\n      t3 = space();\n      if (if_block4) if_block4.c();\n      attr(div0, \"class\", \"sg-task-content svelte-1f5vvpk\");\n      attr(div1, \"data-task-id\", div1_data_task_id_value = /*model*/ctx[0].id);\n      attr(div1, \"class\", div1_class_value = \"sg-task \" + /*classes*/ctx[6] + \" svelte-1f5vvpk\");\n      set_style(div1, \"width\", /*_position*/ctx[5].width + \"px\");\n      set_style(div1, \"height\", /*height*/ctx[1] + \"px\");\n      set_style(div1, \"left\", /*_position*/ctx[5].x + \"px\");\n      set_style(div1, \"top\", /*_position*/ctx[5].y + \"px\");\n      toggle_class(div1, \"sg-milestone\", /*model*/ctx[0].type === 'milestone');\n      toggle_class(div1, \"moving\", /*_dragging*/ctx[3] || /*_resizing*/ctx[4]);\n      toggle_class(div1, \"animating\", animating);\n      toggle_class(div1, \"sg-task-reflected\", /*reflected*/ctx[2]);\n      toggle_class(div1, \"sg-task-selected\", /*$selectedTasks*/ctx[8][/*model*/ctx[0].id]);\n      toggle_class(div1, \"resize-enabled\", /*resizeEnabled*/ctx[7]);\n      toggle_class(div1, \"sg-task--sticky\", /*model*/ctx[0].stickyLabel);\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      if (if_block0) if_block0.m(div1, null);\n      append(div1, t0);\n      if (if_block1) if_block1.m(div1, null);\n      append(div1, t1);\n      append(div1, div0);\n      if_block2.m(div0, null);\n      append(div0, t2);\n      if (if_block3) if_block3.m(div0, null);\n      append(div1, t3);\n      if (if_block4) if_block4.m(div1, null);\n      if (!mounted) {\n        dispose = [action_destroyer( /*drag*/ctx[15].call(null, div1)), action_destroyer(taskElement_action = /*taskElement*/ctx[16].call(null, div1, /*model*/ctx[0]))];\n        mounted = true;\n      }\n    },\n    p(ctx, dirty) {\n      if ( /*model*/ctx[0].type === 'milestone') {\n        if (if_block0) ;else {\n          if_block0 = create_if_block_5$1();\n          if_block0.c();\n          if_block0.m(div1, t0);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n      if ( /*model*/ctx[0].amountDone) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n        } else {\n          if_block1 = create_if_block_4$1(ctx);\n          if_block1.c();\n          if_block1.m(div1, t1);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {\n        if_block2.p(ctx, dirty);\n      } else {\n        if_block2.d(1);\n        if_block2 = current_block_type(ctx);\n        if (if_block2) {\n          if_block2.c();\n          if_block2.m(div0, t2);\n        }\n      }\n      if ( /*model*/ctx[0].showButton) {\n        if (if_block3) {\n          if_block3.p(ctx, dirty);\n        } else {\n          if_block3 = create_if_block_1$2(ctx);\n          if_block3.c();\n          if_block3.m(div0, null);\n        }\n      } else if (if_block3) {\n        if_block3.d(1);\n        if_block3 = null;\n      }\n      if ( /*model*/ctx[0].labelBottom) {\n        if (if_block4) {\n          if_block4.p(ctx, dirty);\n        } else {\n          if_block4 = create_if_block$6(ctx);\n          if_block4.c();\n          if_block4.m(div1, null);\n        }\n      } else if (if_block4) {\n        if_block4.d(1);\n        if_block4 = null;\n      }\n      if (dirty[0] & /*model*/1 && div1_data_task_id_value !== (div1_data_task_id_value = /*model*/ctx[0].id)) {\n        attr(div1, \"data-task-id\", div1_data_task_id_value);\n      }\n      if (dirty[0] & /*classes*/64 && div1_class_value !== (div1_class_value = \"sg-task \" + /*classes*/ctx[6] + \" svelte-1f5vvpk\")) {\n        attr(div1, \"class\", div1_class_value);\n      }\n      if (dirty[0] & /*_position*/32) {\n        set_style(div1, \"width\", /*_position*/ctx[5].width + \"px\");\n      }\n      if (dirty[0] & /*height*/2) {\n        set_style(div1, \"height\", /*height*/ctx[1] + \"px\");\n      }\n      if (dirty[0] & /*_position*/32) {\n        set_style(div1, \"left\", /*_position*/ctx[5].x + \"px\");\n      }\n      if (dirty[0] & /*_position*/32) {\n        set_style(div1, \"top\", /*_position*/ctx[5].y + \"px\");\n      }\n      if (taskElement_action && is_function(taskElement_action.update) && dirty[0] & /*model*/1) taskElement_action.update.call(null, /*model*/ctx[0]);\n      if (dirty[0] & /*classes, model*/65) {\n        toggle_class(div1, \"sg-milestone\", /*model*/ctx[0].type === 'milestone');\n      }\n      if (dirty[0] & /*classes, _dragging, _resizing*/88) {\n        toggle_class(div1, \"moving\", /*_dragging*/ctx[3] || /*_resizing*/ctx[4]);\n      }\n      if (dirty[0] & /*classes*/64) {\n        toggle_class(div1, \"animating\", animating);\n      }\n      if (dirty[0] & /*classes, reflected*/68) {\n        toggle_class(div1, \"sg-task-reflected\", /*reflected*/ctx[2]);\n      }\n      if (dirty[0] & /*classes, $selectedTasks, model*/321) {\n        toggle_class(div1, \"sg-task-selected\", /*$selectedTasks*/ctx[8][/*model*/ctx[0].id]);\n      }\n      if (dirty[0] & /*classes, resizeEnabled*/192) {\n        toggle_class(div1, \"resize-enabled\", /*resizeEnabled*/ctx[7]);\n      }\n      if (dirty[0] & /*classes, model*/65) {\n        toggle_class(div1, \"sg-task--sticky\", /*model*/ctx[0].stickyLabel);\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n      if_block2.d();\n      if (if_block3) if_block3.d();\n      if (if_block4) if_block4.d();\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\nlet animating = true;\n\n/** How much pixels near the bounds user has to drag to start scrolling */\nconst DRAGGING_TO_SCROLL_TRESHOLD = 40;\n\n/** How much pixels does the view scroll when dragging */\nconst DRAGGING_TO_SCROLL_DELTA = 40;\nfunction outOfBounds(event, rect) {\n  return {\n    left: event.clientX - rect.left < 0 + DRAGGING_TO_SCROLL_TRESHOLD,\n    top: event.clientY - rect.top < 0 + DRAGGING_TO_SCROLL_TRESHOLD,\n    right: event.clientX - rect.left > rect.width - DRAGGING_TO_SCROLL_TRESHOLD,\n    bottom: event.clientY - rect.top > rect.height - DRAGGING_TO_SCROLL_TRESHOLD\n  };\n}\nfunction instance$d($$self, $$props, $$invalidate) {\n  let $rowStore;\n  let $draggingTaskCache;\n  let $rowPadding;\n  let $taskStore;\n  let $selectedTasks;\n  let {\n    model\n  } = $$props;\n  let {\n    height\n  } = $$props;\n  let {\n    left\n  } = $$props;\n  let {\n    top\n  } = $$props;\n  let {\n    topDelta = 0\n  } = $$props;\n  let {\n    width\n  } = $$props;\n  let {\n    reflected = false\n  } = $$props;\n  let _dragging = false;\n  let _resizing = false;\n  let _position = {\n    x: left,\n    y: top + topDelta,\n    width\n  };\n  function updatePosition(x, y, width) {\n    if (!_dragging && !_resizing) {\n      $$invalidate(5, _position.x = x, _position);\n      $$invalidate(5, _position.y = y, _position);\n      $$invalidate(5, _position.width = width, _position);\n    } // should NOT animate on resize/update of columns\n  }\n  const {\n    taskStore,\n    rowStore,\n    draggingTaskCache\n  } = getContext('dataStore');\n  component_subscribe($$self, taskStore, value => $$invalidate(26, $taskStore = value));\n  component_subscribe($$self, rowStore, value => $$invalidate(22, $rowStore = value));\n  component_subscribe($$self, draggingTaskCache, value => $$invalidate(24, $draggingTaskCache = value));\n  const {\n    rowContainer,\n    mainContainer\n  } = getContext('gantt');\n  const {\n    taskContent,\n    resizeHandleWidth,\n    rowPadding,\n    onTaskButtonClick,\n    reflectOnParentRows,\n    reflectOnChildRows,\n    taskElementHook\n  } = getContext('options');\n  component_subscribe($$self, rowPadding, value => $$invalidate(25, $rowPadding = value));\n  const {\n    dndManager,\n    api,\n    utils,\n    columnService,\n    selectionManager\n  } = getContext('services');\n  let selectedTasks = selectionManager.selectedTasks;\n  component_subscribe($$self, selectedTasks, value => $$invalidate(8, $selectedTasks = value));\n\n  /** Bounds of the main gantt area, changes only on window resize */\n  let mainContainerRect;\n  const scrollIfOutOfBounds = throttle(event => {\n    // throttle the following\n    const bounds = outOfBounds(event, mainContainerRect);\n    if (bounds.left || bounds.right) {\n      // scroll left\n      mainContainer.scrollTo({\n        left: mainContainer.scrollLeft + (bounds.left ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),\n        behavior: 'smooth'\n      });\n    }\n    if (bounds.top || bounds.bottom) {\n      // scroll top\n      mainContainer.scrollTo({\n        top: mainContainer.scrollTop + (bounds.top ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),\n        behavior: 'smooth'\n      });\n    }\n  }, 250);\n  function drag(_) {\n    function onDrop(event) {\n      let rowChangeValid = true;\n\n      //row switching\n      const sourceRow = $rowStore.entities[model.resourceId];\n      if (event.dragging) {\n        const targetRow = dndManager.getTarget('row', event.mouseEvent);\n        if (targetRow) {\n          $$invalidate(0, model.resourceId = targetRow.model.id, model);\n          api.tasks.raise.switchRow(this, targetRow, sourceRow);\n        } else {\n          rowChangeValid = false;\n        }\n      }\n      $$invalidate(3, _dragging = $$invalidate(4, _resizing = false));\n      const task = $taskStore.entities[model.id];\n      delete $draggingTaskCache[model.id];\n      if (rowChangeValid) {\n        const prevFrom = model.from;\n        const prevTo = model.to;\n        const newFrom = $$invalidate(0, model.from = utils.roundTo(columnService.getDateByPosition(event.x)), model);\n        const newTo = $$invalidate(0, model.to = utils.roundTo(columnService.getDateByPosition(event.x + event.width)), model);\n        const newLeft = columnService.getPositionByDate(newFrom) | 0;\n        const newRight = columnService.getPositionByDate(newTo) | 0;\n        const targetRow = $rowStore.entities[model.resourceId];\n        const left = newLeft;\n        const width = newRight - newLeft;\n        const top = $rowPadding + targetRow.y;\n        updatePosition(left, top + topDelta, width);\n        const newTask = {\n          ...task,\n          left,\n          width,\n          top,\n          model\n        };\n        const changed = prevFrom != newFrom || prevTo != newTo || sourceRow && sourceRow.model.id !== targetRow.model.id;\n        if (changed) {\n          api.tasks.raise.change({\n            task: newTask,\n            sourceRow,\n            targetRow\n          });\n        }\n        selectionManager.newTasksAndReflections.push(newTask);\n        if (changed) {\n          api.tasks.raise.changed({\n            task: newTask,\n            sourceRow,\n            targetRow\n          });\n        }\n\n        // update shadow tasks\n        if (newTask.reflections) {\n          selectionManager.oldReflections.push(...newTask.reflections);\n        }\n        const reflectedTasks = [];\n        if (reflectOnChildRows && targetRow.allChildren) {\n          if (!newTask.reflections) newTask.reflections = [];\n          const opts = {\n            rowPadding: $rowPadding\n          };\n          targetRow.allChildren.forEach(r => {\n            const reflectedTask = reflectTask(newTask, r, opts);\n            newTask.reflections.push(reflectedTask.model.id);\n            reflectedTasks.push(reflectedTask);\n          });\n        }\n        if (reflectOnParentRows && targetRow.allParents.length > 0) {\n          if (!newTask.reflections) newTask.reflections = [];\n          const opts = {\n            rowPadding: $rowPadding\n          };\n          targetRow.allParents.forEach(r => {\n            const reflectedTask = reflectTask(newTask, r, opts);\n            newTask.reflections.push(reflectedTask.model.id);\n            reflectedTasks.push(reflectedTask);\n          });\n        }\n        if (reflectedTasks.length > 0) {\n          selectionManager.newTasksAndReflections.push(...reflectedTasks);\n        }\n        if (!(targetRow.allParents.length > 0) && !targetRow.allChildren) {\n          newTask.reflections = null;\n        }\n      } else {\n        // reset position\n        $$invalidate(5, _position.x = task.left, _position), $$invalidate(5, _position.width = task.width, _position), $$invalidate(5, _position.y = task.top, _position);\n      }\n    }\n    if (!reflected) {\n      // reflected tasks must not be resized or dragged\n      selectionManager.taskSettings.set(model.id.toString(), {\n        onDown: event => {\n          mainContainerRect = mainContainer.getBoundingClientRect();\n          if (event.dragging) {\n            setCursor('move');\n          }\n          if (event.resizing) {\n            setCursor('e-resize');\n          }\n          set_store_value(draggingTaskCache, $draggingTaskCache[model.id] = true, $draggingTaskCache);\n        },\n        onMouseUp: () => {\n          setCursor('default');\n          api.tasks.raise.moveEnd(model);\n        },\n        onResize: event => {\n          $$invalidate(5, _position.x = event.x, _position);\n          $$invalidate(5, _position.width = event.width, _position);\n          $$invalidate(4, _resizing = true);\n          scrollIfOutOfBounds(event.event);\n        },\n        onDrag: event => {\n          $$invalidate(5, _position.x = event.x, _position);\n          $$invalidate(5, _position.y = event.y, _position);\n          $$invalidate(3, _dragging = true);\n          api.tasks.raise.move(model);\n          scrollIfOutOfBounds(event.event);\n        },\n        dragAllowed: () => {\n          return $rowStore.entities[model.resourceId].model.enableDragging && model.enableDragging;\n        },\n        resizeAllowed: () => {\n          return model.type !== 'milestone' && $rowStore.entities[model.resourceId].model.enableDragging && model.enableDragging;\n        },\n        onDrop,\n        container: rowContainer,\n        resizeHandleWidth,\n        getX: () => _position.x,\n        getY: () => _position.y,\n        getWidth: () => _position.width,\n        modelId: model.id\n      });\n      return {\n        destroy: () => selectionManager.taskSettings.delete(model.id.toString())\n      };\n    }\n  }\n  function taskElement(node, model) {\n    if (taskElementHook) {\n      return taskElementHook(node, model);\n    }\n  }\n  function onClick(event) {\n    if (onTaskButtonClick) {\n      onTaskButtonClick(model, event);\n    }\n  }\n  let classes;\n  let resizeEnabled;\n  $$self.$$set = $$props => {\n    if ('model' in $$props) $$invalidate(0, model = $$props.model);\n    if ('height' in $$props) $$invalidate(1, height = $$props.height);\n    if ('left' in $$props) $$invalidate(18, left = $$props.left);\n    if ('top' in $$props) $$invalidate(19, top = $$props.top);\n    if ('topDelta' in $$props) $$invalidate(20, topDelta = $$props.topDelta);\n    if ('width' in $$props) $$invalidate(21, width = $$props.width);\n    if ('reflected' in $$props) $$invalidate(2, reflected = $$props.reflected);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty[0] & /*left, top, topDelta, width*/3932160) {\n      updatePosition(left, top + topDelta, width);\n    }\n    if ($$self.$$.dirty[0] & /*model*/1) {\n      {\n        $$invalidate(6, classes = normalizeClassAttr(model.classes));\n      }\n    }\n    if ($$self.$$.dirty[0] & /*model, $rowStore*/4194305) {\n      {\n        $$invalidate(7, resizeEnabled = model.type !== 'milestone' && $rowStore.entities[model.resourceId].model.enableDragging && model.enableDragging);\n      }\n    }\n  };\n  return [model, height, reflected, _dragging, _resizing, _position, classes, resizeEnabled, $selectedTasks, taskStore, rowStore, draggingTaskCache, taskContent, rowPadding, selectedTasks, drag, taskElement, onClick, left, top, topDelta, width, $rowStore];\n}\nclass Task extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$d, create_fragment$d, safe_not_equal, {\n      model: 0,\n      height: 1,\n      left: 18,\n      top: 19,\n      topDelta: 20,\n      width: 21,\n      reflected: 2\n    }, null, [-1, -1]);\n  }\n}\nvar css_248z$d = \".sg-row.svelte-7u5y5s{position:relative;width:100%;box-sizing:border-box}\";\nstyleInject(css_248z$d);\n\n/* src\\entities\\Row.svelte generated by Svelte v4.2.1 */\n\nfunction create_if_block$5(ctx) {\n  let html_tag;\n  let raw_value = /*row*/ctx[0].model.contentHtml + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/1 && raw_value !== (raw_value = /*row*/ctx[0].model.contentHtml + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\nfunction create_fragment$c(ctx) {\n  let div;\n  let div_class_value;\n  let div_data_row_id_value;\n  let if_block = /*row*/ctx[0].model.contentHtml && create_if_block$5(ctx);\n  return {\n    c() {\n      div = element(\"div\");\n      if (if_block) if_block.c();\n      attr(div, \"class\", div_class_value = \"sg-row \" + /*row*/ctx[0].model.classes + \" svelte-7u5y5s\");\n      attr(div, \"data-row-id\", div_data_row_id_value = /*row*/ctx[0].model.id);\n      set_style(div, \"height\", /*$rowHeight*/ctx[3] + \"px\");\n      toggle_class(div, \"sg-hover\", /*$hoveredRow*/ctx[1] == /*row*/ctx[0].model.id);\n      toggle_class(div, \"sg-selected\", /*$selectedRow*/ctx[2] == /*row*/ctx[0].model.id);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (if_block) if_block.m(div, null);\n    },\n    p(ctx, [dirty]) {\n      if ( /*row*/ctx[0].model.contentHtml) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$5(ctx);\n          if_block.c();\n          if_block.m(div, null);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n      if (dirty & /*row*/1 && div_class_value !== (div_class_value = \"sg-row \" + /*row*/ctx[0].model.classes + \" svelte-7u5y5s\")) {\n        attr(div, \"class\", div_class_value);\n      }\n      if (dirty & /*row*/1 && div_data_row_id_value !== (div_data_row_id_value = /*row*/ctx[0].model.id)) {\n        attr(div, \"data-row-id\", div_data_row_id_value);\n      }\n      if (dirty & /*$rowHeight*/8) {\n        set_style(div, \"height\", /*$rowHeight*/ctx[3] + \"px\");\n      }\n      if (dirty & /*row, $hoveredRow, row*/3) {\n        toggle_class(div, \"sg-hover\", /*$hoveredRow*/ctx[1] == /*row*/ctx[0].model.id);\n      }\n      if (dirty & /*row, $selectedRow, row*/5) {\n        toggle_class(div, \"sg-selected\", /*$selectedRow*/ctx[2] == /*row*/ctx[0].model.id);\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (if_block) if_block.d();\n    }\n  };\n}\nfunction instance$c($$self, $$props, $$invalidate) {\n  let $hoveredRow;\n  let $selectedRow;\n  let $rowHeight;\n  let {\n    row\n  } = $$props;\n  const {\n    rowHeight\n  } = getContext('options');\n  component_subscribe($$self, rowHeight, value => $$invalidate(3, $rowHeight = value));\n  const {\n    hoveredRow,\n    selectedRow\n  } = getContext('gantt');\n  component_subscribe($$self, hoveredRow, value => $$invalidate(1, $hoveredRow = value));\n  component_subscribe($$self, selectedRow, value => $$invalidate(2, $selectedRow = value));\n  $$self.$$set = $$props => {\n    if ('row' in $$props) $$invalidate(0, row = $$props.row);\n  };\n  return [row, $hoveredRow, $selectedRow, $rowHeight, rowHeight, hoveredRow, selectedRow];\n}\nclass Row extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$c, create_fragment$c, safe_not_equal, {\n      row: 0\n    });\n  }\n}\nvar css_248z$c = \".sg-time-range.svelte-w7p5la{height:100%;position:absolute;display:flex;flex-direction:column;align-items:center;background-image:linear-gradient(\\r\\n            -45deg,\\r\\n            rgba(0, 0, 0, 0) 46%,\\r\\n            #e03218 49%,\\r\\n            #e03218 51%,\\r\\n            rgba(0, 0, 0, 0) 55%\\r\\n        );background-size:6px 6px !important;color:red;font-weight:400}.sg-time-range-label.svelte-w7p5la{margin-top:10px;background:#fff;white-space:nowrap;padding:4px;font-weight:400;font-size:10px}\";\nstyleInject(css_248z$c);\n\n/* src\\entities\\TimeRange.svelte generated by Svelte v4.2.1 */\n\nfunction create_if_block$4(ctx) {\n  let div;\n  let t_value = /*model*/ctx[0].label + \"\";\n  let t;\n  return {\n    c() {\n      div = element(\"div\");\n      t = text(t_value);\n      attr(div, \"class\", \"sg-time-range-label svelte-w7p5la\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, t);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*model*/1 && t_value !== (t_value = /*model*/ctx[0].label + \"\")) set_data(t, t_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\nfunction create_fragment$b(ctx) {\n  let div;\n  let div_class_value;\n  let if_block = /*model*/ctx[0].label && create_if_block$4(ctx);\n  return {\n    c() {\n      div = element(\"div\");\n      if (if_block) if_block.c();\n      attr(div, \"class\", div_class_value = \"sg-time-range \" + /*classes*/ctx[3] + \" svelte-w7p5la\");\n      set_style(div, \"width\", /*_position*/ctx[2].width + \"px\");\n      set_style(div, \"left\", /*_position*/ctx[2].x + \"px\");\n      toggle_class(div, \"moving\", /*resizing*/ctx[1]);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (if_block) if_block.m(div, null);\n    },\n    p(ctx, [dirty]) {\n      if ( /*model*/ctx[0].label) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$4(ctx);\n          if_block.c();\n          if_block.m(div, null);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n      if (dirty & /*classes*/8 && div_class_value !== (div_class_value = \"sg-time-range \" + /*classes*/ctx[3] + \" svelte-w7p5la\")) {\n        attr(div, \"class\", div_class_value);\n      }\n      if (dirty & /*_position*/4) {\n        set_style(div, \"width\", /*_position*/ctx[2].width + \"px\");\n      }\n      if (dirty & /*_position*/4) {\n        set_style(div, \"left\", /*_position*/ctx[2].x + \"px\");\n      }\n      if (dirty & /*classes, resizing*/10) {\n        toggle_class(div, \"moving\", /*resizing*/ctx[1]);\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (if_block) if_block.d();\n    }\n  };\n}\nfunction instance$b($$self, $$props, $$invalidate) {\n  let {\n    model\n  } = $$props;\n  let {\n    left\n  } = $$props;\n  let {\n    width\n  } = $$props;\n  let {\n    resizing = false\n  } = $$props;\n  const _position = {\n    width,\n    x: left\n  };\n  let classes;\n  $$self.$$set = $$props => {\n    if ('model' in $$props) $$invalidate(0, model = $$props.model);\n    if ('left' in $$props) $$invalidate(4, left = $$props.left);\n    if ('width' in $$props) $$invalidate(5, width = $$props.width);\n    if ('resizing' in $$props) $$invalidate(1, resizing = $$props.resizing);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*left, width*/48) {\n      {\n        $$invalidate(2, _position.x = left, _position);\n        $$invalidate(2, _position.width = width, _position);\n      }\n    }\n    if ($$self.$$.dirty & /*model*/1) {\n      {\n        $$invalidate(3, classes = normalizeClassAttr(model.classes));\n      }\n    }\n  };\n  return [model, resizing, _position, classes, left, width];\n}\nclass TimeRange extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$b, create_fragment$b, safe_not_equal, {\n      model: 0,\n      left: 4,\n      width: 5,\n      resizing: 1\n    });\n  }\n}\nconst MIN_DRAG_X = 2;\nconst MIN_DRAG_Y = 2;\n\n/**\n * Applies dragging interaction to gantt elements\n */\nclass Draggable {\n  mouseStartPosX;\n  mouseStartPosY;\n  mouseStartRight;\n  direction;\n  dragging = false;\n  resizing = false;\n  initialX;\n  initialY;\n  initialW;\n  resizeTriggered = false;\n  settings;\n  node;\n  offsetPos = {\n    x: null,\n    y: null\n  };\n  offsetWidth = null;\n  overRezisedOffset;\n  constructor(node, settings, offsetData) {\n    this.settings = settings;\n    this.node = node;\n    if (this.settings.modelId) {\n      this.offsetPos = offsetData.offsetPos;\n      this.offsetWidth = offsetData.offsetWidth;\n    } else {\n      node.addEventListener('mousedown', this.onmousedown, {\n        passive: true\n      });\n    }\n  }\n  get dragAllowed() {\n    if (typeof this.settings.dragAllowed === 'function') {\n      return this.settings.dragAllowed();\n    } else {\n      return this.settings.dragAllowed;\n    }\n  }\n  get resizeAllowed() {\n    if (typeof this.settings.resizeAllowed === 'function') {\n      return this.settings.resizeAllowed();\n    } else {\n      return this.settings.resizeAllowed;\n    }\n  }\n  onmousedown = event => {\n    const offsetEvent = {\n      clientX: this.offsetPos.x + event.clientX,\n      clientY: this.offsetPos.y + event.clientY\n    };\n    if (!isLeftClick(event) && !this.settings.modelId) {\n      return;\n    }\n    if (!this.settings.modelId) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n    const canDrag = this.dragAllowed;\n    const canResize = this.resizeAllowed;\n    if (canDrag || canResize) {\n      const x = this.settings.getX();\n      const y = this.settings.getY();\n      const width = this.settings.getWidth();\n      this.initialX = offsetEvent.clientX;\n      this.initialY = offsetEvent.clientY;\n      this.mouseStartRight = x + width;\n      this.mouseStartPosX = getRelativePos(this.settings.container, offsetEvent).x - x;\n      this.mouseStartPosY = getRelativePos(this.settings.container, offsetEvent).y - y;\n      if (canResize && this.mouseStartPosX <= this.settings.resizeHandleWidth) {\n        this.direction = 'left';\n        this.resizing = true;\n      }\n      if (canResize && this.mouseStartPosX >= width - this.offsetWidth - this.settings.resizeHandleWidth) {\n        this.direction = 'right';\n        this.resizing = true;\n      }\n      if (canDrag && !this.resizing) {\n        this.dragging = true;\n      }\n      if ((this.dragging || this.resizing) && this.settings.onDown) {\n        this.settings.onDown({\n          mouseEvent: offsetEvent,\n          x,\n          width,\n          y,\n          resizing: this.resizing,\n          dragging: this.dragging\n        });\n      }\n      if (!this.settings.modelId) {\n        window.addEventListener('mousemove', this.onmousemove, false);\n        addEventListenerOnce(window, 'mouseup', this.onmouseup);\n      }\n    }\n  };\n  onmousemove = event => {\n    const offsetEvent = {\n      clientX: this.offsetPos.x + event.clientX,\n      clientY: this.offsetPos.y + event.clientY\n    };\n    if (!this.resizeTriggered) {\n      if (Math.abs(offsetEvent.clientX - this.initialX) > MIN_DRAG_X || Math.abs(offsetEvent.clientY - this.initialY) > MIN_DRAG_Y) {\n        this.resizeTriggered = true;\n      } else {\n        return;\n      }\n    }\n    event.preventDefault();\n    if (this.resizing) {\n      const mousePos = getRelativePos(this.settings.container, offsetEvent);\n      const x = this.settings.getX();\n      const width = this.settings.getWidth();\n      let resultX;\n      let resultWidth;\n      if (this.direction === 'left') {\n        //resize left\n        if (this.overRezisedOffset === 'left') {\n          mousePos.x += this.offsetWidth;\n        }\n        if (this.mouseStartRight - mousePos.x <= 0) {\n          this.direction = 'right';\n          if (this.overRezisedOffset !== 'left') {\n            this.overRezisedOffset = 'right';\n          } else {\n            this.overRezisedOffset = undefined;\n          }\n          resultX = this.mouseStartRight;\n          resultWidth = this.mouseStartRight - mousePos.x;\n          this.mouseStartRight = this.mouseStartRight + width;\n        } else {\n          resultX = mousePos.x;\n          resultWidth = this.mouseStartRight - mousePos.x;\n        }\n      } else if (this.direction === 'right') {\n        //resize right\n        if (this.overRezisedOffset === 'right') {\n          mousePos.x -= this.offsetWidth;\n        }\n        if (mousePos.x - x + this.offsetWidth <= 0) {\n          this.direction = 'left';\n          if (this.overRezisedOffset !== 'right') {\n            this.overRezisedOffset = 'left';\n          } else {\n            this.overRezisedOffset = undefined;\n          }\n          resultX = mousePos.x + this.offsetWidth;\n          resultWidth = mousePos.x - x + this.offsetWidth;\n          this.mouseStartRight = x;\n        } else {\n          resultX = x;\n          resultWidth = mousePos.x - x + this.offsetWidth;\n        }\n      }\n      if (this.settings.onResize) {\n        this.settings.onResize({\n          x: resultX,\n          width: resultWidth,\n          event\n        });\n      }\n    }\n    // mouseup\n    if (this.dragging && this.settings.onDrag) {\n      const mousePos = getRelativePos(this.settings.container, offsetEvent);\n      this.settings.onDrag({\n        x: mousePos.x - this.mouseStartPosX,\n        y: mousePos.y - this.mouseStartPosY,\n        event\n      });\n    }\n  };\n  onmouseup = event => {\n    const offsetEvent = {\n      clientX: this.offsetPos.x + event.clientX,\n      clientY: this.offsetPos.y + event.clientY\n    };\n    const x = this.settings.getX();\n    const y = this.settings.getY();\n    const width = this.settings.getWidth();\n    this.settings.onMouseUp && this.settings.onMouseUp();\n    if (this.resizeTriggered && this.settings.onDrop) {\n      this.settings.onDrop({\n        mouseEvent: offsetEvent,\n        x,\n        y,\n        width,\n        dragging: this.dragging,\n        resizing: this.resizing\n      });\n    }\n    this.mouseStartPosX = null;\n    this.mouseStartPosY = null;\n    this.mouseStartRight = null;\n    this.dragging = false;\n    this.resizing = false;\n    this.initialX = null;\n    this.initialY = null;\n    this.initialW = null;\n    this.resizeTriggered = false;\n    this.offsetPos = {\n      x: null,\n      y: null\n    };\n    this.offsetWidth = null;\n    this.overRezisedOffset = undefined;\n    if (!this.settings.modelId) window.removeEventListener('mousemove', this.onmousemove, false);\n  };\n  destroy() {\n    this.node.removeEventListener('mousedown', this.onmousedown, false);\n    this.node.removeEventListener('mousemove', this.onmousemove, false);\n    this.node.removeEventListener('mouseup', this.onmouseup, false);\n  }\n}\nclass DragDropManager {\n  handlerMap = {};\n  constructor(rowStore) {\n    this.register('row', event => {\n      let elements = document.elementsFromPoint(event.clientX, event.clientY);\n      let rowElement = elements.find(element => !!element.getAttribute('data-row-id'));\n      if (rowElement !== undefined) {\n        const rowId = rowElement.getAttribute('data-row-id');\n        const {\n          entities\n        } = get_store_value(rowStore);\n        const targetRow = entities[rowId];\n        if (targetRow.model.enableDragging) {\n          return targetRow;\n        }\n      }\n      return null;\n    });\n  }\n  register(target, handler) {\n    this.handlerMap[target] = handler;\n  }\n  getTarget(target, event) {\n    var handler = this.handlerMap[target];\n    if (handler) {\n      return handler(event);\n    }\n  }\n}\nvar css_248z$b = \".sg-time-range-control.svelte-w4nglp{position:absolute}.sg-time-range-handle-left.svelte-w4nglp{position:absolute;left:0}.sg-time-range-handle-right.svelte-w4nglp{position:absolute;right:0}.sg-time-range-disabled.svelte-w4nglp{display:none}.sg-time-range-handle-left.svelte-w4nglp::before,.sg-time-range-handle-right.svelte-w4nglp::before{position:absolute;content:'';bottom:4px;border-radius:6px 6px 6px 0;border:2px solid #b0b0b7;width:9px;height:9px;transform:translateX(-50%) rotate(-45deg);background-color:#fff;border-color:#e03218;cursor:ew-resize}\";\nstyleInject(css_248z$b);\n\n/* src\\entities\\TimeRangeHeader.svelte generated by Svelte v4.2.1 */\n\nfunction create_fragment$a(ctx) {\n  let div2;\n  let div0;\n  let t;\n  let div1;\n  let div2_class_value;\n  let mounted;\n  let dispose;\n  return {\n    c() {\n      div2 = element(\"div\");\n      div0 = element(\"div\");\n      t = space();\n      div1 = element(\"div\");\n      attr(div0, \"class\", \"sg-time-range-handle-left svelte-w4nglp\");\n      attr(div1, \"class\", \"sg-time-range-handle-right svelte-w4nglp\");\n      attr(div2, \"class\", div2_class_value = \"sg-time-range-control \" + /*classes*/ctx[1] + \" svelte-w4nglp\");\n      set_style(div2, \"width\", /*_position*/ctx[0].width + \"px\");\n      set_style(div2, \"left\", /*_position*/ctx[0].x + \"px\");\n      toggle_class(div2, \"sg-time-range-disabled\", ! /*isResizable*/ctx[3]());\n    },\n    m(target, anchor) {\n      insert(target, div2, anchor);\n      append(div2, div0);\n      append(div2, t);\n      append(div2, div1);\n      if (!mounted) {\n        dispose = [action_destroyer( /*drag*/ctx[2].call(null, div0)), action_destroyer( /*drag*/ctx[2].call(null, div1))];\n        mounted = true;\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*classes*/2 && div2_class_value !== (div2_class_value = \"sg-time-range-control \" + /*classes*/ctx[1] + \" svelte-w4nglp\")) {\n        attr(div2, \"class\", div2_class_value);\n      }\n      if (dirty & /*_position*/1) {\n        set_style(div2, \"width\", /*_position*/ctx[0].width + \"px\");\n      }\n      if (dirty & /*_position*/1) {\n        set_style(div2, \"left\", /*_position*/ctx[0].x + \"px\");\n      }\n      if (dirty & /*classes, isResizable*/10) {\n        toggle_class(div2, \"sg-time-range-disabled\", ! /*isResizable*/ctx[3]());\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div2);\n      }\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\nfunction instance$a($$self, $$props, $$invalidate) {\n  const {\n    rowContainer\n  } = getContext('gantt');\n  const {\n    api,\n    utils,\n    columnService\n  } = getContext('services');\n  const {\n    resizeHandleWidth\n  } = getContext('options');\n  const {\n    timeRangeStore\n  } = getContext('dataStore');\n  let {\n    model\n  } = $$props;\n  let {\n    width\n  } = $$props;\n  let {\n    left\n  } = $$props;\n  const _position = {\n    width,\n    x: left\n  };\n  function drag(node) {\n    const ondrop = event => {\n      const newFrom = utils.roundTo(columnService.getDateByPosition(event.x));\n      const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\n      const newLeft = columnService.getPositionByDate(newFrom);\n      const newRight = columnService.getPositionByDate(newTo);\n      Object.assign(model, {\n        from: newFrom,\n        to: newTo\n      });\n      update({\n        left: newLeft,\n        width: newRight - newLeft,\n        model,\n        resizing: false\n      });\n      window.removeEventListener('mousemove', onmousemove, false);\n    };\n    function update(state) {\n      timeRangeStore.update(state);\n      $$invalidate(0, _position.x = state.left, _position);\n      $$invalidate(0, _position.width = state.width, _position);\n    }\n    const draggable = new Draggable(node, {\n      onDown: event => {\n        api.timeranges.raise.clicked({\n          model\n        });\n        update({\n          left: event.x,\n          width: event.width,\n          model,\n          resizing: true\n        });\n      },\n      onResize: event => {\n        api.timeranges.raise.resized({\n          model,\n          left: event.x,\n          width: event.width\n        });\n        update({\n          left: event.x,\n          width: event.width,\n          model,\n          resizing: true\n        });\n      },\n      dragAllowed: false,\n      resizeAllowed: () => isResizable(),\n      onDrop: ondrop,\n      container: rowContainer,\n      resizeHandleWidth,\n      getX: () => _position.x,\n      getY: () => 0,\n      getWidth: () => _position.width\n    });\n    return {\n      destroy: () => draggable.destroy()\n    };\n  }\n  function isResizable() {\n    return model.resizable !== undefined ? model.resizable : true;\n  }\n  let classes;\n  $$self.$$set = $$props => {\n    if ('model' in $$props) $$invalidate(4, model = $$props.model);\n    if ('width' in $$props) $$invalidate(5, width = $$props.width);\n    if ('left' in $$props) $$invalidate(6, left = $$props.left);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*left, width*/96) {\n      {\n        $$invalidate(0, _position.x = left, _position), $$invalidate(0, _position.width = width, _position);\n      }\n    }\n    if ($$self.$$.dirty & /*model*/16) {\n      {\n        $$invalidate(1, classes = normalizeClassAttr(model.classes));\n      }\n    }\n  };\n  return [_position, classes, drag, isResizable, model, width, left];\n}\nclass TimeRangeHeader extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$a, create_fragment$a, safe_not_equal, {\n      model: 4,\n      width: 5,\n      left: 6\n    });\n  }\n}\nvar css_248z$a = \".column.svelte-4fffin{position:absolute;height:100%;box-sizing:border-box}.column.svelte-4fffin{border-right:#efefef 1px solid}\";\nstyleInject(css_248z$a);\nfunction getDuration(unit, offset = 1) {\n  switch (unit) {\n    case 'y':\n    case 'year':\n      return offset * 31536000000;\n    case 'month':\n      return offset * 30 * 24 * 60 * 60 * 1000;\n    // incorrect since months are of different durations\n    // 4 cases : 28 - 29 - 30 - 31\n    case 'week':\n      return offset * 7 * 24 * 60 * 60 * 1000;\n    case 'd':\n    case 'day':\n      return offset * 24 * 60 * 60 * 1000;\n    case 'h':\n    case 'hour':\n      return offset * 60 * 60 * 1000;\n    case 'm':\n    case 'minute':\n      return offset * 60 * 1000;\n    case 's':\n    case 'second':\n      return offset * 1000;\n    default:\n      throw new Error(`Unknown unit: ${unit}`);\n  }\n}\nfunction addSeconds(date, offset = 1) {\n  date.setSeconds(date.getSeconds() + offset);\n  return date;\n}\nfunction addMinutes(date, offset = 1) {\n  date.setMinutes(date.getMinutes() + offset);\n  return date;\n}\nfunction addHours(date, offset = 1) {\n  date.setHours(date.getHours() + offset);\n  return date;\n}\nfunction addDays(date, offset = 1) {\n  date.setDate(date.getDate() + offset);\n  date.setHours(0, 0, 0);\n  return date;\n}\nfunction addWeeks(date, offset = 1) {\n  const d = date;\n  const day = d.getDay();\n  const diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday\n  d.setDate(diff);\n  d.setHours(0, 0, 0);\n  d.setDate(d.getDate() + 7 * offset);\n  return d;\n}\nfunction addMonths(date, offset = 1) {\n  date.setMonth(date.getMonth() + offset);\n  date.setDate(1);\n  date.setHours(0, 0, 0);\n  return date;\n}\nfunction addYears(date, offset = 1) {\n  date.setFullYear(date.getFullYear() + offset);\n  date.setMonth(0);\n  date.setDate(1);\n  date.setHours(0, 0, 0);\n  return date;\n}\nfunction getNextDate(date, unit, offset) {\n  switch (unit) {\n    case 'y':\n    case 'year':\n      return addYears(date, offset);\n    case 'month':\n      return addMonths(date, offset);\n    case 'week':\n      return addWeeks(date, offset);\n    case 'd':\n    case 'day':\n      return addDays(date, offset);\n    case 'h':\n    case 'hour':\n      return addHours(date, offset);\n    case 'm':\n    case 'minute':\n      return addMinutes(date, offset);\n    case 's':\n    case 'second':\n      return addSeconds(date, offset);\n  }\n}\nconst units = ['y', 'year', 'month', 'week', 'd', 'day', 'h', 'hour', 'm', 'minute', 's', 'second'];\n/**\n *\n * @param from Interval start\n * @param to Interval end\n * @param unit Column unit\n * @param offset Column spacing\n * @param highlightedDurations\n * @returns\n */\nfunction getAllPeriods(from, to, unit, offset = 1, highlightedDurations) {\n  if (units.indexOf(unit) !== -1) {\n    let tmsWorkOld = 0;\n    let interval_duration = 0;\n    const start = new Date(from); // Starts at hh:mm:ss\n    const dateWork = new Date(from);\n    let nextDate = getNextDate(dateWork, unit, offset);\n    let tmsWork = nextDate.getTime();\n    const firstDuration = nextDate.getTime() - from;\n    const all_periods = [{\n      // start: start,\n      // end: nextDate,\n      from: from,\n      // from: startOf(from, unit), // incorrect if not circled down to the unit eg. 6:30\n      // TODO: think about offsetting the whole row, so for example if timeline starts at 6:30, the headers still show times for 6:00, 7:00 etc, and not 6:30, 7:30...\n      to: nextDate.getTime(),\n      duration: firstDuration,\n      // check whether duration is highlighted\n      isHighlighted: highlightedDurations && isUnitFraction(start, highlightedDurations)\n    }];\n    if (tmsWork < to) {\n      while (tmsWork < to) {\n        tmsWorkOld = tmsWork;\n        nextDate = getNextDate(new Date(tmsWork), unit, offset);\n        interval_duration = nextDate.getTime() - tmsWork;\n        all_periods.push({\n          from: tmsWork,\n          to: nextDate.getTime(),\n          duration: interval_duration,\n          //check whether duration is highlighted\n          isHighlighted: highlightedDurations && isUnitFraction(new Date(tmsWork), highlightedDurations)\n        });\n        tmsWork = nextDate.getTime();\n      }\n      const last_day_duration = to - tmsWorkOld;\n      all_periods[all_periods.length - 1].to = to;\n      all_periods[all_periods.length - 1].duration = last_day_duration;\n      // ToDo: there could be another option for hours, minutes, seconds based on pure math like in getPeriodDuration to optimise performance\n    }\n    return all_periods;\n  }\n  throw new Error(`Unknown unit: ${unit}`);\n}\nfunction isUnitFraction(localDate, highlightedDurations) {\n  // const localDate = new Date(timestamp * 1000);\n  let timeInUnit;\n  switch (highlightedDurations.unit) {\n    case 'm':\n    case 'minute':\n      timeInUnit = localDate.getMinutes();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'h':\n    case 'hour':\n      timeInUnit = localDate.getHours();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'd':\n    case 'day':\n      timeInUnit = localDate.getDay();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'week':\n      // getWeekNumber(localDate);\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'dayinMonth':\n      timeInUnit = localDate.getDate();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'month':\n      timeInUnit = localDate.getMonth();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    case 'y':\n    case 'year':\n      timeInUnit = localDate.getFullYear();\n      return highlightedDurations.fractions.includes(timeInUnit);\n    default:\n      throw new Error(`Invalid unit: ${highlightedDurations.unit}`);\n  }\n}\nclass GanttUtils {\n  from;\n  to;\n  width;\n  magnetOffset;\n  magnetUnit;\n  magnetDuration;\n  dateAdapter;\n  /** because gantt width is not always correct */\n  /**BlueFox 09.01.23: couldn't reproduce the above so I removed the code\n  //totalColumnDuration: number;\n  //totalColumnWidth: number;\n   constructor() {\n  }\n   /**\n   * Returns position of date on a line if from and to represent length of width\n   * @param {*} date\n   */\n  getPositionByDate(date) {\n    return getPositionByDate(date, this.from, this.to, this.width);\n  }\n  getDateByPosition(x) {\n    return getDateByPosition(x, this.from, this.to, this.width);\n  }\n  roundTo(date) {\n    if (this.dateAdapter) {\n      return this.dateAdapter.roundTo(date, this.magnetUnit, this.magnetOffset);\n    }\n    // this does not consider the timezone, rounds only to the UTC time\n    // let value = Math.round((date - 7200000) / this.magnetDuration) * this.magnetDuration;\n    // cases where rounding to day or timezone offset is not rounded, this won't work\n    return null;\n  }\n}\nfunction getPositionByDate(date, from, to, width) {\n  if (!date) {\n    return undefined;\n  }\n  const durationTo = date - from;\n  const durationToEnd = to - from;\n  return durationTo / durationToEnd * width;\n}\nfunction getDateByPosition(x, from, to, width) {\n  const durationTo = x / width * (to - from);\n  const dateAtPosition = from + durationTo;\n  return dateAtPosition;\n}\n// Returns the object on the left and right in an array using the given cmp function.\n// The compare function defined which property of the value to compare (e.g.: c => c.left)\nfunction getIndicesOnly(input, value, comparer, strict) {\n  let lo = -1;\n  let hi = input.length;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (strict ? comparer(input[mid]) < value : comparer(input[mid]) <= value) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  if (!strict && input[lo] !== undefined && comparer(input[lo]) === value) {\n    hi = lo;\n  }\n  return [lo, hi];\n}\nfunction get(input, value, comparer, strict) {\n  const res = getIndicesOnly(input, value, comparer, strict);\n  return [input[res[0]], input[res[1]]];\n}\nvar css_248z$9 = \".column-header-row.svelte-vfarxf.svelte-vfarxf{position:relative;white-space:nowrap;height:32px}.column-header-cell.svelte-vfarxf.svelte-vfarxf{position:absolute;height:100%;box-sizing:border-box;text-overflow:clip;text-align:center;display:inline-flex;justify-content:center;align-items:center;font-size:1em;font-size:14px;font-weight:300;transition:background 0.2s;cursor:pointer;user-select:none;border-right:#efefef 1px solid;border-bottom:#efefef 1px solid}.column-header-cell.svelte-vfarxf.svelte-vfarxf:hover{background:#f9f9f9}.column-header-cell.sticky.svelte-vfarxf>.column-header-cell-label.svelte-vfarxf{position:sticky;left:1rem}\";\nstyleInject(css_248z$9);\n\n/* src\\column\\ColumnHeaderRow.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$6(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[13] = list[i];\n  return child_ctx;\n}\n\n// (40:4) {#each header.columns as _header}\nfunction create_each_block$6(ctx) {\n  let div1;\n  let div0;\n  let t0_value = ( /*_header*/ctx[13].label || 'N/A') + \"\";\n  let t0;\n  let t1;\n  let mounted;\n  let dispose;\n  function click_handler() {\n    return /*click_handler*/ctx[10]( /*_header*/ctx[13]);\n  }\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = text(t0_value);\n      t1 = space();\n      attr(div0, \"class\", \"column-header-cell-label svelte-vfarxf\");\n      attr(div1, \"class\", \"column-header-cell svelte-vfarxf\");\n      attr(div1, \"role\", \"button\");\n      attr(div1, \"tabindex\", \"0\");\n      set_style(div1, \"left\", /*_header*/ctx[13].left + \"px\");\n      set_style(div1, \"width\", /*_header*/ctx[13].width + \"px\");\n      toggle_class(div1, \"sticky\", /*header*/ctx[0].sticky);\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div0, t0);\n      append(div1, t1);\n      if (!mounted) {\n        dispose = listen(div1, \"click\", click_handler);\n        mounted = true;\n      }\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      if (dirty & /*header*/1 && t0_value !== (t0_value = ( /*_header*/ctx[13].label || 'N/A') + \"\")) set_data(t0, t0_value);\n      if (dirty & /*header*/1) {\n        set_style(div1, \"left\", /*_header*/ctx[13].left + \"px\");\n      }\n      if (dirty & /*header*/1) {\n        set_style(div1, \"width\", /*_header*/ctx[13].width + \"px\");\n      }\n      if (dirty & /*header*/1) {\n        toggle_class(div1, \"sticky\", /*header*/ctx[0].sticky);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction create_fragment$9(ctx) {\n  let div;\n  let each_value = ensure_array_like( /*header*/ctx[0].columns);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));\n  }\n  return {\n    c() {\n      div = element(\"div\");\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div, \"class\", \"column-header-row svelte-vfarxf\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div, null);\n        }\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*header, onHeaderClick*/17) {\n        each_value = ensure_array_like( /*header*/ctx[0].columns);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$6(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n          } else {\n            each_blocks[i] = create_each_block$6(child_ctx);\n            each_blocks[i].c();\n            each_blocks[i].m(div, null);\n          }\n        }\n        for (; i < each_blocks.length; i += 1) {\n          each_blocks[i].d(1);\n        }\n        each_blocks.length = each_value.length;\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      destroy_each(each_blocks, detaching);\n    }\n  };\n}\nfunction instance$9($$self, $$props, $$invalidate) {\n  let $width;\n  let $to;\n  let $from;\n  const dispatch = createEventDispatcher();\n  const {\n    from,\n    to,\n    width\n  } = getContext('dimensions');\n  component_subscribe($$self, from, value => $$invalidate(9, $from = value));\n  component_subscribe($$self, to, value => $$invalidate(8, $to = value));\n  component_subscribe($$self, width, value => $$invalidate(7, $width = value));\n  const {\n    dateAdapter\n  } = getContext('options');\n  let {\n    header\n  } = $$props;\n  let {\n    ganttBodyColumns\n  } = $$props;\n  let {\n    ganttBodyUnit\n  } = $$props;\n  function onHeaderClick(_header) {\n    dispatch('dateSelected', {\n      from: _header.from,\n      to: _header.to,\n      unit: header.unit\n    });\n  }\n  const click_handler = _header => onHeaderClick(_header);\n  $$self.$$set = $$props => {\n    if ('header' in $$props) $$invalidate(0, header = $$props.header);\n    if ('ganttBodyColumns' in $$props) $$invalidate(5, ganttBodyColumns = $$props.ganttBodyColumns);\n    if ('ganttBodyUnit' in $$props) $$invalidate(6, ganttBodyUnit = $$props.ganttBodyUnit);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*header, ganttBodyUnit, ganttBodyColumns, $from, $to, $width*/993) {\n      {\n        if (header.unit === ganttBodyUnit) {\n          $$invalidate(0, header.columns = ganttBodyColumns.map(column => ({\n            ...column,\n            label: dateAdapter.format(column.from, header.format)\n          })), header);\n        } else {\n          const periods = getAllPeriods($from.valueOf(), $to.valueOf(), header.unit);\n          let distance_point = 0;\n          let left = 0;\n          $$invalidate(0, header.columns = periods.map(period => {\n            left = distance_point;\n            distance_point = getPositionByDate(period.to, $from.valueOf(), $to.valueOf(), $width);\n            return {\n              width: Math.min(distance_point - left, $width),\n              label: dateAdapter.format(period.from, header.format),\n              from: period.from,\n              to: period.to,\n              left\n            };\n          }), header);\n        }\n      }\n    }\n  };\n  return [header, from, to, width, onHeaderClick, ganttBodyColumns, ganttBodyUnit, $width, $to, $from, click_handler];\n}\nclass ColumnHeaderRow extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$9, create_fragment$9, safe_not_equal, {\n      header: 0,\n      ganttBodyColumns: 5,\n      ganttBodyUnit: 6\n    });\n  }\n}\n\n/* src\\column\\ColumnHeader.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$5(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[4] = list[i];\n  return child_ctx;\n}\n\n// (10:0) {#each headers as header}\nfunction create_each_block$5(ctx) {\n  let columnheaderrow;\n  let current;\n  columnheaderrow = new ColumnHeaderRow({\n    props: {\n      header: /*header*/ctx[4],\n      ganttBodyColumns: /*ganttBodyColumns*/ctx[1],\n      ganttBodyUnit: /*ganttBodyUnit*/ctx[2]\n    }\n  });\n  columnheaderrow.$on(\"dateSelected\", /*dateSelected_handler*/ctx[3]);\n  return {\n    c() {\n      create_component(columnheaderrow.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(columnheaderrow, target, anchor);\n      current = true;\n    },\n    p(ctx, dirty) {\n      const columnheaderrow_changes = {};\n      if (dirty & /*headers*/1) columnheaderrow_changes.header = /*header*/ctx[4];\n      if (dirty & /*ganttBodyColumns*/2) columnheaderrow_changes.ganttBodyColumns = /*ganttBodyColumns*/ctx[1];\n      if (dirty & /*ganttBodyUnit*/4) columnheaderrow_changes.ganttBodyUnit = /*ganttBodyUnit*/ctx[2];\n      columnheaderrow.$set(columnheaderrow_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(columnheaderrow.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(columnheaderrow.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(columnheaderrow, detaching);\n    }\n  };\n}\nfunction create_fragment$8(ctx) {\n  let each_1_anchor;\n  let current;\n  let each_value = ensure_array_like( /*headers*/ctx[0]);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));\n  }\n  const out = i => transition_out(each_blocks[i], 1, 1, () => {\n    each_blocks[i] = null;\n  });\n  return {\n    c() {\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      each_1_anchor = empty();\n    },\n    m(target, anchor) {\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(target, anchor);\n        }\n      }\n      insert(target, each_1_anchor, anchor);\n      current = true;\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*headers, ganttBodyColumns, ganttBodyUnit*/7) {\n        each_value = ensure_array_like( /*headers*/ctx[0]);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$5(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n            transition_in(each_blocks[i], 1);\n          } else {\n            each_blocks[i] = create_each_block$5(child_ctx);\n            each_blocks[i].c();\n            transition_in(each_blocks[i], 1);\n            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n          }\n        }\n        group_outros();\n        for (i = each_value.length; i < each_blocks.length; i += 1) {\n          out(i);\n        }\n        check_outros();\n      }\n    },\n    i(local) {\n      if (current) return;\n      for (let i = 0; i < each_value.length; i += 1) {\n        transition_in(each_blocks[i]);\n      }\n      current = true;\n    },\n    o(local) {\n      each_blocks = each_blocks.filter(Boolean);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        transition_out(each_blocks[i]);\n      }\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(each_1_anchor);\n      }\n      destroy_each(each_blocks, detaching);\n    }\n  };\n}\nfunction instance$8($$self, $$props, $$invalidate) {\n  let {\n    headers\n  } = $$props;\n  let {\n    ganttBodyColumns\n  } = $$props;\n  let {\n    ganttBodyUnit\n  } = $$props;\n  function dateSelected_handler(event) {\n    bubble.call(this, $$self, event);\n  }\n  $$self.$$set = $$props => {\n    if ('headers' in $$props) $$invalidate(0, headers = $$props.headers);\n    if ('ganttBodyColumns' in $$props) $$invalidate(1, ganttBodyColumns = $$props.ganttBodyColumns);\n    if ('ganttBodyUnit' in $$props) $$invalidate(2, ganttBodyUnit = $$props.ganttBodyUnit);\n  };\n  return [headers, ganttBodyColumns, ganttBodyUnit, dateSelected_handler];\n}\nclass ColumnHeader extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$8, create_fragment$8, safe_not_equal, {\n      headers: 0,\n      ganttBodyColumns: 1,\n      ganttBodyUnit: 2\n    });\n  }\n}\nfunction createBackground(columns, opts) {\n  const canvas = document.createElement('canvas');\n  canvas.width = (columns.length - 1) * columns[0].width;\n  canvas.height = 20;\n  const ctx = canvas.getContext('2d');\n  ctx.shadowColor = 'rgba(128,128,128,0.5)';\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 0;\n  ctx.shadowBlur = 0.5;\n  ctx.lineWidth = opts.columnStrokeWidth;\n  ctx.lineCap = 'square';\n  ctx.strokeStyle = opts.columnStrokeColor;\n  ctx.translate(0.5, 0.5);\n  columns.forEach(column => {\n    lineAt(ctx, column.left);\n  });\n  const dataURL = canvas.toDataURL();\n  return `url(\"${dataURL}\")`;\n}\nfunction lineAt(ctx, x) {\n  ctx.beginPath();\n  ctx.moveTo(x, 0);\n  ctx.lineTo(x, 20);\n  ctx.stroke();\n}\nvar css_248z$8 = \".sg-columns.svelte-1uqfnup{position:absolute;height:100%;width:100%}.sg-columns--background.svelte-1uqfnup{overflow:hidden;background-repeat:repeat;background-position-x:-1px}.sg-column.svelte-1uqfnup{position:absolute;height:100%;width:100%;box-sizing:border-box}\";\nstyleInject(css_248z$8);\n\n/* src\\column\\Columns.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$4(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[6] = list[i];\n  return child_ctx;\n}\n\n// (24:0) {:else}\nfunction create_else_block$2(ctx) {\n  let div;\n  let each_value = ensure_array_like( /*columns*/ctx[0]);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));\n  }\n  return {\n    c() {\n      div = element(\"div\");\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div, \"class\", \"sg-columns svelte-1uqfnup\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div, null);\n        }\n      }\n    },\n    p(ctx, dirty) {\n      if (dirty & /*columns, columnStrokeWidth, columnStrokeColor, columnDefaultColor*/29) {\n        each_value = ensure_array_like( /*columns*/ctx[0]);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$4(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n          } else {\n            each_blocks[i] = create_each_block$4(child_ctx);\n            each_blocks[i].c();\n            each_blocks[i].m(div, null);\n          }\n        }\n        for (; i < each_blocks.length; i += 1) {\n          each_blocks[i].d(1);\n        }\n        each_blocks.length = each_value.length;\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      destroy_each(each_blocks, detaching);\n    }\n  };\n}\n\n// (22:0) {#if useCanvasColumns}\nfunction create_if_block$3(ctx) {\n  let div;\n  return {\n    c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"sg-columns sg-columns--background svelte-1uqfnup\");\n      set_style(div, \"background-image\", /*backgroundImage*/ctx[5]);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*backgroundImage*/32) {\n        set_style(div, \"background-image\", /*backgroundImage*/ctx[5]);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (26:8) {#each columns as column}\nfunction create_each_block$4(ctx) {\n  let div;\n  return {\n    c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"sg-column svelte-1uqfnup\");\n      set_style(div, \"border-right\", ( /*column*/ctx[6].bgHighlightColor ? 0 : /*columnStrokeWidth*/ctx[2]) + \"px solid \" + ( /*column*/ctx[6].bgHighlightColor || /*columnStrokeColor*/ctx[3]));\n      set_style(div, \"left\", /*column*/ctx[6].left + \"px\");\n      set_style(div, \"width\", /*column*/ctx[6].width + \"px\");\n      set_style(div, \"background-color\", /*column*/ctx[6].bgHighlightColor || /*columnDefaultColor*/ctx[4]);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*columns, columnStrokeWidth, columnStrokeColor*/13) {\n        set_style(div, \"border-right\", ( /*column*/ctx[6].bgHighlightColor ? 0 : /*columnStrokeWidth*/ctx[2]) + \"px solid \" + ( /*column*/ctx[6].bgHighlightColor || /*columnStrokeColor*/ctx[3]));\n      }\n      if (dirty & /*columns*/1) {\n        set_style(div, \"left\", /*column*/ctx[6].left + \"px\");\n      }\n      if (dirty & /*columns*/1) {\n        set_style(div, \"width\", /*column*/ctx[6].width + \"px\");\n      }\n      if (dirty & /*columns, columnDefaultColor*/17) {\n        set_style(div, \"background-color\", /*column*/ctx[6].bgHighlightColor || /*columnDefaultColor*/ctx[4]);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\nfunction create_fragment$7(ctx) {\n  let if_block_anchor;\n  function select_block_type(ctx, dirty) {\n    if ( /*useCanvasColumns*/ctx[1]) return create_if_block$3;\n    return create_else_block$2;\n  }\n  let current_block_type = select_block_type(ctx);\n  let if_block = current_block_type(ctx);\n  return {\n    c() {\n      if_block.c();\n      if_block_anchor = empty();\n    },\n    m(target, anchor) {\n      if_block.m(target, anchor);\n      insert(target, if_block_anchor, anchor);\n    },\n    p(ctx, [dirty]) {\n      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {\n        if_block.p(ctx, dirty);\n      } else {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n        if (if_block) {\n          if_block.c();\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(if_block_anchor);\n      }\n      if_block.d(detaching);\n    }\n  };\n}\nfunction instance$7($$self, $$props, $$invalidate) {\n  let {\n    columns\n  } = $$props;\n  let {\n    useCanvasColumns = true\n  } = $$props;\n  let {\n    columnStrokeWidth\n  } = $$props;\n  let {\n    columnStrokeColor\n  } = $$props;\n  let {\n    columnDefaultColor = '#ffffff'\n  } = $$props;\n  let backgroundImage;\n  $$self.$$set = $$props => {\n    if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);\n    if ('useCanvasColumns' in $$props) $$invalidate(1, useCanvasColumns = $$props.useCanvasColumns);\n    if ('columnStrokeWidth' in $$props) $$invalidate(2, columnStrokeWidth = $$props.columnStrokeWidth);\n    if ('columnStrokeColor' in $$props) $$invalidate(3, columnStrokeColor = $$props.columnStrokeColor);\n    if ('columnDefaultColor' in $$props) $$invalidate(4, columnDefaultColor = $$props.columnDefaultColor);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*columns, columnStrokeColor, columnStrokeWidth*/13) {\n      {\n        // TODO: background repeats and so do columns so passing every element is not needed, but line alignment issues occur on later rows\n        // TODO: I used to make column widths and positions whole numbers, now they contain decimals again, check if this is because of that\n        $$invalidate(5, backgroundImage = createBackground(columns, {\n          // columns.slice(0,5)\n          columnStrokeColor,\n          columnStrokeWidth\n        }));\n      }\n    }\n  };\n  return [columns, useCanvasColumns, columnStrokeWidth, columnStrokeColor, columnDefaultColor, backgroundImage];\n}\nclass Columns extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$7, create_fragment$7, safe_not_equal, {\n      columns: 0,\n      useCanvasColumns: 1,\n      columnStrokeWidth: 2,\n      columnStrokeColor: 3,\n      columnDefaultColor: 4\n    });\n  }\n}\nvar css_248z$7 = \".sg-context-menu.svelte-1a9x2in{position:absolute;background:white;border:1px solid #ccc;padding:0.25em 0;font-size:10px;transition:opacity 0.4s ease 0s;opacity:1;box-shadow:rgba(0, 0, 0, 0.32) 1px 1px 3px 0px}.context-option.svelte-1a9x2in:hover{background:#eee}.context-option.svelte-1a9x2in{cursor:default;padding:0.2em 1em}\";\nstyleInject(css_248z$7);\nvar css_248z$6 = \".sg-resize.svelte-1vzamdy{z-index:2;background:#e9eaeb;width:5px;cursor:col-resize;position:absolute;height:100%;transition:width 0.2s,\\r\\n            transform 0.2s}.sg-resize.svelte-1vzamdy:hover{transform:translateX(-2px);width:10px}\";\nstyleInject(css_248z$6);\n\n/* src\\ui\\Resizer.svelte generated by Svelte v4.2.1 */\n\nfunction create_fragment$6(ctx) {\n  let div;\n  let mounted;\n  let dispose;\n  return {\n    c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"sg-resize svelte-1vzamdy\");\n      set_style(div, \"left\", /*x*/ctx[0] + \"px\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (!mounted) {\n        dispose = action_destroyer( /*resizer*/ctx[1].call(null, div));\n        mounted = true;\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*x*/1) {\n        set_style(div, \"left\", /*x*/ctx[0] + \"px\");\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance$6($$self, $$props, $$invalidate) {\n  const dispatch = createEventDispatcher();\n  let {\n    x\n  } = $$props;\n  let {\n    container\n  } = $$props;\n  const dragOptions = {\n    onDrag: event => {\n      $$invalidate(0, x = event.x);\n      dispatch('resize', {\n        left: x\n      });\n      setCursor('col-resize');\n    },\n    onDrop: event => {\n      $$invalidate(0, x = event.x);\n      dispatch('resize', {\n        left: x\n      });\n      setCursor('default');\n    },\n    dragAllowed: true,\n    resizeAllowed: false,\n    container,\n    getX: () => x,\n    getY: () => 0,\n    getWidth: () => 0\n  };\n  function resizer(node) {\n    const draggable = new Draggable(node, dragOptions, 'resizer');\n    return {\n      destroy: () => draggable.destroy()\n    };\n  }\n  $$self.$$set = $$props => {\n    if ('x' in $$props) $$invalidate(0, x = $$props.x);\n    if ('container' in $$props) $$invalidate(2, container = $$props.container);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*container*/4) {\n      dragOptions.container = container;\n    }\n  };\n  return [x, resizer, container];\n}\nclass Resizer extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$6, create_fragment$6, safe_not_equal, {\n      x: 0,\n      container: 2\n    });\n  }\n}\nclass GanttApi {\n  listeners;\n  listenersMap;\n  tasks;\n  timeranges;\n  constructor() {\n    this.listeners = [];\n    this.listenersMap = {};\n  }\n  registerEvent(featureName, eventName) {\n    if (!this[featureName]) {\n      this[featureName] = {};\n    }\n    const feature = this[featureName];\n    if (!feature.on) {\n      feature.on = {};\n      feature.raise = {};\n    }\n    let eventId = 'on:' + featureName + ':' + eventName;\n    feature.raise[eventName] = (...params) => {\n      //todo add svelte? event listeners, looping isnt effective unless rarely used\n      this.listeners.forEach(listener => {\n        if (listener.eventId === eventId) {\n          listener.handler(params);\n        }\n      });\n    };\n    // Creating on event method featureName.oneventName\n    feature.on[eventName] = handler => {\n      // track our listener so we can turn off and on\n      let listener = {\n        handler: handler,\n        eventId: eventId\n      };\n      this.listenersMap[eventId] = listener;\n      this.listeners.push(listener);\n      const removeListener = () => {\n        const index = this.listeners.indexOf(listener);\n        this.listeners.splice(index, 1);\n      };\n      return removeListener;\n    };\n  }\n}\nclass RowFactory {\n  rowHeight;\n  constructor() {}\n  createRow(row, y) {\n    // defaults\n    // id of task, every task needs to have a unique one\n    //row.id = row.id || undefined;\n    // css classes\n    row.classes = row.classes || '';\n    // html content of row\n    row.contentHtml = row.contentHtml || undefined;\n    // enable dragging of tasks to and from this row\n    row.enableDragging = row.enableDragging === undefined ? true : row.enableDragging;\n    // height of row element\n    const height = row.height || this.rowHeight;\n    return {\n      model: row,\n      y,\n      height,\n      expanded: true\n    };\n  }\n  createRows(rows) {\n    const ctx = {\n      y: 0,\n      result: []\n    };\n    this.createChildRows(rows, ctx);\n    return ctx.result;\n  }\n  createChildRows(rowModels, ctx, parent = null, level = 0, parents = []) {\n    const rowsAtLevel = [];\n    const allRows = [];\n    if (parent) {\n      parents = [...parents, parent];\n    }\n    rowModels.forEach(rowModel => {\n      const row = this.createRow(rowModel, ctx.y);\n      ctx.result.push(row);\n      rowsAtLevel.push(row);\n      allRows.push(row);\n      row.childLevel = level;\n      row.parent = parent;\n      row.allParents = parents;\n      ctx.y += row.height;\n      if (rowModel.children) {\n        const nextLevel = this.createChildRows(rowModel.children, ctx, row, level + 1, parents);\n        row.children = nextLevel.rows;\n        row.allChildren = nextLevel.allRows;\n        allRows.push(...nextLevel.allRows);\n      }\n    });\n    return {\n      rows: rowsAtLevel,\n      allRows\n    };\n  }\n}\nclass TimeRangeFactory {\n  columnService;\n  constructor(columnService) {\n    this.columnService = columnService;\n  }\n  create(model) {\n    // enable dragging\n    model.enableResizing = model.enableResizing === undefined ? true : model.enableResizing;\n    const left = this.columnService.getPositionByDate(model.from);\n    const right = this.columnService.getPositionByDate(model.to);\n    return {\n      model,\n      left: left,\n      width: right - left,\n      resizing: false\n    };\n  }\n}\nclass SelectionManager {\n  taskStore;\n  // TODO:: figure out why these exist\n  oldReflections = [];\n  newTasksAndReflections = [];\n  taskSettings = new Map();\n  currentSelection = new Map();\n  selectedTasks = writable({});\n  constructor(taskStore) {\n    this.taskStore = taskStore;\n  }\n  selectSingle(taskId, node) {\n    if (!this.currentSelection.has(taskId)) {\n      this.unSelectTasks();\n      this.toggleSelection(taskId, node);\n    }\n    this.selectedTasks.set({\n      [taskId]: true\n    });\n  }\n  toggleSelection(taskId, node) {\n    this.currentSelection.set(taskId, {\n      HTMLElement: node,\n      offsetData: undefined,\n      draggable: undefined\n    });\n    this.selectedTasks.update(selections => ({\n      ...selections,\n      [taskId]: !selections[taskId]\n    }));\n  }\n  unSelectTasks() {\n    this.selectedTasks.set({});\n    this.currentSelection.clear();\n  }\n  dispatchSelectionEvent(taskId, event) {\n    const taskSetting = this.taskSettings.get(taskId);\n    const x = taskSetting.getX();\n    const y = taskSetting.getY();\n    const width = taskSetting.getWidth();\n    for (const [selId, selectedItem] of this.currentSelection.entries()) {\n      if (selId !== taskId) {\n        const selectedSetting = this.taskSettings.get(selId);\n        selectedItem.offsetData = {\n          offsetPos: {\n            x: selectedSetting.getX() - x,\n            y: selectedSetting.getY() - y\n          },\n          offsetWidth: selectedSetting.getWidth() - width\n        };\n      } else {\n        selectedItem.offsetData = {\n          offsetPos: {\n            x: null,\n            y: null\n          },\n          offsetWidth: null\n        };\n      }\n    }\n    this.dragOrResizeTriggered(event);\n  }\n  dragOrResizeTriggered = event => {\n    for (const [selId, selectedItem] of this.currentSelection.entries()) {\n      const draggable = new Draggable(selectedItem.HTMLElement, this.taskSettings.get(selId), selectedItem.offsetData);\n      draggable.onmousedown(event);\n      this.currentSelection.set(selId, {\n        ...selectedItem,\n        draggable: draggable\n      });\n    }\n    window.addEventListener('mousemove', this.selectionDragOrResizing, false);\n    addEventListenerOnce(window, 'mouseup', this.selectionDropped);\n  };\n  selectionDragOrResizing = event => {\n    for (const [, selectedItem] of this.currentSelection.entries()) {\n      const {\n        draggable\n      } = selectedItem;\n      draggable.onmousemove(event);\n    }\n  };\n  selectionDropped = event => {\n    window.removeEventListener('mousemove', this.selectionDragOrResizing, false);\n    for (const [, selectedItem] of this.currentSelection.entries()) {\n      const {\n        draggable\n      } = selectedItem;\n      draggable.onmouseup(event);\n    }\n    if (this.oldReflections.length) this.taskStore.deleteAll(this.oldReflections);\n    if (this.newTasksAndReflections.length) this.taskStore.upsertAll(this.newTasksAndReflections);\n    this.newTasksAndReflections.splice(0);\n    this.oldReflections.splice(0);\n  };\n}\n// export let draggableTasks: object = {};\n// export let currentSelection: Map<number,HTMLElement> = new Map();\n// export class SelectionManager {\n//     selectSingle(taskId, node) {\n//         if (!currentSelection.has(taskId)) {\n//             this.unSelectTasks()\n//             currentSelection.set(taskId, node);\n//         }\n//     }\n//     toggleSelection(taskId, node) {\n//         currentSelection.set(taskId, node);\n//     }\n//     unSelectTasks() {\n//         for (const [taskId, node] of currentSelection.entries()) {\n//             currentSelection.delete(taskId);\n//         }\n//     }\n//     dispatchTaskEvent(taskId, event) {\n//         const x = draggableTasks[taskId].settings.getX();\n//         const y = draggableTasks[taskId].settings.getY();\n//         const width = draggableTasks[taskId].settings.getWidth();\n//         draggableTasks[taskId].mouseStartPosX = getRelativePos(draggableTasks[taskId].settings.container, event).x - x;\n//         draggableTasks[taskId].mouseStartPosY = getRelativePos(draggableTasks[taskId].settings.container, event).y - y;\n//         if(draggableTasks[taskId].dragAllowed && draggableTasks[taskId].mouseStartPosX < draggableTasks[taskId].settings.resizeHandleWidth) {\n//             draggableTasks[taskId].direction = 'left';\n//             draggableTasks[taskId].resizing = true;\n//         }\n//         if(draggableTasks[taskId].dragAllowed && draggableTasks[taskId].mouseStartPosX > width - draggableTasks[taskId].settings.resizeHandleWidth) {\n//             draggableTasks[taskId].direction = 'right';\n//             draggableTasks[taskId].resizing = true;\n//         }\n//         draggableTasks[taskId].onmousedown(event);\n//         for (const [selId, node] of currentSelection.entries()) {\n//             if (selId !== taskId) {\n//                 draggableTasks[selId].direction = draggableTasks[taskId].direction;\n//                 draggableTasks[selId].resizing = draggableTasks[taskId].resizing; //prvent resizing and draggin at the same time\n//                 draggableTasks[selId].offsetPos.x = (draggableTasks[selId].settings.getX() - x);\n//                 draggableTasks[selId].offsetPos.y = (draggableTasks[selId].settings.getY() - y);\n//                 draggableTasks[selId].offsetWidth =  draggableTasks[selId].settings.getWidth() - width\n//                 const offsetMousePosition: offsetMousePostion = {\n//                 clientX: event.clientX + draggableTasks[selId].offsetPos.x,\n//                 clientY: event.clientY + draggableTasks[selId].offsetPos.y,\n//                 isOffsetMouseEvent: true //fake left click on all items in selection\n//                 }\n//                 draggableTasks[selId].onmousedown(offsetMousePosition);\n//             }\n//         }\n//     }\n// }\n\nfunction findByPosition(columns, x) {\n  const result = get(columns, x, c => c.left);\n  return result;\n}\nfunction findByDate(columns, x) {\n  const result = get(columns, x, c => c.from);\n  return result;\n}\nfunction createDelegatedEventDispatcher() {\n  const callbacks = {};\n  return {\n    onDelegatedEvent(type, attr, callback) {\n      if (!callbacks[type]) callbacks[type] = {};\n      callbacks[type][attr] = callback;\n    },\n    offDelegatedEvent(type, attr) {\n      delete callbacks[type][attr];\n    },\n    onEvent(e) {\n      const {\n        type,\n        target\n      } = e;\n      const cbs = callbacks[type];\n      if (!cbs) return;\n      let match;\n      let element = target;\n      while (element && element != e.currentTarget) {\n        if (match = matches(cbs, element)) {\n          break;\n        }\n        element = element.parentElement;\n      }\n      if (match && cbs[match.attr]) {\n        cbs[match.attr](e, match.data, element);\n      } else if (cbs['empty']) {\n        cbs['empty'](e, null, element);\n      }\n    }\n  };\n}\nfunction matches(cbs, element) {\n  let data;\n  for (const attr in cbs) {\n    if (data = element.getAttribute(attr)) {\n      return {\n        attr,\n        data\n      };\n    }\n  }\n}\nclass DefaultSvelteGanttDateAdapter {\n  format(date, format) {\n    const d = new Date(date);\n    switch (format) {\n      case 'H':\n        return d.getHours() + '';\n      case 'HH':\n        return pad(d.getHours());\n      case 'H:mm':\n        return `${d.getHours()}:${pad(d.getMinutes())}`;\n      case 'hh:mm':\n        return `${pad(d.getHours())}:${pad(d.getMinutes())}`;\n      case 'hh:mm:ss':\n        return `${d.getHours()}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n      case 'dd/MM/yyyy':\n        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()}`;\n      case 'dd/MM/yyyy hh:mm':\n        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()} ${d.getHours()}:${d.getMinutes()}`;\n      case 'dd/MM/yyyy hh:mm:ss':\n        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()} ${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}`;\n      // VPY More formats supported 10/12/2021\n      case 'YYYY':\n        return `${d.getFullYear()}`;\n      case 'Q':\n        return `${Math.floor(d.getMonth() / 3 + 1)}`;\n      case '[Q]Q':\n        return `Q${Math.floor(d.getMonth() / 3 + 1)}`;\n      case 'YYYY[Q]Q':\n        return `${d.getFullYear()}Q${Math.floor(d.getMonth() / 3 + 1)}`;\n      case 'MM':\n        {\n          // const month = d.toLocaleString('default', { month: 'long' });\n          let month = String(d.getMonth() + 1);\n          if (month.length == 1) month = `0${month}`;\n          return `${month}`;\n        }\n      case 'MMMM':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'long'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)}`;\n        }\n      case 'MMMM - YYYY':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'long'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)}-${d.getFullYear()}`;\n        }\n      case 'MMMM YYYY':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'long'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)} ${d.getFullYear()}`;\n        }\n      case 'MMM':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'short'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)}`;\n        }\n      case 'MMM - YYYY':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'short'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)} - ${d.getFullYear()}`;\n        }\n      case 'MMM YYYY':\n        {\n          const month = d.toLocaleString('default', {\n            month: 'short'\n          });\n          return `${month.charAt(0).toUpperCase()}${month.substring(1)} ${d.getFullYear()}`;\n        }\n      case 'W':\n        return `${getWeekNumber(d)}`;\n      case 'WW':\n        {\n          const weeknumber = getWeekNumber(d);\n          return `${weeknumber.toString().length == 1 ? '0' : ''}${weeknumber}`;\n        }\n      default:\n        console.warn(`Date Format '${format}' is not supported, use another date adapter.`);\n        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()}`;\n    }\n  }\n  /**\n   * Rounds the date down to the nearest unit\n   *\n   * Note: This does not consider the timezone, rounds only to the UTC time, which makes it incorrect to round to day start or half hour time zones\n   */\n  roundTo(date, unit, offset) {\n    const magnetDuration = getPeriodDuration(unit, offset);\n    const value = Math.round(date / magnetDuration) * magnetDuration; //\n    return value;\n  }\n}\nfunction pad(value) {\n  let result = value.toString();\n  for (let i = result.length; i < 2; i++) {\n    result = '0' + result;\n  }\n  return result;\n}\nfunction getWeekNumber(d) {\n  // Copy date so don't modify original\n  d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));\n  // Set to nearest Thursday: current date + 4 - current day number\n  // Make Sunday's day number 7\n  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n  // Get first day of year\n  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n  // Calculate full weeks to nearest Thursday\n  const weekNo = Math.ceil(((d.valueOf() - yearStart.valueOf()) / 86400000 + 1) / 7);\n  // Return array of year and week number\n  return weekNo;\n}\n/**\n * Return duration\n */\nfunction getPeriodDuration(unit, offset) {\n  switch (unit) {\n    case 'y':\n    case 'year':\n      // 2 cases 31622400000 (366) - 31536000000 (365)\n      return offset * 31536000000;\n    // Incorrect since there is years with 366 days\n    case 'month':\n      // 4 cases : 28 - 29 - 30 - 31\n      return offset * 30 * 24 * 60 * 60 * 1000;\n    // incorrect since months are of different durations\n    case 'week':\n      return offset * 7 * 24 * 60 * 60 * 1000;\n    case 'd':\n    case 'day':\n      return offset * 24 * 60 * 60 * 1000;\n    case 'h':\n    case 'hour':\n      return offset * 60 * 60 * 1000;\n    case 'm':\n    case 'minute':\n      return offset * 60 * 1000;\n    case 's':\n    case 'second':\n      return offset * 1000;\n    default:\n      throw new Error(`Unknown unit: ${unit}`);\n  }\n}\n\n/**\n * Layouts tasks in a 'pack' layout:\n *  - overlapping tasks display in the same row, but shrink to not overlap with eachother\n *\n * @param tasks\n * @param params\n *\n * TODO:: tests, optimization: update only rows that have changes, update only overlapping tasks\n */\nfunction layout(tasks, params) {\n  if (!tasks.length) {\n    return;\n  }\n  if (tasks.length === 1) {\n    const task = tasks[0];\n    task.yPos = 0;\n    task.intersectsWith = [];\n    task.height = params.rowContentHeight;\n    task.topDelta = task.yPos * task.height; // + rowPadding which is added by taskfactory;\n  }\n  tasks.sort(_byStartThenByLongestSortFn);\n  for (const left of tasks) {\n    left.yPos = 0; // reset y positions\n    left.intersectsWith = [];\n    for (const right of tasks) {\n      if (left !== right && _intersects(left, right)) {\n        left.intersectsWith.push(right);\n      }\n    }\n  }\n  for (const task of tasks) {\n    task.numYSlots = _getMaxIntersectsWithLength(task);\n    for (let i = 0; i < task.numYSlots; i++) {\n      if (!task.intersectsWith.some(intersect => intersect.yPos === i)) {\n        task.yPos = i;\n        task.height = params.rowContentHeight / task.numYSlots;\n        task.topDelta = task.yPos * task.height; // + rowPadding which is added by taskfactory;\n        break;\n      }\n    }\n  }\n}\n/** string intersection between tasks */\nfunction _intersects(left, right) {\n  return left.left + left.width > right.left && left.left < right.left + right.width;\n}\nfunction _byStartThenByLongestSortFn(a, b) {\n  return a.left - b.left || b.left + b.width - (a.left + a.width);\n}\n/**\n * The maximum number of tasks a task, and the tasks task is intersecting with, task is intersecting with.\n * eg. If intersecting with 3, and one of those 3 is intersecting with 4 more, the number returned is 4,\n * because for the layout to look good we need to squeeze the first task in slots of 4.\n * @param task\n * @param seen\n * @returns\n */\nfunction _getMaxIntersectsWithLength(task, seen = new Map()) {\n  seen.set(task, true);\n  // if (task.numYSlots != null) {\n  //     return task.numYSlots;\n  // }\n  let len = task.intersectsWith.length + 1;\n  for (const intersect of task.intersectsWith.filter(i => !seen.has(i))) {\n    const innerLen = _getMaxIntersectsWithLength(intersect, seen);\n    if (innerLen > len) {\n      len = innerLen;\n    }\n  }\n  return len;\n}\nvar css_248z$5 = \".sg-disable-transition.svelte-rujbxv .sg-task,.sg-disable-transition.svelte-rujbxv .sg-milestone{transition:transform 0s,\\r\\n            background-color 0.2s,\\r\\n            width 0s !important}.sg-view:not(:first-child){margin-left:5px}.right-scrollbar-visible{padding-right:17px}.sg-timeline.svelte-rujbxv{flex:1 1 0%;display:flex;flex-direction:column;overflow-x:auto}.sg-gantt.svelte-rujbxv{display:flex;width:100%;height:100%;position:relative}.sg-foreground.svelte-rujbxv{box-sizing:border-box;overflow:hidden;top:0;left:0;position:absolute;width:100%;height:100%;z-index:1;pointer-events:none}.sg-rows.svelte-rujbxv{width:100%;box-sizing:border-box;overflow:hidden}.sg-timeline-body.svelte-rujbxv{overflow:auto;flex:1 1 auto}.sg-header-scroller.svelte-rujbxv{border-right:1px solid #efefef;overflow:hidden;position:relative}.content.svelte-rujbxv{position:relative}*{box-sizing:border-box}\";\nstyleInject(css_248z$5);\n\n/* src\\Gantt.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$3(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[138] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_1$1(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[141] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_2(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[144] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_3(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[147] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_4(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[144] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_5(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[138] = list[i];\n  return child_ctx;\n}\n\n// (608:4) {#each ganttTableModules as module}\nfunction create_each_block_5(ctx) {\n  let switch_instance;\n  let t;\n  let resizer;\n  let current;\n  const switch_instance_spread_levels = [{\n    rowContainerHeight: /*rowContainerHeight*/ctx[9]\n  }, {\n    paddingTop: /*paddingTop*/ctx[21]\n  }, {\n    paddingBottom: /*paddingBottom*/ctx[22]\n  }, {\n    tableWidth: /*tableWidth*/ctx[2]\n  }, /*$$restProps*/ctx[52], {\n    visibleRows: /*visibleRows*/ctx[10]\n  }];\n  var switch_value = /*module*/ctx[138];\n  function switch_props(ctx, dirty) {\n    let switch_instance_props = {};\n    if (dirty !== undefined && dirty[0] & /*rowContainerHeight, paddingTop, paddingBottom, tableWidth, visibleRows*/6292996 | dirty[1] & /*$$restProps*/2097152) {\n      switch_instance_props = get_spread_update(switch_instance_spread_levels, [dirty[0] & /*rowContainerHeight*/512 && {\n        rowContainerHeight: /*rowContainerHeight*/ctx[9]\n      }, dirty[0] & /*paddingTop*/2097152 && {\n        paddingTop: /*paddingTop*/ctx[21]\n      }, dirty[0] & /*paddingBottom*/4194304 && {\n        paddingBottom: /*paddingBottom*/ctx[22]\n      }, dirty[0] & /*tableWidth*/4 && {\n        tableWidth: /*tableWidth*/ctx[2]\n      }, dirty[1] & /*$$restProps*/2097152 && get_spread_object( /*$$restProps*/ctx[52]), dirty[0] & /*visibleRows*/1024 && {\n        visibleRows: /*visibleRows*/ctx[10]\n      }]);\n    } else {\n      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {\n        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);\n      }\n    }\n    return {\n      props: switch_instance_props\n    };\n  }\n  if (switch_value) {\n    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));\n    switch_instance.$on(\"init\", onModuleInit);\n  }\n  resizer = new Resizer({\n    props: {\n      x: /*tableWidth*/ctx[2],\n      container: /*ganttElement*/ctx[13]\n    }\n  });\n  resizer.$on(\"resize\", /*onResize*/ctx[49]);\n  return {\n    c() {\n      if (switch_instance) create_component(switch_instance.$$.fragment);\n      t = space();\n      create_component(resizer.$$.fragment);\n    },\n    m(target, anchor) {\n      if (switch_instance) mount_component(switch_instance, target, anchor);\n      insert(target, t, anchor);\n      mount_component(resizer, target, anchor);\n      current = true;\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*ganttTableModules*/16 && switch_value !== (switch_value = /*module*/ctx[138])) {\n        if (switch_instance) {\n          group_outros();\n          const old_component = switch_instance;\n          transition_out(old_component.$$.fragment, 1, 0, () => {\n            destroy_component(old_component, 1);\n          });\n          check_outros();\n        }\n        if (switch_value) {\n          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));\n          switch_instance.$on(\"init\", onModuleInit);\n          create_component(switch_instance.$$.fragment);\n          transition_in(switch_instance.$$.fragment, 1);\n          mount_component(switch_instance, t.parentNode, t);\n        } else {\n          switch_instance = null;\n        }\n      } else if (switch_value) {\n        const switch_instance_changes = dirty[0] & /*rowContainerHeight, paddingTop, paddingBottom, tableWidth, visibleRows*/6292996 | dirty[1] & /*$$restProps*/2097152 ? get_spread_update(switch_instance_spread_levels, [dirty[0] & /*rowContainerHeight*/512 && {\n          rowContainerHeight: /*rowContainerHeight*/ctx[9]\n        }, dirty[0] & /*paddingTop*/2097152 && {\n          paddingTop: /*paddingTop*/ctx[21]\n        }, dirty[0] & /*paddingBottom*/4194304 && {\n          paddingBottom: /*paddingBottom*/ctx[22]\n        }, dirty[0] & /*tableWidth*/4 && {\n          tableWidth: /*tableWidth*/ctx[2]\n        }, dirty[1] & /*$$restProps*/2097152 && get_spread_object( /*$$restProps*/ctx[52]), dirty[0] & /*visibleRows*/1024 && {\n          visibleRows: /*visibleRows*/ctx[10]\n        }]) : {};\n        switch_instance.$set(switch_instance_changes);\n      }\n      const resizer_changes = {};\n      if (dirty[0] & /*tableWidth*/4) resizer_changes.x = /*tableWidth*/ctx[2];\n      if (dirty[0] & /*ganttElement*/8192) resizer_changes.container = /*ganttElement*/ctx[13];\n      resizer.$set(resizer_changes);\n    },\n    i(local) {\n      if (current) return;\n      if (switch_instance) transition_in(switch_instance.$$.fragment, local);\n      transition_in(resizer.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      if (switch_instance) transition_out(switch_instance.$$.fragment, local);\n      transition_out(resizer.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      if (switch_instance) destroy_component(switch_instance, detaching);\n      destroy_component(resizer, detaching);\n    }\n  };\n}\n\n// (633:20) {#each $allTimeRanges as timeRange (timeRange.model.id)}\nfunction create_each_block_4(key_1, ctx) {\n  let first;\n  let timerangeheader;\n  let current;\n  const timerangeheader_spread_levels = [/*timeRange*/ctx[144]];\n  let timerangeheader_props = {};\n  for (let i = 0; i < timerangeheader_spread_levels.length; i += 1) {\n    timerangeheader_props = assign(timerangeheader_props, timerangeheader_spread_levels[i]);\n  }\n  timerangeheader = new TimeRangeHeader({\n    props: timerangeheader_props\n  });\n  return {\n    key: key_1,\n    first: null,\n    c() {\n      first = empty();\n      create_component(timerangeheader.$$.fragment);\n      this.first = first;\n    },\n    m(target, anchor) {\n      insert(target, first, anchor);\n      mount_component(timerangeheader, target, anchor);\n      current = true;\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      const timerangeheader_changes = dirty[0] & /*$allTimeRanges*/33554432 ? get_spread_update(timerangeheader_spread_levels, [get_spread_object( /*timeRange*/ctx[144])]) : {};\n      timerangeheader.$set(timerangeheader_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(timerangeheader.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(timerangeheader.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(first);\n      }\n      destroy_component(timerangeheader, detaching);\n    }\n  };\n}\n\n// (658:24) {#each visibleRows as row (row.model.id)}\nfunction create_each_block_3(key_1, ctx) {\n  let first;\n  let row_1;\n  let current;\n  row_1 = new Row({\n    props: {\n      row: /*row*/ctx[147]\n    }\n  });\n  return {\n    key: key_1,\n    first: null,\n    c() {\n      first = empty();\n      create_component(row_1.$$.fragment);\n      this.first = first;\n    },\n    m(target, anchor) {\n      insert(target, first, anchor);\n      mount_component(row_1, target, anchor);\n      current = true;\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      const row_1_changes = {};\n      if (dirty[0] & /*visibleRows*/1024) row_1_changes.row = /*row*/ctx[147];\n      row_1.$set(row_1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(row_1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(row_1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(first);\n      }\n      destroy_component(row_1, detaching);\n    }\n  };\n}\n\n// (665:20) {#each $allTimeRanges as timeRange (timeRange.model.id)}\nfunction create_each_block_2(key_1, ctx) {\n  let first;\n  let timerange;\n  let current;\n  const timerange_spread_levels = [/*timeRange*/ctx[144]];\n  let timerange_props = {};\n  for (let i = 0; i < timerange_spread_levels.length; i += 1) {\n    timerange_props = assign(timerange_props, timerange_spread_levels[i]);\n  }\n  timerange = new TimeRange({\n    props: timerange_props\n  });\n  return {\n    key: key_1,\n    first: null,\n    c() {\n      first = empty();\n      create_component(timerange.$$.fragment);\n      this.first = first;\n    },\n    m(target, anchor) {\n      insert(target, first, anchor);\n      mount_component(timerange, target, anchor);\n      current = true;\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      const timerange_changes = dirty[0] & /*$allTimeRanges*/33554432 ? get_spread_update(timerange_spread_levels, [get_spread_object( /*timeRange*/ctx[144])]) : {};\n      timerange.$set(timerange_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(timerange.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(timerange.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(first);\n      }\n      destroy_component(timerange, detaching);\n    }\n  };\n}\n\n// (669:20) {#each visibleTasks as task (task.model.id)}\nfunction create_each_block_1$1(key_1, ctx) {\n  let first;\n  let task_1;\n  let current;\n  const task_1_spread_levels = [{\n    model: /*task*/ctx[141].model\n  }, {\n    left: /*task*/ctx[141].left\n  }, {\n    width: /*task*/ctx[141].width\n  }, {\n    height: /*task*/ctx[141].height\n  }, {\n    top: /*task*/ctx[141].top\n  }, /*task*/ctx[141]];\n  let task_1_props = {};\n  for (let i = 0; i < task_1_spread_levels.length; i += 1) {\n    task_1_props = assign(task_1_props, task_1_spread_levels[i]);\n  }\n  task_1 = new Task({\n    props: task_1_props\n  });\n  return {\n    key: key_1,\n    first: null,\n    c() {\n      first = empty();\n      create_component(task_1.$$.fragment);\n      this.first = first;\n    },\n    m(target, anchor) {\n      insert(target, first, anchor);\n      mount_component(task_1, target, anchor);\n      current = true;\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      const task_1_changes = dirty[0] & /*visibleTasks*/8388608 ? get_spread_update(task_1_spread_levels, [{\n        model: /*task*/ctx[141].model\n      }, {\n        left: /*task*/ctx[141].left\n      }, {\n        width: /*task*/ctx[141].width\n      }, {\n        height: /*task*/ctx[141].height\n      }, {\n        top: /*task*/ctx[141].top\n      }, get_spread_object( /*task*/ctx[141])]) : {};\n      task_1.$set(task_1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(task_1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(task_1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(first);\n      }\n      destroy_component(task_1, detaching);\n    }\n  };\n}\n\n// (680:16) {#each ganttBodyModules as module}\nfunction create_each_block$3(ctx) {\n  let switch_instance;\n  let switch_instance_anchor;\n  let current;\n  const switch_instance_spread_levels = [{\n    paddingTop: /*paddingTop*/ctx[21]\n  }, {\n    paddingBottom: /*paddingBottom*/ctx[22]\n  }, {\n    visibleRows: /*visibleRows*/ctx[10]\n  }, /*$$restProps*/ctx[52]];\n  var switch_value = /*module*/ctx[138];\n  function switch_props(ctx, dirty) {\n    let switch_instance_props = {};\n    if (dirty !== undefined && dirty[0] & /*paddingTop, paddingBottom, visibleRows*/6292480 | dirty[1] & /*$$restProps*/2097152) {\n      switch_instance_props = get_spread_update(switch_instance_spread_levels, [dirty[0] & /*paddingTop*/2097152 && {\n        paddingTop: /*paddingTop*/ctx[21]\n      }, dirty[0] & /*paddingBottom*/4194304 && {\n        paddingBottom: /*paddingBottom*/ctx[22]\n      }, dirty[0] & /*visibleRows*/1024 && {\n        visibleRows: /*visibleRows*/ctx[10]\n      }, dirty[1] & /*$$restProps*/2097152 && get_spread_object( /*$$restProps*/ctx[52])]);\n    } else {\n      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {\n        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);\n      }\n    }\n    return {\n      props: switch_instance_props\n    };\n  }\n  if (switch_value) {\n    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));\n    switch_instance.$on(\"init\", onModuleInit);\n  }\n  return {\n    c() {\n      if (switch_instance) create_component(switch_instance.$$.fragment);\n      switch_instance_anchor = empty();\n    },\n    m(target, anchor) {\n      if (switch_instance) mount_component(switch_instance, target, anchor);\n      insert(target, switch_instance_anchor, anchor);\n      current = true;\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*ganttBodyModules*/32 && switch_value !== (switch_value = /*module*/ctx[138])) {\n        if (switch_instance) {\n          group_outros();\n          const old_component = switch_instance;\n          transition_out(old_component.$$.fragment, 1, 0, () => {\n            destroy_component(old_component, 1);\n          });\n          check_outros();\n        }\n        if (switch_value) {\n          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));\n          switch_instance.$on(\"init\", onModuleInit);\n          create_component(switch_instance.$$.fragment);\n          transition_in(switch_instance.$$.fragment, 1);\n          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);\n        } else {\n          switch_instance = null;\n        }\n      } else if (switch_value) {\n        const switch_instance_changes = dirty[0] & /*paddingTop, paddingBottom, visibleRows*/6292480 | dirty[1] & /*$$restProps*/2097152 ? get_spread_update(switch_instance_spread_levels, [dirty[0] & /*paddingTop*/2097152 && {\n          paddingTop: /*paddingTop*/ctx[21]\n        }, dirty[0] & /*paddingBottom*/4194304 && {\n          paddingBottom: /*paddingBottom*/ctx[22]\n        }, dirty[0] & /*visibleRows*/1024 && {\n          visibleRows: /*visibleRows*/ctx[10]\n        }, dirty[1] & /*$$restProps*/2097152 && get_spread_object( /*$$restProps*/ctx[52])]) : {};\n        switch_instance.$set(switch_instance_changes);\n      }\n    },\n    i(local) {\n      if (current) return;\n      if (switch_instance) transition_in(switch_instance.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      if (switch_instance) transition_out(switch_instance.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(switch_instance_anchor);\n      }\n      if (switch_instance) destroy_component(switch_instance, detaching);\n    }\n  };\n}\nfunction create_fragment$5(ctx) {\n  let div9;\n  let t0;\n  let div8;\n  let div2;\n  let div1;\n  let div0;\n  let columnheader;\n  let t1;\n  let each_blocks_4 = [];\n  let each1_lookup = new Map();\n  let div2_resize_listener;\n  let t2;\n  let div7;\n  let div6;\n  let columns_1;\n  let t3;\n  let div4;\n  let div3;\n  let each_blocks_3 = [];\n  let each2_lookup = new Map();\n  let t4;\n  let div5;\n  let each_blocks_2 = [];\n  let each3_lookup = new Map();\n  let t5;\n  let each_blocks_1 = [];\n  let each4_lookup = new Map();\n  let t6;\n  let div7_resize_listener;\n  let div9_class_value;\n  let current;\n  let mounted;\n  let dispose;\n  let each_value_5 = ensure_array_like( /*ganttTableModules*/ctx[4]);\n  let each_blocks_5 = [];\n  for (let i = 0; i < each_value_5.length; i += 1) {\n    each_blocks_5[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));\n  }\n  const out = i => transition_out(each_blocks_5[i], 1, 1, () => {\n    each_blocks_5[i] = null;\n  });\n  columnheader = new ColumnHeader({\n    props: {\n      headers: /*headers*/ctx[1],\n      ganttBodyColumns: /*columns*/ctx[18],\n      ganttBodyUnit: /*columnUnit*/ctx[0]\n    }\n  });\n  columnheader.$on(\"dateSelected\", /*onDateSelected*/ctx[51]);\n  let each_value_4 = ensure_array_like( /*$allTimeRanges*/ctx[25]);\n  const get_key = ctx => /*timeRange*/ctx[144].model.id;\n  for (let i = 0; i < each_value_4.length; i += 1) {\n    let child_ctx = get_each_context_4(ctx, each_value_4, i);\n    let key = get_key(child_ctx);\n    each1_lookup.set(key, each_blocks_4[i] = create_each_block_4(key, child_ctx));\n  }\n  columns_1 = new Columns({\n    props: {\n      columns: /*columns*/ctx[18],\n      columnStrokeColor: /*columnStrokeColor*/ctx[7],\n      columnStrokeWidth: /*columnStrokeWidth*/ctx[8],\n      useCanvasColumns: /*useCanvasColumns*/ctx[6]\n    }\n  });\n  let each_value_3 = ensure_array_like( /*visibleRows*/ctx[10]);\n  const get_key_1 = ctx => /*row*/ctx[147].model.id;\n  for (let i = 0; i < each_value_3.length; i += 1) {\n    let child_ctx = get_each_context_3(ctx, each_value_3, i);\n    let key = get_key_1(child_ctx);\n    each2_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));\n  }\n  let each_value_2 = ensure_array_like( /*$allTimeRanges*/ctx[25]);\n  const get_key_2 = ctx => /*timeRange*/ctx[144].model.id;\n  for (let i = 0; i < each_value_2.length; i += 1) {\n    let child_ctx = get_each_context_2(ctx, each_value_2, i);\n    let key = get_key_2(child_ctx);\n    each3_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));\n  }\n  let each_value_1 = ensure_array_like( /*visibleTasks*/ctx[23]);\n  const get_key_3 = ctx => /*task*/ctx[141].model.id;\n  for (let i = 0; i < each_value_1.length; i += 1) {\n    let child_ctx = get_each_context_1$1(ctx, each_value_1, i);\n    let key = get_key_3(child_ctx);\n    each4_lookup.set(key, each_blocks_1[i] = create_each_block_1$1(key, child_ctx));\n  }\n  let each_value = ensure_array_like( /*ganttBodyModules*/ctx[5]);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));\n  }\n  const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {\n    each_blocks[i] = null;\n  });\n  return {\n    c() {\n      div9 = element(\"div\");\n      for (let i = 0; i < each_blocks_5.length; i += 1) {\n        each_blocks_5[i].c();\n      }\n      t0 = space();\n      div8 = element(\"div\");\n      div2 = element(\"div\");\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      create_component(columnheader.$$.fragment);\n      t1 = space();\n      for (let i = 0; i < each_blocks_4.length; i += 1) {\n        each_blocks_4[i].c();\n      }\n      t2 = space();\n      div7 = element(\"div\");\n      div6 = element(\"div\");\n      create_component(columns_1.$$.fragment);\n      t3 = space();\n      div4 = element(\"div\");\n      div3 = element(\"div\");\n      for (let i = 0; i < each_blocks_3.length; i += 1) {\n        each_blocks_3[i].c();\n      }\n      t4 = space();\n      div5 = element(\"div\");\n      for (let i = 0; i < each_blocks_2.length; i += 1) {\n        each_blocks_2[i].c();\n      }\n      t5 = space();\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        each_blocks_1[i].c();\n      }\n      t6 = space();\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div0, \"class\", \"header-container\");\n      set_style(div0, \"width\", /*$_width*/ctx[12] + \"px\");\n      attr(div1, \"class\", \"sg-header-scroller svelte-rujbxv\");\n      attr(div2, \"class\", \"sg-header\");\n      add_render_callback(() => /*div2_elementresize_handler*/ctx[112].call(div2));\n      toggle_class(div2, \"right-scrollbar-visible\", /*rightScrollbarVisible*/ctx[20]);\n      set_style(div3, \"transform\", \"translateY(\" + /*paddingTop*/ctx[21] + \"px)\");\n      attr(div4, \"class\", \"sg-rows svelte-rujbxv\");\n      set_style(div4, \"height\", /*rowContainerHeight*/ctx[9] + \"px\");\n      attr(div5, \"class\", \"sg-foreground svelte-rujbxv\");\n      attr(div6, \"class\", \"content svelte-rujbxv\");\n      set_style(div6, \"width\", /*$_width*/ctx[12] + \"px\");\n      attr(div7, \"class\", \"sg-timeline-body svelte-rujbxv\");\n      add_render_callback(() => /*div7_elementresize_handler*/ctx[115].call(div7));\n      toggle_class(div7, \"zooming\", /*zooming*/ctx[19]);\n      attr(div8, \"class\", \"sg-timeline sg-view svelte-rujbxv\");\n      attr(div9, \"class\", div9_class_value = \"sg-gantt \" + /*classes*/ctx[3] + \" svelte-rujbxv\");\n      toggle_class(div9, \"sg-disable-transition\", /*disableTransition*/ctx[17]);\n    },\n    m(target, anchor) {\n      insert(target, div9, anchor);\n      for (let i = 0; i < each_blocks_5.length; i += 1) {\n        if (each_blocks_5[i]) {\n          each_blocks_5[i].m(div9, null);\n        }\n      }\n      append(div9, t0);\n      append(div9, div8);\n      append(div8, div2);\n      append(div2, div1);\n      append(div1, div0);\n      mount_component(columnheader, div0, null);\n      append(div0, t1);\n      for (let i = 0; i < each_blocks_4.length; i += 1) {\n        if (each_blocks_4[i]) {\n          each_blocks_4[i].m(div0, null);\n        }\n      }\n\n      /*div2_binding*/\n      ctx[111](div2);\n      div2_resize_listener = add_iframe_resize_listener(div2, /*div2_elementresize_handler*/ctx[112].bind(div2));\n      append(div8, t2);\n      append(div8, div7);\n      append(div7, div6);\n      mount_component(columns_1, div6, null);\n      append(div6, t3);\n      append(div6, div4);\n      append(div4, div3);\n      for (let i = 0; i < each_blocks_3.length; i += 1) {\n        if (each_blocks_3[i]) {\n          each_blocks_3[i].m(div3, null);\n        }\n      }\n\n      /*div4_binding*/\n      ctx[113](div4);\n      append(div6, t4);\n      append(div6, div5);\n      for (let i = 0; i < each_blocks_2.length; i += 1) {\n        if (each_blocks_2[i]) {\n          each_blocks_2[i].m(div5, null);\n        }\n      }\n      append(div5, t5);\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        if (each_blocks_1[i]) {\n          each_blocks_1[i].m(div5, null);\n        }\n      }\n      append(div6, t6);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div6, null);\n        }\n      }\n\n      /*div7_binding*/\n      ctx[114](div7);\n      div7_resize_listener = add_iframe_resize_listener(div7, /*div7_elementresize_handler*/ctx[115].bind(div7));\n      /*div9_binding*/\n      ctx[116](div9);\n      current = true;\n      if (!mounted) {\n        dispose = [action_destroyer( /*horizontalScrollListener*/ctx[48].call(null, div1)), action_destroyer( /*scrollable*/ctx[47].call(null, div7)), listen(div7, \"wheel\", /*onwheel*/ctx[50]), listen(div9, \"mousedown\", stop_propagation( /*onEvent*/ctx[46])), listen(div9, \"click\", stop_propagation( /*onEvent*/ctx[46])), listen(div9, \"dblclick\", /*onEvent*/ctx[46]), listen(div9, \"mouseover\", /*onEvent*/ctx[46]), listen(div9, \"mouseleave\", /*onEvent*/ctx[46])];\n        mounted = true;\n      }\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*tableWidth, ganttElement, ganttTableModules, rowContainerHeight, paddingTop, paddingBottom, visibleRows*/6301204 | dirty[1] & /*onResize, $$restProps*/2359296) {\n        each_value_5 = ensure_array_like( /*ganttTableModules*/ctx[4]);\n        let i;\n        for (i = 0; i < each_value_5.length; i += 1) {\n          const child_ctx = get_each_context_5(ctx, each_value_5, i);\n          if (each_blocks_5[i]) {\n            each_blocks_5[i].p(child_ctx, dirty);\n            transition_in(each_blocks_5[i], 1);\n          } else {\n            each_blocks_5[i] = create_each_block_5(child_ctx);\n            each_blocks_5[i].c();\n            transition_in(each_blocks_5[i], 1);\n            each_blocks_5[i].m(div9, t0);\n          }\n        }\n        group_outros();\n        for (i = each_value_5.length; i < each_blocks_5.length; i += 1) {\n          out(i);\n        }\n        check_outros();\n      }\n      const columnheader_changes = {};\n      if (dirty[0] & /*headers*/2) columnheader_changes.headers = /*headers*/ctx[1];\n      if (dirty[0] & /*columns*/262144) columnheader_changes.ganttBodyColumns = /*columns*/ctx[18];\n      if (dirty[0] & /*columnUnit*/1) columnheader_changes.ganttBodyUnit = /*columnUnit*/ctx[0];\n      columnheader.$set(columnheader_changes);\n      if (dirty[0] & /*$allTimeRanges*/33554432) {\n        each_value_4 = ensure_array_like( /*$allTimeRanges*/ctx[25]);\n        group_outros();\n        each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key, 1, ctx, each_value_4, each1_lookup, div0, outro_and_destroy_block, create_each_block_4, null, get_each_context_4);\n        check_outros();\n      }\n      if (!current || dirty[0] & /*$_width*/4096) {\n        set_style(div0, \"width\", /*$_width*/ctx[12] + \"px\");\n      }\n      if (!current || dirty[0] & /*rightScrollbarVisible*/1048576) {\n        toggle_class(div2, \"right-scrollbar-visible\", /*rightScrollbarVisible*/ctx[20]);\n      }\n      const columns_1_changes = {};\n      if (dirty[0] & /*columns*/262144) columns_1_changes.columns = /*columns*/ctx[18];\n      if (dirty[0] & /*columnStrokeColor*/128) columns_1_changes.columnStrokeColor = /*columnStrokeColor*/ctx[7];\n      if (dirty[0] & /*columnStrokeWidth*/256) columns_1_changes.columnStrokeWidth = /*columnStrokeWidth*/ctx[8];\n      if (dirty[0] & /*useCanvasColumns*/64) columns_1_changes.useCanvasColumns = /*useCanvasColumns*/ctx[6];\n      columns_1.$set(columns_1_changes);\n      if (dirty[0] & /*visibleRows*/1024) {\n        each_value_3 = ensure_array_like( /*visibleRows*/ctx[10]);\n        group_outros();\n        each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_1, 1, ctx, each_value_3, each2_lookup, div3, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);\n        check_outros();\n      }\n      if (!current || dirty[0] & /*paddingTop*/2097152) {\n        set_style(div3, \"transform\", \"translateY(\" + /*paddingTop*/ctx[21] + \"px)\");\n      }\n      if (!current || dirty[0] & /*rowContainerHeight*/512) {\n        set_style(div4, \"height\", /*rowContainerHeight*/ctx[9] + \"px\");\n      }\n      if (dirty[0] & /*$allTimeRanges*/33554432) {\n        each_value_2 = ensure_array_like( /*$allTimeRanges*/ctx[25]);\n        group_outros();\n        each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_2, 1, ctx, each_value_2, each3_lookup, div5, outro_and_destroy_block, create_each_block_2, t5, get_each_context_2);\n        check_outros();\n      }\n      if (dirty[0] & /*visibleTasks*/8388608) {\n        each_value_1 = ensure_array_like( /*visibleTasks*/ctx[23]);\n        group_outros();\n        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_3, 1, ctx, each_value_1, each4_lookup, div5, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);\n        check_outros();\n      }\n      if (dirty[0] & /*ganttBodyModules, paddingTop, paddingBottom, visibleRows*/6292512 | dirty[1] & /*$$restProps*/2097152) {\n        each_value = ensure_array_like( /*ganttBodyModules*/ctx[5]);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$3(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n            transition_in(each_blocks[i], 1);\n          } else {\n            each_blocks[i] = create_each_block$3(child_ctx);\n            each_blocks[i].c();\n            transition_in(each_blocks[i], 1);\n            each_blocks[i].m(div6, null);\n          }\n        }\n        group_outros();\n        for (i = each_value.length; i < each_blocks.length; i += 1) {\n          out_1(i);\n        }\n        check_outros();\n      }\n      if (!current || dirty[0] & /*$_width*/4096) {\n        set_style(div6, \"width\", /*$_width*/ctx[12] + \"px\");\n      }\n      if (!current || dirty[0] & /*zooming*/524288) {\n        toggle_class(div7, \"zooming\", /*zooming*/ctx[19]);\n      }\n      if (!current || dirty[0] & /*classes*/8 && div9_class_value !== (div9_class_value = \"sg-gantt \" + /*classes*/ctx[3] + \" svelte-rujbxv\")) {\n        attr(div9, \"class\", div9_class_value);\n      }\n      if (!current || dirty[0] & /*classes, disableTransition*/131080) {\n        toggle_class(div9, \"sg-disable-transition\", /*disableTransition*/ctx[17]);\n      }\n    },\n    i(local) {\n      if (current) return;\n      for (let i = 0; i < each_value_5.length; i += 1) {\n        transition_in(each_blocks_5[i]);\n      }\n      transition_in(columnheader.$$.fragment, local);\n      for (let i = 0; i < each_value_4.length; i += 1) {\n        transition_in(each_blocks_4[i]);\n      }\n      transition_in(columns_1.$$.fragment, local);\n      for (let i = 0; i < each_value_3.length; i += 1) {\n        transition_in(each_blocks_3[i]);\n      }\n      for (let i = 0; i < each_value_2.length; i += 1) {\n        transition_in(each_blocks_2[i]);\n      }\n      for (let i = 0; i < each_value_1.length; i += 1) {\n        transition_in(each_blocks_1[i]);\n      }\n      for (let i = 0; i < each_value.length; i += 1) {\n        transition_in(each_blocks[i]);\n      }\n      current = true;\n    },\n    o(local) {\n      each_blocks_5 = each_blocks_5.filter(Boolean);\n      for (let i = 0; i < each_blocks_5.length; i += 1) {\n        transition_out(each_blocks_5[i]);\n      }\n      transition_out(columnheader.$$.fragment, local);\n      for (let i = 0; i < each_blocks_4.length; i += 1) {\n        transition_out(each_blocks_4[i]);\n      }\n      transition_out(columns_1.$$.fragment, local);\n      for (let i = 0; i < each_blocks_3.length; i += 1) {\n        transition_out(each_blocks_3[i]);\n      }\n      for (let i = 0; i < each_blocks_2.length; i += 1) {\n        transition_out(each_blocks_2[i]);\n      }\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        transition_out(each_blocks_1[i]);\n      }\n      each_blocks = each_blocks.filter(Boolean);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        transition_out(each_blocks[i]);\n      }\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div9);\n      }\n      destroy_each(each_blocks_5, detaching);\n      destroy_component(columnheader);\n      for (let i = 0; i < each_blocks_4.length; i += 1) {\n        each_blocks_4[i].d();\n      }\n\n      /*div2_binding*/\n      ctx[111](null);\n      div2_resize_listener();\n      destroy_component(columns_1);\n      for (let i = 0; i < each_blocks_3.length; i += 1) {\n        each_blocks_3[i].d();\n      }\n\n      /*div4_binding*/\n      ctx[113](null);\n      for (let i = 0; i < each_blocks_2.length; i += 1) {\n        each_blocks_2[i].d();\n      }\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        each_blocks_1[i].d();\n      }\n      destroy_each(each_blocks, detaching);\n      /*div7_binding*/\n      ctx[114](null);\n      div7_resize_listener();\n      /*div9_binding*/\n      ctx[116](null);\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\nfunction assertSet(values) {\n  for (const name in values) {\n    if (values[name] == null) {\n      throw new Error(`\"${name}\" is not set`);\n    }\n  }\n}\nfunction toDateNum(date) {\n  return date instanceof Date ? date.valueOf() : date;\n}\nfunction onModuleInit(module) {}\nfunction instance$5($$self, $$props, $$invalidate) {\n  const omit_props_names = [\"rows\", \"tasks\", \"timeRanges\", \"rowPadding\", \"rowHeight\", \"from\", \"to\", \"minWidth\", \"fitWidth\", \"classes\", \"headers\", \"zoomLevels\", \"taskContent\", \"tableWidth\", \"resizeHandleWidth\", \"onTaskButtonClick\", \"dateAdapter\", \"magnetUnit\", \"magnetOffset\", \"columnUnit\", \"columnOffset\", \"ganttTableModules\", \"ganttBodyModules\", \"reflectOnParentRows\", \"reflectOnChildRows\", \"useCanvasColumns\", \"columnStrokeColor\", \"columnStrokeWidth\", \"highlightedDurations\", \"highlightColor\", \"taskElementHook\", \"layout\", \"columnService\", \"api\", \"taskFactory\", \"rowFactory\", \"dndManager\", \"timeRangeFactory\", \"utils\", \"refreshTimeRanges\", \"refreshTasks\", \"getRowContainer\", \"selectTask\", \"unselectTasks\", \"scrollToRow\", \"scrollToTask\", \"updateTask\", \"updateTasks\", \"updateRow\", \"updateRows\", \"getRow\", \"getTask\", \"getTasks\"];\n  let $$restProps = compute_rest_props($$props, omit_props_names);\n  let $taskStore;\n  let $rowTaskCache;\n  let $rowStore;\n  let $draggingTaskCache;\n  let $visibleHeight;\n  let $allRows;\n  let $allTasks;\n  let $_width;\n  let $_to;\n  let $_from;\n  let $_rowPadding;\n  let $_fitWidth;\n  let $_minWidth;\n  let $hoveredRow;\n  let $selectedRow;\n  let $_rowHeight;\n  let $headerHeight;\n  let $allTimeRanges;\n  let $visibleWidth;\n  let ganttElement;\n  let mainHeaderContainer;\n  let mainContainer;\n  let rowContainer;\n  let scrollables = [];\n  let mounted = false;\n  let {\n    rows\n  } = $$props;\n  let {\n    tasks = []\n  } = $$props;\n  let {\n    timeRanges = []\n  } = $$props;\n  assertSet({\n    rows\n  });\n  let {\n    rowPadding = 6\n  } = $$props;\n  let {\n    rowHeight = 52\n  } = $$props;\n  const _rowHeight = writable(rowHeight);\n  component_subscribe($$self, _rowHeight, value => $$invalidate(124, $_rowHeight = value));\n  const _rowPadding = writable(rowPadding);\n  component_subscribe($$self, _rowPadding, value => $$invalidate(110, $_rowPadding = value));\n  let {\n    from\n  } = $$props;\n  let {\n    to\n  } = $$props;\n  assertSet({\n    from,\n    to\n  });\n  const _from = writable(toDateNum(from));\n  component_subscribe($$self, _from, value => $$invalidate(109, $_from = value));\n  const _to = writable(toDateNum(to));\n  component_subscribe($$self, _to, value => $$invalidate(108, $_to = value));\n  let {\n    minWidth = 800\n  } = $$props;\n  let {\n    fitWidth = false\n  } = $$props;\n  const _minWidth = writable(minWidth);\n  component_subscribe($$self, _minWidth, value => $$invalidate(121, $_minWidth = value));\n  const _fitWidth = writable(fitWidth);\n  component_subscribe($$self, _fitWidth, value => $$invalidate(120, $_fitWidth = value));\n  let {\n    classes = []\n  } = $$props;\n  let {\n    headers = [{\n      unit: 'day',\n      format: 'MMMM Do'\n    }, {\n      unit: 'hour',\n      format: 'H:mm'\n    }]\n  } = $$props;\n  let {\n    zoomLevels = [{\n      headers: [{\n        unit: 'day',\n        format: 'DD.MM.YYYY'\n      }, {\n        unit: 'hour',\n        format: 'HH'\n      }],\n      minWidth: 800,\n      fitWidth: true\n    }, {\n      headers: [{\n        unit: 'hour',\n        format: 'ddd D/M, H A'\n      }, {\n        unit: 'minute',\n        format: 'mm',\n        offset: 15\n      }],\n      minWidth: 5000,\n      fitWidth: false\n    }]\n  } = $$props;\n  let {\n    taskContent = null\n  } = $$props;\n  let {\n    tableWidth = 240\n  } = $$props;\n  let {\n    resizeHandleWidth = 10\n  } = $$props;\n  let {\n    onTaskButtonClick = null\n  } = $$props;\n  let {\n    dateAdapter = new DefaultSvelteGanttDateAdapter()\n  } = $$props;\n  let {\n    magnetUnit = 'minute'\n  } = $$props;\n  let {\n    magnetOffset = 15\n  } = $$props;\n  let magnetDuration;\n  setMagnetDuration(magnetUnit, magnetOffset);\n  function setMagnetDuration(unit, offset) {\n    if (unit && offset) {\n      $$invalidate(98, magnetDuration = getDuration(unit, offset));\n    }\n  }\n  let {\n    columnUnit = 'minute'\n  } = $$props;\n  let {\n    columnOffset = 15\n  } = $$props;\n  let {\n    ganttTableModules = []\n  } = $$props;\n  let {\n    ganttBodyModules = []\n  } = $$props;\n  let {\n    reflectOnParentRows = true\n  } = $$props;\n  let {\n    reflectOnChildRows = false\n  } = $$props;\n  let {\n    useCanvasColumns = true\n  } = $$props;\n  let {\n    columnStrokeColor = '#efefef'\n  } = $$props;\n  let {\n    columnStrokeWidth = 1\n  } = $$props;\n  let {\n    highlightedDurations\n  } = $$props;\n  let {\n    highlightColor = '#6eb859'\n  } = $$props;\n  let {\n    taskElementHook = null\n  } = $$props;\n  let {\n    layout: layout$1 = 'overlap'\n  } = $$props;\n  const visibleWidth = writable(null);\n  component_subscribe($$self, visibleWidth, value => $$invalidate(26, $visibleWidth = value));\n  const visibleHeight = writable(null);\n  component_subscribe($$self, visibleHeight, value => $$invalidate(11, $visibleHeight = value));\n  const headerHeight = writable(null);\n  component_subscribe($$self, headerHeight, value => $$invalidate(24, $headerHeight = value));\n  const _width = derived([visibleWidth, _minWidth, _fitWidth], ([visible, min, stretch]) => {\n    return stretch && visible > min ? visible : min;\n  });\n  component_subscribe($$self, _width, value => $$invalidate(12, $_width = value));\n  const dataStore = createDataStore();\n  setContext('dataStore', dataStore);\n  const {\n    rowStore,\n    taskStore,\n    timeRangeStore,\n    allTasks,\n    allRows,\n    allTimeRanges,\n    rowTaskCache,\n    draggingTaskCache\n  } = dataStore;\n  component_subscribe($$self, rowStore, value => $$invalidate(105, $rowStore = value));\n  component_subscribe($$self, taskStore, value => $$invalidate(103, $taskStore = value));\n  component_subscribe($$self, allTasks, value => $$invalidate(119, $allTasks = value));\n  component_subscribe($$self, allRows, value => $$invalidate(107, $allRows = value));\n  component_subscribe($$self, allTimeRanges, value => $$invalidate(25, $allTimeRanges = value));\n  component_subscribe($$self, rowTaskCache, value => $$invalidate(104, $rowTaskCache = value));\n  component_subscribe($$self, draggingTaskCache, value => $$invalidate(106, $draggingTaskCache = value));\n  const columnService = {\n    getColumnByDate(date) {\n      const pair = findByDate(columns, date);\n      return !pair[0] ? pair[1] : pair[0];\n    },\n    getColumnByPosition(x) {\n      const pair = findByPosition(columns, x);\n      return !pair[0] ? pair[1] : pair[0];\n    },\n    getPositionByDate(date) {\n      if (!date) return null;\n      const column = this.getColumnByDate(date);\n      let durationTo = date - column.from;\n      const position = durationTo / column.duration * column.width;\n\n      //multiples - skip every nth col, use other duration\n      return column.left + position;\n    },\n    getDateByPosition(x) {\n      const column = this.getColumnByPosition(x);\n      x = x - column.left;\n      let positionDuration = column.duration / column.width * x;\n      const date = column.from + positionDuration;\n      return date;\n    },\n    /**\n    * TODO: remove, currently unused\n    * @param {number} date - Date\n    * @returns {number} rounded date passed as parameter\n    */\n    roundTo(date) {\n      let value = Math.round(date / magnetDuration) * magnetDuration;\n      return value;\n    }\n  };\n  let disableTransition = false;\n  async function tickWithoutCSSTransition() {\n    $$invalidate(17, disableTransition = true);\n    await tick();\n    ganttElement.offsetHeight; // force a reflow\n    $$invalidate(17, disableTransition = false);\n  }\n  let columns;\n  function getColumnsV2(from, to, unit, offset, width) {\n    //BUG: Function is running twice on init, how to prevent it?\n    if (from instanceof Date) from = from.valueOf();\n    if (to instanceof Date) to = to.valueOf();\n    let cols = [];\n    const periods = getAllPeriods(from.valueOf(), to.valueOf(), unit, offset, highlightedDurations);\n    let left = 0;\n    let distance_point = 0;\n    periods.forEach(function (period) {\n      left = distance_point;\n      distance_point = getPositionByDate(period.to, $_from, $_to, $_width);\n      cols.push({\n        width: distance_point - left,\n        from: period.from,\n        to: period.to,\n        left,\n        duration: period.duration,\n        ...(period.isHighlighted && {\n          bgHighlightColor: highlightColor\n        })\n      });\n    });\n    return cols;\n  }\n  setContext('dimensions', {\n    from: _from,\n    to: _to,\n    width: _width,\n    visibleWidth,\n    visibleHeight,\n    headerHeight\n  });\n  setContext('options', {\n    dateAdapter,\n    taskElementHook,\n    taskContent,\n    rowPadding: _rowPadding,\n    rowHeight: _rowHeight,\n    resizeHandleWidth,\n    reflectOnParentRows,\n    reflectOnChildRows,\n    onTaskButtonClick\n  });\n  const hoveredRow = writable(null);\n  component_subscribe($$self, hoveredRow, value => $$invalidate(122, $hoveredRow = value));\n  const selectedRow = writable(null);\n  component_subscribe($$self, selectedRow, value => $$invalidate(123, $selectedRow = value));\n  const ganttContext = {\n    scrollables,\n    hoveredRow,\n    selectedRow\n  };\n  setContext('gantt', ganttContext);\n  onMount(() => {\n    Object.assign(ganttContext, {\n      rowContainer,\n      mainContainer,\n      mainHeaderContainer\n    });\n    api.registerEvent('tasks', 'move');\n    api.registerEvent('tasks', 'select');\n    api.registerEvent('tasks', 'switchRow');\n    api.registerEvent('tasks', 'moveEnd');\n    api.registerEvent('tasks', 'change');\n    api.registerEvent('tasks', 'changed');\n    api.registerEvent('gantt', 'viewChanged');\n    api.registerEvent('gantt', 'dateSelected');\n    api.registerEvent('tasks', 'dblclicked');\n    api.registerEvent('timeranges', 'clicked');\n    api.registerEvent('timeranges', 'resized');\n    $$invalidate(97, mounted = true);\n  });\n  const {\n    onDelegatedEvent,\n    offDelegatedEvent,\n    onEvent\n  } = createDelegatedEventDispatcher();\n  onDelegatedEvent('mousedown', 'data-task-id', (event, data, target) => {\n    const taskId = data;\n    if (isLeftClick(event) && !target.classList.contains('sg-task-reflected')) {\n      if (event.ctrlKey) {\n        selectionManager.toggleSelection(taskId, target);\n      } else {\n        selectionManager.selectSingle(taskId, target);\n      }\n      selectionManager.dispatchSelectionEvent(taskId, event);\n    }\n    api['tasks'].raise.select($taskStore.entities[taskId]);\n  });\n  onDelegatedEvent('mouseover', 'data-row-id', (event, data, target) => {\n    set_store_value(hoveredRow, $hoveredRow = data, $hoveredRow);\n  });\n  onDelegatedEvent('click', 'data-row-id', (event, data, target) => {\n    selectionManager.unSelectTasks();\n    if ($selectedRow == data) {\n      set_store_value(selectedRow, $selectedRow = null, $selectedRow);\n      return;\n    }\n    set_store_value(selectedRow, $selectedRow = data, $selectedRow);\n  });\n  onDelegatedEvent('dblclick', 'data-task-id', (event, data, target) => {\n    const taskId = data;\n    api['tasks'].raise.dblclicked($taskStore.entities[taskId], event);\n  });\n  onDelegatedEvent('mouseleave', 'empty', (event, data, target) => {\n    set_store_value(hoveredRow, $hoveredRow = null, $hoveredRow);\n  });\n  onDestroy(() => {\n    offDelegatedEvent('click', 'data-task-id');\n    offDelegatedEvent('click', 'data-row-id');\n    offDelegatedEvent('mousedown', 'data-task-id');\n    offDelegatedEvent('dblclick', 'data-task-id');\n    selectionManager.unSelectTasks();\n  });\n  let __scrollTop = 0;\n  function scrollable(node) {\n    const onscroll = event => {\n      const {\n        scrollTop,\n        scrollLeft\n      } = node;\n      scrollables.forEach(scrollable => {\n        if (scrollable.orientation === 'horizontal') {\n          scrollable.node.scrollLeft = scrollLeft;\n        } else {\n          scrollable.node.scrollTop = scrollTop;\n        }\n      });\n      $$invalidate(99, __scrollTop = scrollTop);\n    };\n    node.addEventListener('scroll', onscroll);\n    return {\n      destroy() {\n        node.removeEventListener('scroll', onscroll, false);\n      }\n    };\n  }\n  function horizontalScrollListener(node) {\n    scrollables.push({\n      node,\n      orientation: 'horizontal'\n    });\n  }\n  function onResize(event) {\n    $$invalidate(2, tableWidth = event.detail.left);\n  }\n  let zoomLevel = 0;\n  let zooming = false;\n  async function onwheel(event) {\n    if (event.ctrlKey) {\n      event.preventDefault();\n      const prevZoomLevel = zoomLevel;\n      if (event.deltaY > 0) {\n        zoomLevel = Math.max(zoomLevel - 1, 0);\n      } else {\n        zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1);\n      }\n      if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {\n        const options = {\n          columnUnit,\n          columnOffset,\n          minWidth: $_minWidth,\n          ...zoomLevels[zoomLevel]\n        };\n        const scale = options.minWidth / $_width;\n        const node = mainContainer;\n        const mousepos = getRelativePos(node, event);\n        const before = node.scrollLeft + mousepos.x;\n        const after = before * scale;\n        const scrollLeft = after - mousepos.x + node.clientWidth / 2;\n        $$invalidate(0, columnUnit = options.columnUnit);\n        $$invalidate(53, columnOffset = options.columnOffset);\n        set_store_value(_minWidth, $_minWidth = options.minWidth, $_minWidth);\n        if (options.headers) $$invalidate(1, headers = options.headers);\n        if (options.fitWidth) set_store_value(_fitWidth, $_fitWidth = options.fitWidth, $_fitWidth);\n        api['gantt'].raise.viewChanged();\n        $$invalidate(19, zooming = true);\n        await tick();\n        node.scrollLeft = scrollLeft;\n        $$invalidate(19, zooming = false);\n      }\n    }\n  }\n  function onDateSelected(event) {\n    set_store_value(_from, $_from = event.detail.from, $_from);\n    set_store_value(_to, $_to = event.detail.to, $_to);\n    api['gantt'].raise.dateSelected({\n      from: $_from,\n      to: $_to\n    });\n  }\n  function initRows(rowsData) {\n    //Bug: Running twice on change options\n    const rows = rowFactory.createRows(rowsData);\n    rowStore.addAll(rows);\n  }\n  async function initTasks(taskData) {\n    await tick();\n    const tasks = [];\n    const opts = {\n      rowPadding: $_rowPadding\n    };\n    taskData.forEach(t => {\n      const task = taskFactory.createTask(t);\n      const row = $rowStore.entities[task.model.resourceId];\n      task.reflections = [];\n      if (reflectOnChildRows && row.allChildren) {\n        row.allChildren.forEach(r => {\n          const reflectedTask = reflectTask(task, r, opts);\n          task.reflections.push(reflectedTask.model.id);\n          tasks.push(reflectedTask);\n        });\n      }\n      if (reflectOnParentRows && row.allParents.length > 0) {\n        row.allParents.forEach(r => {\n          const reflectedTask = reflectTask(task, r, opts);\n          task.reflections.push(reflectedTask.model.id);\n          tasks.push(reflectedTask);\n        });\n      }\n      tasks.push(task);\n    });\n    taskStore.addAll(tasks);\n  }\n  function initTimeRanges(timeRangeData) {\n    const timeRanges = timeRangeData.map(timeRange => {\n      return timeRangeFactory.create(timeRange);\n    });\n    timeRangeStore.addAll(timeRanges);\n  }\n  const api = new GanttApi();\n  const selectionManager = new SelectionManager(taskStore);\n  const taskFactory = new TaskFactory(columnService);\n  const rowFactory = new RowFactory();\n  const dndManager = new DragDropManager(rowStore);\n  const timeRangeFactory = new TimeRangeFactory(columnService);\n  const utils = new GanttUtils();\n  setContext('services', {\n    utils,\n    api,\n    dndManager,\n    selectionManager,\n    columnService\n  });\n  function refreshTimeRanges() {\n    timeRangeStore._update(({\n      ids,\n      entities\n    }) => {\n      ids.forEach(id => {\n        const timeRange = entities[id];\n        const newLeft = columnService.getPositionByDate(timeRange.model.from) | 0;\n        const newRight = columnService.getPositionByDate(timeRange.model.to) | 0;\n        timeRange.left = newLeft;\n        timeRange.width = newRight - newLeft;\n      });\n      return {\n        ids,\n        entities\n      };\n    });\n  }\n  function refreshTasks() {\n    $allTasks.forEach(task => {\n      const newLeft = columnService.getPositionByDate(task.model.from) | 0;\n      const newRight = columnService.getPositionByDate(task.model.to) | 0;\n      task.left = newLeft;\n      task.width = newRight - newLeft;\n    });\n    taskStore.refresh();\n  }\n  function getRowContainer() {\n    return rowContainer;\n  }\n  function selectTask(id) {\n    const task = $taskStore.entities[id];\n    if (task) {\n      selectionManager.selectSingle(id, ganttElement.querySelector(`data-task-id='${id}'`)); // TODO:: fix\n    }\n  }\n  function unselectTasks() {\n    selectionManager.unSelectTasks();\n  }\n  function scrollToRow(id, scrollBehavior = 'auto') {\n    const {\n      scrollTop,\n      clientHeight\n    } = mainContainer;\n    const index = $allRows.findIndex(r => r.model.id == id);\n    if (index === -1) return;\n    const targetTop = index * rowHeight;\n    if (targetTop < scrollTop) {\n      mainContainer.scrollTo({\n        top: targetTop,\n        behavior: scrollBehavior\n      });\n    }\n    if (targetTop > scrollTop + clientHeight) {\n      mainContainer.scrollTo({\n        top: targetTop + rowHeight - clientHeight,\n        behavior: scrollBehavior\n      });\n    }\n  }\n  function scrollToTask(id, scrollBehavior = 'auto') {\n    const {\n      scrollLeft,\n      scrollTop,\n      clientWidth,\n      clientHeight\n    } = mainContainer;\n    const task = $taskStore.entities[id];\n    if (!task) return;\n    const targetLeft = task.left;\n    const rowIndex = $allRows.findIndex(r => r.model.id == task.model.resourceId);\n    const targetTop = rowIndex * rowHeight;\n    const options = {\n      top: undefined,\n      left: undefined,\n      behavior: scrollBehavior\n    };\n    if (targetLeft < scrollLeft) {\n      options.left = targetLeft;\n    }\n    if (targetLeft > scrollLeft + clientWidth) {\n      options.left = targetLeft + task.width - clientWidth;\n    }\n    if (targetTop < scrollTop) {\n      options.top = targetTop;\n    }\n    if (targetTop > scrollTop + clientHeight) {\n      options.top = targetTop + rowHeight - clientHeight;\n    }\n    mainContainer.scrollTo(options);\n  }\n  function updateTask(model) {\n    const task = taskFactory.createTask(model);\n    taskStore.upsert(task);\n  }\n  function updateTasks(taskModels) {\n    const tasks = taskModels.map(model => taskFactory.createTask(model));\n    taskStore.upsertAll(tasks);\n  }\n  function updateRow(model) {\n    const row = rowFactory.createRow(model, null);\n    rowStore.upsert(row);\n  }\n  function updateRows(rowModels) {\n    const rows = rowModels.map(model => rowFactory.createRow(model, null));\n    rowStore.upsertAll(rows);\n  }\n  function getRow(resourceId) {\n    return $rowStore.entities[resourceId];\n  }\n  function getTask(id) {\n    return $taskStore.entities[id];\n  }\n  function getTasks(resourceId) {\n    if ($rowTaskCache[resourceId]) {\n      return $rowTaskCache[resourceId].map(id => $taskStore.entities[id]);\n    }\n    return null;\n  }\n  let filteredRows = [];\n  let rightScrollbarVisible;\n  let rowContainerHeight;\n  let startIndex;\n  let endIndex;\n  let paddingTop = 0;\n  let paddingBottom = 0;\n  let visibleRows = [];\n  let visibleTasks;\n  function div2_binding($$value) {\n    binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n      mainHeaderContainer = $$value;\n      $$invalidate(14, mainHeaderContainer);\n    });\n  }\n  function div2_elementresize_handler() {\n    $headerHeight = this.clientHeight;\n    headerHeight.set($headerHeight);\n  }\n  function div4_binding($$value) {\n    binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n      rowContainer = $$value;\n      $$invalidate(16, rowContainer);\n    });\n  }\n  function div7_binding($$value) {\n    binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n      mainContainer = $$value;\n      $$invalidate(15, mainContainer);\n    });\n  }\n  function div7_elementresize_handler() {\n    $visibleHeight = this.clientHeight;\n    visibleHeight.set($visibleHeight);\n    $visibleWidth = this.clientWidth;\n    visibleWidth.set($visibleWidth);\n  }\n  function div9_binding($$value) {\n    binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n      ganttElement = $$value;\n      $$invalidate(13, ganttElement);\n    });\n  }\n  $$self.$$set = $$new_props => {\n    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));\n    $$invalidate(52, $$restProps = compute_rest_props($$props, omit_props_names));\n    if ('rows' in $$new_props) $$invalidate(57, rows = $$new_props.rows);\n    if ('tasks' in $$new_props) $$invalidate(58, tasks = $$new_props.tasks);\n    if ('timeRanges' in $$new_props) $$invalidate(59, timeRanges = $$new_props.timeRanges);\n    if ('rowPadding' in $$new_props) $$invalidate(60, rowPadding = $$new_props.rowPadding);\n    if ('rowHeight' in $$new_props) $$invalidate(61, rowHeight = $$new_props.rowHeight);\n    if ('from' in $$new_props) $$invalidate(62, from = $$new_props.from);\n    if ('to' in $$new_props) $$invalidate(63, to = $$new_props.to);\n    if ('minWidth' in $$new_props) $$invalidate(64, minWidth = $$new_props.minWidth);\n    if ('fitWidth' in $$new_props) $$invalidate(65, fitWidth = $$new_props.fitWidth);\n    if ('classes' in $$new_props) $$invalidate(3, classes = $$new_props.classes);\n    if ('headers' in $$new_props) $$invalidate(1, headers = $$new_props.headers);\n    if ('zoomLevels' in $$new_props) $$invalidate(66, zoomLevels = $$new_props.zoomLevels);\n    if ('taskContent' in $$new_props) $$invalidate(67, taskContent = $$new_props.taskContent);\n    if ('tableWidth' in $$new_props) $$invalidate(2, tableWidth = $$new_props.tableWidth);\n    if ('resizeHandleWidth' in $$new_props) $$invalidate(68, resizeHandleWidth = $$new_props.resizeHandleWidth);\n    if ('onTaskButtonClick' in $$new_props) $$invalidate(69, onTaskButtonClick = $$new_props.onTaskButtonClick);\n    if ('dateAdapter' in $$new_props) $$invalidate(70, dateAdapter = $$new_props.dateAdapter);\n    if ('magnetUnit' in $$new_props) $$invalidate(71, magnetUnit = $$new_props.magnetUnit);\n    if ('magnetOffset' in $$new_props) $$invalidate(72, magnetOffset = $$new_props.magnetOffset);\n    if ('columnUnit' in $$new_props) $$invalidate(0, columnUnit = $$new_props.columnUnit);\n    if ('columnOffset' in $$new_props) $$invalidate(53, columnOffset = $$new_props.columnOffset);\n    if ('ganttTableModules' in $$new_props) $$invalidate(4, ganttTableModules = $$new_props.ganttTableModules);\n    if ('ganttBodyModules' in $$new_props) $$invalidate(5, ganttBodyModules = $$new_props.ganttBodyModules);\n    if ('reflectOnParentRows' in $$new_props) $$invalidate(73, reflectOnParentRows = $$new_props.reflectOnParentRows);\n    if ('reflectOnChildRows' in $$new_props) $$invalidate(74, reflectOnChildRows = $$new_props.reflectOnChildRows);\n    if ('useCanvasColumns' in $$new_props) $$invalidate(6, useCanvasColumns = $$new_props.useCanvasColumns);\n    if ('columnStrokeColor' in $$new_props) $$invalidate(7, columnStrokeColor = $$new_props.columnStrokeColor);\n    if ('columnStrokeWidth' in $$new_props) $$invalidate(8, columnStrokeWidth = $$new_props.columnStrokeWidth);\n    if ('highlightedDurations' in $$new_props) $$invalidate(75, highlightedDurations = $$new_props.highlightedDurations);\n    if ('highlightColor' in $$new_props) $$invalidate(76, highlightColor = $$new_props.highlightColor);\n    if ('taskElementHook' in $$new_props) $$invalidate(77, taskElementHook = $$new_props.taskElementHook);\n    if ('layout' in $$new_props) $$invalidate(78, layout$1 = $$new_props.layout);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty[1] & /*rows*/67108864 | $$self.$$.dirty[3] & /*mounted*/16) {\n      if (mounted) initRows(rows);\n    }\n    if ($$self.$$.dirty[1] & /*tasks*/134217728 | $$self.$$.dirty[3] & /*mounted*/16) {\n      if (mounted) initTasks(tasks);\n    }\n    if ($$self.$$.dirty[1] & /*timeRanges*/268435456 | $$self.$$.dirty[3] & /*mounted*/16) {\n      if (mounted) initTimeRanges(timeRanges);\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824) {\n      set_store_value(_rowHeight, $_rowHeight = rowHeight, $_rowHeight);\n    }\n    if ($$self.$$.dirty[1] & /*rowPadding*/536870912) {\n      set_store_value(_rowPadding, $_rowPadding = rowPadding, $_rowPadding);\n    }\n    if ($$self.$$.dirty[2] & /*from*/1) {\n      set_store_value(_from, $_from = toDateNum(from), $_from);\n    }\n    if ($$self.$$.dirty[2] & /*to*/2) {\n      set_store_value(_to, $_to = toDateNum(to), $_to);\n    }\n    if ($$self.$$.dirty[2] & /*minWidth, fitWidth*/12) {\n      {\n        set_store_value(_minWidth, $_minWidth = minWidth, $_minWidth);\n        set_store_value(_fitWidth, $_fitWidth = fitWidth, $_fitWidth);\n      }\n    }\n    if ($$self.$$.dirty[2] & /*magnetUnit, magnetOffset*/1536) {\n      setMagnetDuration(magnetUnit, magnetOffset);\n    }\n    if ($$self.$$.dirty[0] & /*columnUnit, $_width*/4097 | $$self.$$.dirty[1] & /*columnOffset*/4194304 | $$self.$$.dirty[3] & /*$_from, $_to*/98304) {\n      {\n        $$invalidate(18, columns = getColumnsV2($_from, $_to, columnUnit, columnOffset));\n        tickWithoutCSSTransition();\n        refreshTimeRanges();\n        refreshTasks();\n      }\n    }\n    if ($$self.$$.dirty[3] & /*$_rowPadding, $rowStore*/135168) {\n      {\n        $$invalidate(54, taskFactory.rowPadding = $_rowPadding, taskFactory);\n        $$invalidate(54, taskFactory.rowEntities = $rowStore.entities, taskFactory);\n      }\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824) {\n      $$invalidate(55, rowFactory.rowHeight = rowHeight, rowFactory);\n    }\n    if ($$self.$$.dirty[0] & /*$_width*/4096 | $$self.$$.dirty[2] & /*magnetOffset, magnetUnit, dateAdapter*/1792 | $$self.$$.dirty[3] & /*$_from, $_to, magnetDuration*/98336) {\n      {\n        $$invalidate(56, utils.from = $_from, utils);\n        $$invalidate(56, utils.to = $_to, utils);\n        $$invalidate(56, utils.width = $_width, utils);\n        $$invalidate(56, utils.magnetOffset = magnetOffset, utils);\n        $$invalidate(56, utils.magnetUnit = magnetUnit, utils);\n        $$invalidate(56, utils.magnetDuration = magnetDuration, utils);\n        $$invalidate(56, utils.dateAdapter = dateAdapter, utils);\n      } //utils.to = columns[columns.length - 1].to;\n      //utils.width = columns.length * columns[columns.length - 1].width;\n    }\n    if ($$self.$$.dirty[3] & /*$allRows*/16384) {\n      $$invalidate(100, filteredRows = $allRows.filter(row => !row.hidden));\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824 | $$self.$$.dirty[3] & /*filteredRows*/128) {\n      $$invalidate(9, rowContainerHeight = filteredRows.length * rowHeight);\n    }\n    if ($$self.$$.dirty[0] & /*rowContainerHeight, $visibleHeight*/2560) {\n      $$invalidate(20, rightScrollbarVisible = rowContainerHeight > $visibleHeight);\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824 | $$self.$$.dirty[3] & /*__scrollTop*/64) {\n      $$invalidate(101, startIndex = Math.floor(__scrollTop / rowHeight));\n    }\n    if ($$self.$$.dirty[0] & /*$visibleHeight*/2048 | $$self.$$.dirty[1] & /*rowHeight*/1073741824 | $$self.$$.dirty[3] & /*startIndex, filteredRows*/384) {\n      $$invalidate(102, endIndex = Math.min(startIndex + Math.ceil($visibleHeight / rowHeight), filteredRows.length - 1));\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824 | $$self.$$.dirty[3] & /*startIndex*/256) {\n      $$invalidate(21, paddingTop = startIndex * rowHeight);\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight*/1073741824 | $$self.$$.dirty[3] & /*filteredRows, endIndex*/640) {\n      $$invalidate(22, paddingBottom = (filteredRows.length - endIndex - 1) * rowHeight);\n    }\n    if ($$self.$$.dirty[3] & /*filteredRows, startIndex, endIndex*/896) {\n      $$invalidate(10, visibleRows = filteredRows.slice(startIndex, endIndex + 1));\n    }\n    if ($$self.$$.dirty[0] & /*visibleRows*/1024 | $$self.$$.dirty[3] & /*$rowTaskCache, $taskStore, $draggingTaskCache*/11264) {\n      {\n        const tasks = [];\n        const rendered = {};\n        for (let i = 0; i < visibleRows.length; i++) {\n          const row = visibleRows[i];\n          if ($rowTaskCache[row.model.id]) {\n            for (let j = 0; j < $rowTaskCache[row.model.id].length; j++) {\n              const id = $rowTaskCache[row.model.id][j];\n              tasks.push($taskStore.entities[id]);\n              rendered[id] = true;\n            }\n          }\n        }\n\n        // render all tasks being dragged if not already\n        for (const id in $draggingTaskCache) {\n          if (!rendered[id]) {\n            tasks.push($taskStore.entities[id]);\n            rendered[id] = true;\n          }\n        }\n        $$invalidate(23, visibleTasks = tasks);\n      }\n    }\n    if ($$self.$$.dirty[1] & /*rowHeight, rowPadding*/1610612736 | $$self.$$.dirty[2] & /*layout*/65536 | $$self.$$.dirty[3] & /*$rowStore, $rowTaskCache, $taskStore*/7168) {\n      {\n        if (layout$1 === 'pack') {\n          for (const rowId of $rowStore.ids) {\n            // const row = $rowStore.entities[rowId];\n            const taskIds = $rowTaskCache[rowId];\n            if (taskIds) {\n              const tasks = taskIds.map(taskId => $taskStore.entities[taskId]);\n              layout(tasks, {\n                rowContentHeight: rowHeight - rowPadding * 2\n              });\n            }\n          }\n        }\n      }\n    }\n  };\n  return [columnUnit, headers, tableWidth, classes, ganttTableModules, ganttBodyModules, useCanvasColumns, columnStrokeColor, columnStrokeWidth, rowContainerHeight, visibleRows, $visibleHeight, $_width, ganttElement, mainHeaderContainer, mainContainer, rowContainer, disableTransition, columns, zooming, rightScrollbarVisible, paddingTop, paddingBottom, visibleTasks, $headerHeight, $allTimeRanges, $visibleWidth, _rowHeight, _rowPadding, _from, _to, _minWidth, _fitWidth, visibleWidth, visibleHeight, headerHeight, _width, rowStore, taskStore, allTasks, allRows, allTimeRanges, rowTaskCache, draggingTaskCache, hoveredRow, selectedRow, onEvent, scrollable, horizontalScrollListener, onResize, onwheel, onDateSelected, $$restProps, columnOffset, taskFactory, rowFactory, utils, rows, tasks, timeRanges, rowPadding, rowHeight, from, to, minWidth, fitWidth, zoomLevels, taskContent, resizeHandleWidth, onTaskButtonClick, dateAdapter, magnetUnit, magnetOffset, reflectOnParentRows, reflectOnChildRows, highlightedDurations, highlightColor, taskElementHook, layout$1, columnService, api, dndManager, timeRangeFactory, refreshTimeRanges, refreshTasks, getRowContainer, selectTask, unselectTasks, scrollToRow, scrollToTask, updateTask, updateTasks, updateRow, updateRows, getRow, getTask, getTasks, mounted, magnetDuration, __scrollTop, filteredRows, startIndex, endIndex, $taskStore, $rowTaskCache, $rowStore, $draggingTaskCache, $allRows, $_to, $_from, $_rowPadding, div2_binding, div2_elementresize_handler, div4_binding, div7_binding, div7_elementresize_handler, div9_binding];\n}\nclass Gantt extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$5, create_fragment$5, safe_not_equal, {\n      rows: 57,\n      tasks: 58,\n      timeRanges: 59,\n      rowPadding: 60,\n      rowHeight: 61,\n      from: 62,\n      to: 63,\n      minWidth: 64,\n      fitWidth: 65,\n      classes: 3,\n      headers: 1,\n      zoomLevels: 66,\n      taskContent: 67,\n      tableWidth: 2,\n      resizeHandleWidth: 68,\n      onTaskButtonClick: 69,\n      dateAdapter: 70,\n      magnetUnit: 71,\n      magnetOffset: 72,\n      columnUnit: 0,\n      columnOffset: 53,\n      ganttTableModules: 4,\n      ganttBodyModules: 5,\n      reflectOnParentRows: 73,\n      reflectOnChildRows: 74,\n      useCanvasColumns: 6,\n      columnStrokeColor: 7,\n      columnStrokeWidth: 8,\n      highlightedDurations: 75,\n      highlightColor: 76,\n      taskElementHook: 77,\n      layout: 78,\n      columnService: 79,\n      api: 80,\n      taskFactory: 54,\n      rowFactory: 55,\n      dndManager: 81,\n      timeRangeFactory: 82,\n      utils: 56,\n      refreshTimeRanges: 83,\n      refreshTasks: 84,\n      getRowContainer: 85,\n      selectTask: 86,\n      unselectTasks: 87,\n      scrollToRow: 88,\n      scrollToTask: 89,\n      updateTask: 90,\n      updateTasks: 91,\n      updateRow: 92,\n      updateRows: 93,\n      getRow: 94,\n      getTask: 95,\n      getTasks: 96\n    }, null, [-1, -1, -1, -1, -1]);\n  }\n  get columnService() {\n    return this.$$.ctx[79];\n  }\n  get api() {\n    return this.$$.ctx[80];\n  }\n  get taskFactory() {\n    return this.$$.ctx[54];\n  }\n  get rowFactory() {\n    return this.$$.ctx[55];\n  }\n  get dndManager() {\n    return this.$$.ctx[81];\n  }\n  get timeRangeFactory() {\n    return this.$$.ctx[82];\n  }\n  get utils() {\n    return this.$$.ctx[56];\n  }\n  get refreshTimeRanges() {\n    return this.$$.ctx[83];\n  }\n  get refreshTasks() {\n    return this.$$.ctx[84];\n  }\n  get getRowContainer() {\n    return this.$$.ctx[85];\n  }\n  get selectTask() {\n    return this.$$.ctx[86];\n  }\n  get unselectTasks() {\n    return this.$$.ctx[87];\n  }\n  get scrollToRow() {\n    return this.$$.ctx[88];\n  }\n  get scrollToTask() {\n    return this.$$.ctx[89];\n  }\n  get updateTask() {\n    return this.$$.ctx[90];\n  }\n  get updateTasks() {\n    return this.$$.ctx[91];\n  }\n  get updateRow() {\n    return this.$$.ctx[92];\n  }\n  get updateRows() {\n    return this.$$.ctx[93];\n  }\n  get getRow() {\n    return this.$$.ctx[94];\n  }\n  get getTask() {\n    return this.$$.ctx[95];\n  }\n  get getTasks() {\n    return this.$$.ctx[96];\n  }\n}\nvar css_248z$4 = \".sg-tree-expander.svelte-1tk4vqn{cursor:pointer;min-width:1.4em;display:flex;justify-content:center;align-items:center}.sg-cell-inner.svelte-1tk4vqn{display:flex}\";\nstyleInject(css_248z$4);\n\n/* src\\modules\\table\\TableTreeCell.svelte generated by Svelte v4.2.1 */\n\nfunction create_if_block$2(ctx) {\n  let div;\n  let mounted;\n  let dispose;\n  function select_block_type(ctx, dirty) {\n    if ( /*row*/ctx[0].expanded) return create_if_block_1$1;\n    return create_else_block$1;\n  }\n  let current_block_type = select_block_type(ctx);\n  let if_block = current_block_type(ctx);\n  return {\n    c() {\n      div = element(\"div\");\n      if_block.c();\n      attr(div, \"class\", \"sg-tree-expander svelte-1tk4vqn\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if_block.m(div, null);\n      if (!mounted) {\n        dispose = listen(div, \"click\", /*onExpandToggle*/ctx[1]);\n        mounted = true;\n      }\n    },\n    p(ctx, dirty) {\n      if (current_block_type !== (current_block_type = select_block_type(ctx))) {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n        if (if_block) {\n          if_block.c();\n          if_block.m(div, null);\n        }\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if_block.d();\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\n// (19:12) {:else}\nfunction create_else_block$1(ctx) {\n  let i;\n  return {\n    c() {\n      i = element(\"i\");\n      attr(i, \"class\", \"fas fa-angle-right\");\n    },\n    m(target, anchor) {\n      insert(target, i, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(i);\n      }\n    }\n  };\n}\n\n// (17:12) {#if row.expanded}\nfunction create_if_block_1$1(ctx) {\n  let i;\n  return {\n    c() {\n      i = element(\"i\");\n      attr(i, \"class\", \"fas fa-angle-down\");\n    },\n    m(target, anchor) {\n      insert(target, i, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(i);\n      }\n    }\n  };\n}\nfunction create_fragment$4(ctx) {\n  let div;\n  let t;\n  let current;\n  let if_block = /*row*/ctx[0].children && create_if_block$2(ctx);\n  const default_slot_template = /*#slots*/ctx[3].default;\n  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[2], null);\n  return {\n    c() {\n      div = element(\"div\");\n      if (if_block) if_block.c();\n      t = space();\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"sg-cell-inner svelte-1tk4vqn\");\n      set_style(div, \"padding-left\", /*row*/ctx[0].childLevel * 3 + \"em\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (if_block) if_block.m(div, null);\n      append(div, t);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx, [dirty]) {\n      if ( /*row*/ctx[0].children) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$2(ctx);\n          if_block.c();\n          if_block.m(div, t);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/4)) {\n          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[2], dirty, null), null);\n        }\n      }\n      if (!current || dirty & /*row*/1) {\n        set_style(div, \"padding-left\", /*row*/ctx[0].childLevel * 3 + \"em\");\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (if_block) if_block.d();\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance$4($$self, $$props, $$invalidate) {\n  let {\n    $$slots: slots = {},\n    $$scope\n  } = $$props;\n  let {\n    row\n  } = $$props;\n  const dispatch = createEventDispatcher();\n  function onExpandToggle() {\n    if (row.expanded) {\n      dispatch('rowCollapsed', {\n        row\n      });\n    } else {\n      dispatch('rowExpanded', {\n        row\n      });\n    }\n  }\n  $$self.$$set = $$props => {\n    if ('row' in $$props) $$invalidate(0, row = $$props.row);\n    if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);\n  };\n  return [row, onExpandToggle, $$scope, slots];\n}\nclass TableTreeCell extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$4, create_fragment$4, safe_not_equal, {\n      row: 0\n    });\n  }\n}\nvar css_248z$3 = \".sg-table-row.svelte-oze9vk{display:inline-flex;min-width:100%;align-items:stretch;position:relative;font-weight:400;font-size:14px}.sg-table-cell.svelte-oze9vk{border-left:1px solid #eee}.sg-table-body-cell.svelte-oze9vk{border-bottom:#efefef 1px solid;background-color:#fff;font-weight:bold}.sg-resource-image.svelte-oze9vk{width:2.4em;height:2.4em;border-radius:50%;margin-right:0.6em;background:#047c69}.sg-resource-info.svelte-oze9vk{flex:1;height:100%;display:flex;flex-direction:row;align-items:center}.sg-table-icon.svelte-oze9vk{margin-right:0.5em}\";\nstyleInject(css_248z$3);\n\n/* src\\modules\\table\\TableRow.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$2(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[12] = list[i];\n  return child_ctx;\n}\n\n// (44:12) {:else}\nfunction create_else_block_1(ctx) {\n  let t;\n  let if_block1_anchor;\n  let if_block0 = /*row*/ctx[1].model.iconClass && create_if_block_7(ctx);\n  function select_block_type_2(ctx, dirty) {\n    if ( /*row*/ctx[1].model.headerHtml) return create_if_block_4;\n    if ( /*header*/ctx[12].renderer) return create_if_block_5;\n    if ( /*header*/ctx[12].type === 'resourceInfo') return create_if_block_6;\n    return create_else_block_2;\n  }\n  let current_block_type = select_block_type_2(ctx);\n  let if_block1 = current_block_type(ctx);\n  return {\n    c() {\n      if (if_block0) if_block0.c();\n      t = space();\n      if_block1.c();\n      if_block1_anchor = empty();\n    },\n    m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t, anchor);\n      if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if ( /*row*/ctx[1].model.iconClass) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n        } else {\n          if_block0 = create_if_block_7(ctx);\n          if_block0.c();\n          if_block0.m(t.parentNode, t);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n      if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block1) {\n        if_block1.p(ctx, dirty);\n      } else {\n        if_block1.d(1);\n        if_block1 = current_block_type(ctx);\n        if (if_block1) {\n          if_block1.c();\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n        detach(if_block1_anchor);\n      }\n      if (if_block0) if_block0.d(detaching);\n      if_block1.d(detaching);\n    }\n  };\n}\n\n// (28:12) {#if header.type == 'tree'}\nfunction create_if_block$1(ctx) {\n  let tabletreecell;\n  let current;\n  tabletreecell = new TableTreeCell({\n    props: {\n      row: /*row*/ctx[1],\n      $$slots: {\n        default: [create_default_slot]\n      },\n      $$scope: {\n        ctx\n      }\n    }\n  });\n  tabletreecell.$on(\"rowCollapsed\", /*rowCollapsed_handler*/ctx[8]);\n  tabletreecell.$on(\"rowExpanded\", /*rowExpanded_handler*/ctx[9]);\n  return {\n    c() {\n      create_component(tabletreecell.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(tabletreecell, target, anchor);\n      current = true;\n    },\n    p(ctx, dirty) {\n      const tabletreecell_changes = {};\n      if (dirty & /*row*/2) tabletreecell_changes.row = /*row*/ctx[1];\n      if (dirty & /*$$scope, row, headers*/32771) {\n        tabletreecell_changes.$$scope = {\n          dirty,\n          ctx\n        };\n      }\n      tabletreecell.$set(tabletreecell_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(tabletreecell.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(tabletreecell.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(tabletreecell, detaching);\n    }\n  };\n}\n\n// (45:16) {#if row.model.iconClass}\nfunction create_if_block_7(ctx) {\n  let div;\n  let i;\n  let i_class_value;\n  return {\n    c() {\n      div = element(\"div\");\n      i = element(\"i\");\n      attr(i, \"class\", i_class_value = \"\" + (null_to_empty( /*row*/ctx[1].model.iconClass) + \" svelte-oze9vk\"));\n      attr(div, \"class\", \"sg-table-icon svelte-oze9vk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, i);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/2 && i_class_value !== (i_class_value = \"\" + (null_to_empty( /*row*/ctx[1].model.iconClass) + \" svelte-oze9vk\"))) {\n        attr(i, \"class\", i_class_value);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (60:16) {:else}\nfunction create_else_block_2(ctx) {\n  let t_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\";\n  let t;\n  return {\n    c() {\n      t = text(t_value);\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row, headers*/3 && t_value !== (t_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\")) set_data(t, t_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\n\n// (55:57) \nfunction create_if_block_6(ctx) {\n  let img;\n  let img_src_value;\n  let t0;\n  let div;\n  let t1_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\";\n  let t1;\n  return {\n    c() {\n      img = element(\"img\");\n      t0 = space();\n      div = element(\"div\");\n      t1 = text(t1_value);\n      attr(img, \"class\", \"sg-resource-image svelte-oze9vk\");\n      if (!src_url_equal(img.src, img_src_value = /*row*/ctx[1].model.imageSrc)) attr(img, \"src\", img_src_value);\n      attr(img, \"alt\", \"\");\n      attr(div, \"class\", \"sg-resource-title\");\n    },\n    m(target, anchor) {\n      insert(target, img, anchor);\n      insert(target, t0, anchor);\n      insert(target, div, anchor);\n      append(div, t1);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/2 && !src_url_equal(img.src, img_src_value = /*row*/ctx[1].model.imageSrc)) {\n        attr(img, \"src\", img_src_value);\n      }\n      if (dirty & /*row, headers*/3 && t1_value !== (t1_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\")) set_data(t1, t1_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(img);\n        detach(t0);\n        detach(div);\n      }\n    }\n  };\n}\n\n// (53:42) \nfunction create_if_block_5(ctx) {\n  let html_tag;\n  let raw_value = /*header*/ctx[12].renderer( /*row*/ctx[1]) + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*headers, row*/3 && raw_value !== (raw_value = /*header*/ctx[12].renderer( /*row*/ctx[1]) + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (51:16) {#if row.model.headerHtml}\nfunction create_if_block_4(ctx) {\n  let html_tag;\n  let raw_value = /*row*/ctx[1].model.headerHtml + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/2 && raw_value !== (raw_value = /*row*/ctx[1].model.headerHtml + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (30:20) {#if row.model.iconClass}\nfunction create_if_block_3(ctx) {\n  let div;\n  let i;\n  let i_class_value;\n  return {\n    c() {\n      div = element(\"div\");\n      i = element(\"i\");\n      attr(i, \"class\", i_class_value = \"\" + (null_to_empty( /*row*/ctx[1].model.iconClass) + \" svelte-oze9vk\"));\n      attr(div, \"class\", \"sg-table-icon svelte-oze9vk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, i);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/2 && i_class_value !== (i_class_value = \"\" + (null_to_empty( /*row*/ctx[1].model.iconClass) + \" svelte-oze9vk\"))) {\n        attr(i, \"class\", i_class_value);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (40:20) {:else}\nfunction create_else_block(ctx) {\n  let t_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\";\n  let t;\n  return {\n    c() {\n      t = text(t_value);\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row, headers*/3 && t_value !== (t_value = /*row*/ctx[1].model[/*header*/ctx[12].property] + \"\")) set_data(t, t_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\n\n// (38:46) \nfunction create_if_block_2(ctx) {\n  let html_tag;\n  let raw_value = /*header*/ctx[12].renderer( /*row*/ctx[1]) + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*headers, row*/3 && raw_value !== (raw_value = /*header*/ctx[12].renderer( /*row*/ctx[1]) + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (36:20) {#if row.model.headerHtml}\nfunction create_if_block_1(ctx) {\n  let html_tag;\n  let raw_value = /*row*/ctx[1].model.headerHtml + \"\";\n  let html_anchor;\n  return {\n    c() {\n      html_tag = new HtmlTag(false);\n      html_anchor = empty();\n      html_tag.a = html_anchor;\n    },\n    m(target, anchor) {\n      html_tag.m(raw_value, target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*row*/2 && raw_value !== (raw_value = /*row*/ctx[1].model.headerHtml + \"\")) html_tag.p(raw_value);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(html_anchor);\n        html_tag.d();\n      }\n    }\n  };\n}\n\n// (29:16) <TableTreeCell on:rowCollapsed on:rowExpanded {row}>\nfunction create_default_slot(ctx) {\n  let t;\n  let if_block1_anchor;\n  let if_block0 = /*row*/ctx[1].model.iconClass && create_if_block_3(ctx);\n  function select_block_type_1(ctx, dirty) {\n    if ( /*row*/ctx[1].model.headerHtml) return create_if_block_1;\n    if ( /*header*/ctx[12].renderer) return create_if_block_2;\n    return create_else_block;\n  }\n  let current_block_type = select_block_type_1(ctx);\n  let if_block1 = current_block_type(ctx);\n  return {\n    c() {\n      if (if_block0) if_block0.c();\n      t = space();\n      if_block1.c();\n      if_block1_anchor = empty();\n    },\n    m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t, anchor);\n      if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n    },\n    p(ctx, dirty) {\n      if ( /*row*/ctx[1].model.iconClass) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n        } else {\n          if_block0 = create_if_block_3(ctx);\n          if_block0.c();\n          if_block0.m(t.parentNode, t);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {\n        if_block1.p(ctx, dirty);\n      } else {\n        if_block1.d(1);\n        if_block1 = current_block_type(ctx);\n        if (if_block1) {\n          if_block1.c();\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n        detach(if_block1_anchor);\n      }\n      if (if_block0) if_block0.d(detaching);\n      if_block1.d(detaching);\n    }\n  };\n}\n\n// (26:4) {#each headers as header}\nfunction create_each_block$2(ctx) {\n  let div;\n  let current_block_type_index;\n  let if_block;\n  let t;\n  let current;\n  const if_block_creators = [create_if_block$1, create_else_block_1];\n  const if_blocks = [];\n  function select_block_type(ctx, dirty) {\n    if ( /*header*/ctx[12].type == 'tree') return 0;\n    return 1;\n  }\n  current_block_type_index = select_block_type(ctx);\n  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  return {\n    c() {\n      div = element(\"div\");\n      if_block.c();\n      t = space();\n      attr(div, \"class\", \"sg-table-body-cell sg-table-cell svelte-oze9vk\");\n      set_style(div, \"width\", /*header*/ctx[12].width + \"px\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if_blocks[current_block_type_index].m(div, null);\n      append(div, t);\n      current = true;\n    },\n    p(ctx, dirty) {\n      let previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, () => {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block = if_blocks[current_block_type_index];\n        if (!if_block) {\n          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block.c();\n        } else {\n          if_block.p(ctx, dirty);\n        }\n        transition_in(if_block, 1);\n        if_block.m(div, t);\n      }\n      if (!current || dirty & /*headers*/1) {\n        set_style(div, \"width\", /*header*/ctx[12].width + \"px\");\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(if_block);\n      current = true;\n    },\n    o(local) {\n      transition_out(if_block);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if_blocks[current_block_type_index].d();\n    }\n  };\n}\nfunction create_fragment$3(ctx) {\n  let div;\n  let div_data_row_id_value;\n  let div_class_value;\n  let current;\n  let each_value = ensure_array_like( /*headers*/ctx[0]);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));\n  }\n  const out = i => transition_out(each_blocks[i], 1, 1, () => {\n    each_blocks[i] = null;\n  });\n  return {\n    c() {\n      div = element(\"div\");\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div, \"data-row-id\", div_data_row_id_value = /*row*/ctx[1].model.id);\n      set_style(div, \"height\", /*$rowHeight*/ctx[2] + \"px\");\n      attr(div, \"class\", div_class_value = \"sg-table-row \" + ( /*row*/ctx[1].model.classes || '') + \" svelte-oze9vk\");\n      toggle_class(div, \"sg-row-expanded\", /*row*/ctx[1].expanded);\n      toggle_class(div, \"sg-hover\", /*$hoveredRow*/ctx[3] == /*row*/ctx[1].model.id);\n      toggle_class(div, \"sg-selected\", /*$selectedRow*/ctx[4] == /*row*/ctx[1].model.id);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div, null);\n        }\n      }\n      current = true;\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*headers, row*/3) {\n        each_value = ensure_array_like( /*headers*/ctx[0]);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$2(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n            transition_in(each_blocks[i], 1);\n          } else {\n            each_blocks[i] = create_each_block$2(child_ctx);\n            each_blocks[i].c();\n            transition_in(each_blocks[i], 1);\n            each_blocks[i].m(div, null);\n          }\n        }\n        group_outros();\n        for (i = each_value.length; i < each_blocks.length; i += 1) {\n          out(i);\n        }\n        check_outros();\n      }\n      if (!current || dirty & /*row*/2 && div_data_row_id_value !== (div_data_row_id_value = /*row*/ctx[1].model.id)) {\n        attr(div, \"data-row-id\", div_data_row_id_value);\n      }\n      if (!current || dirty & /*$rowHeight*/4) {\n        set_style(div, \"height\", /*$rowHeight*/ctx[2] + \"px\");\n      }\n      if (!current || dirty & /*row*/2 && div_class_value !== (div_class_value = \"sg-table-row \" + ( /*row*/ctx[1].model.classes || '') + \" svelte-oze9vk\")) {\n        attr(div, \"class\", div_class_value);\n      }\n      if (!current || dirty & /*row, row*/2) {\n        toggle_class(div, \"sg-row-expanded\", /*row*/ctx[1].expanded);\n      }\n      if (!current || dirty & /*row, $hoveredRow, row*/10) {\n        toggle_class(div, \"sg-hover\", /*$hoveredRow*/ctx[3] == /*row*/ctx[1].model.id);\n      }\n      if (!current || dirty & /*row, $selectedRow, row*/18) {\n        toggle_class(div, \"sg-selected\", /*$selectedRow*/ctx[4] == /*row*/ctx[1].model.id);\n      }\n    },\n    i(local) {\n      if (current) return;\n      for (let i = 0; i < each_value.length; i += 1) {\n        transition_in(each_blocks[i]);\n      }\n      current = true;\n    },\n    o(local) {\n      each_blocks = each_blocks.filter(Boolean);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        transition_out(each_blocks[i]);\n      }\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      destroy_each(each_blocks, detaching);\n    }\n  };\n}\nfunction instance$3($$self, $$props, $$invalidate) {\n  let $rowHeight;\n  let $hoveredRow;\n  let $selectedRow;\n  let {\n    headers = null\n  } = $$props;\n  let {\n    row = null\n  } = $$props;\n  const {\n    rowHeight\n  } = getContext('options');\n  component_subscribe($$self, rowHeight, value => $$invalidate(2, $rowHeight = value));\n  const {\n    hoveredRow,\n    selectedRow\n  } = getContext('gantt');\n  component_subscribe($$self, hoveredRow, value => $$invalidate(3, $hoveredRow = value));\n  component_subscribe($$self, selectedRow, value => $$invalidate(4, $selectedRow = value));\n  const dispatch = createEventDispatcher();\n  onMount(() => {\n    if (row.model.expanded == false) dispatch('rowCollapsed', {\n      row\n    });\n  });\n  function rowCollapsed_handler(event) {\n    bubble.call(this, $$self, event);\n  }\n  function rowExpanded_handler(event) {\n    bubble.call(this, $$self, event);\n  }\n  $$self.$$set = $$props => {\n    if ('headers' in $$props) $$invalidate(0, headers = $$props.headers);\n    if ('row' in $$props) $$invalidate(1, row = $$props.row);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*row*/2) {\n      {\n        row.parent ? `padding-left: ${row.childLevel * 3}em;` : '';\n      }\n    }\n  };\n  return [headers, row, $rowHeight, $hoveredRow, $selectedRow, rowHeight, hoveredRow, selectedRow, rowCollapsed_handler, rowExpanded_handler];\n}\nclass TableRow extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$3, create_fragment$3, safe_not_equal, {\n      headers: 0,\n      row: 1\n    });\n  }\n}\nvar css_248z$2 = \".bottom-scrollbar-visible.svelte-afbyi7{padding-bottom:17px}.sg-table.svelte-afbyi7{overflow-x:auto;display:flex;flex-direction:column}.sg-table-scroller.svelte-afbyi7{width:100%;border-bottom:1px solid #efefef;overflow-y:hidden}.sg-table-header.svelte-afbyi7{display:flex;align-items:stretch;overflow:hidden;border-bottom:#efefef 1px solid;background-color:#fbfbfb}.sg-table-body.svelte-afbyi7{display:flex;flex:1 1 0;width:100%;overflow-y:hidden}.sg-table-header-cell.svelte-afbyi7{font-size:14px;font-weight:400}.sg-table-cell{white-space:nowrap;overflow:hidden;display:flex;align-items:center;flex-shrink:0;padding:0 0.5em;height:100%}.sg-table-cell:last-child{flex-grow:1}\";\nstyleInject(css_248z$2);\n\n/* src\\modules\\table\\Table.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context$1(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[32] = list[i];\n  return child_ctx;\n}\nfunction get_each_context_1(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[35] = list[i];\n  return child_ctx;\n}\n\n// (98:8) {#each tableHeaders as header}\nfunction create_each_block_1(ctx) {\n  let div;\n  let t0_value = /*header*/ctx[35].title + \"\";\n  let t0;\n  let t1;\n  return {\n    c() {\n      div = element(\"div\");\n      t0 = text(t0_value);\n      t1 = space();\n      attr(div, \"class\", \"sg-table-header-cell sg-table-cell svelte-afbyi7\");\n      set_style(div, \"width\", /*header*/ctx[35].width + \"px\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, t0);\n      append(div, t1);\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*tableHeaders*/32 && t0_value !== (t0_value = /*header*/ctx[35].title + \"\")) set_data(t0, t0_value);\n      if (dirty[0] & /*tableHeaders*/32) {\n        set_style(div, \"width\", /*header*/ctx[35].width + \"px\");\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\n\n// (111:16) {#each visibleRows as row}\nfunction create_each_block$1(ctx) {\n  let tablerow;\n  let current;\n  tablerow = new TableRow({\n    props: {\n      row: /*row*/ctx[32],\n      headers: /*tableHeaders*/ctx[5]\n    }\n  });\n  tablerow.$on(\"rowExpanded\", /*onRowExpanded*/ctx[17]);\n  tablerow.$on(\"rowCollapsed\", /*onRowCollapsed*/ctx[18]);\n  return {\n    c() {\n      create_component(tablerow.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(tablerow, target, anchor);\n      current = true;\n    },\n    p(ctx, dirty) {\n      const tablerow_changes = {};\n      if (dirty[0] & /*visibleRows*/16) tablerow_changes.row = /*row*/ctx[32];\n      if (dirty[0] & /*tableHeaders*/32) tablerow_changes.headers = /*tableHeaders*/ctx[5];\n      tablerow.$set(tablerow_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(tablerow.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(tablerow.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(tablerow, detaching);\n    }\n  };\n}\nfunction create_fragment$2(ctx) {\n  let div4;\n  let div0;\n  let t;\n  let div3;\n  let div2;\n  let div1;\n  let current;\n  let mounted;\n  let dispose;\n  let each_value_1 = ensure_array_like( /*tableHeaders*/ctx[5]);\n  let each_blocks_1 = [];\n  for (let i = 0; i < each_value_1.length; i += 1) {\n    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));\n  }\n  let each_value = ensure_array_like( /*visibleRows*/ctx[4]);\n  let each_blocks = [];\n  for (let i = 0; i < each_value.length; i += 1) {\n    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));\n  }\n  const out = i => transition_out(each_blocks[i], 1, 1, () => {\n    each_blocks[i] = null;\n  });\n  return {\n    c() {\n      div4 = element(\"div\");\n      div0 = element(\"div\");\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        each_blocks_1[i].c();\n      }\n      t = space();\n      div3 = element(\"div\");\n      div2 = element(\"div\");\n      div1 = element(\"div\");\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div0, \"class\", \"sg-table-header svelte-afbyi7\");\n      set_style(div0, \"height\", /*$headerHeight*/ctx[8] + \"px\");\n      attr(div1, \"class\", \"sg-table-rows svelte-afbyi7\");\n      set_style(div1, \"padding-top\", /*paddingTop*/ctx[1] + \"px\");\n      set_style(div1, \"padding-bottom\", /*paddingBottom*/ctx[2] + \"px\");\n      set_style(div1, \"height\", /*rowContainerHeight*/ctx[3] + \"px\");\n      attr(div2, \"class\", \"sg-table-scroller svelte-afbyi7\");\n      attr(div3, \"class\", \"sg-table-body svelte-afbyi7\");\n      toggle_class(div3, \"bottom-scrollbar-visible\", /*bottomScrollbarVisible*/ctx[7]);\n      attr(div4, \"class\", \"sg-table sg-view svelte-afbyi7\");\n      set_style(div4, \"width\", /*tableWidth*/ctx[0] + \"px\");\n    },\n    m(target, anchor) {\n      insert(target, div4, anchor);\n      append(div4, div0);\n      for (let i = 0; i < each_blocks_1.length; i += 1) {\n        if (each_blocks_1[i]) {\n          each_blocks_1[i].m(div0, null);\n        }\n      }\n\n      /*div0_binding*/\n      ctx[22](div0);\n      append(div4, t);\n      append(div4, div3);\n      append(div3, div2);\n      append(div2, div1);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div1, null);\n        }\n      }\n      current = true;\n      if (!mounted) {\n        dispose = action_destroyer( /*scrollListener*/ctx[16].call(null, div2));\n        mounted = true;\n      }\n    },\n    p(ctx, dirty) {\n      if (dirty[0] & /*tableHeaders*/32) {\n        each_value_1 = ensure_array_like( /*tableHeaders*/ctx[5]);\n        let i;\n        for (i = 0; i < each_value_1.length; i += 1) {\n          const child_ctx = get_each_context_1(ctx, each_value_1, i);\n          if (each_blocks_1[i]) {\n            each_blocks_1[i].p(child_ctx, dirty);\n          } else {\n            each_blocks_1[i] = create_each_block_1(child_ctx);\n            each_blocks_1[i].c();\n            each_blocks_1[i].m(div0, null);\n          }\n        }\n        for (; i < each_blocks_1.length; i += 1) {\n          each_blocks_1[i].d(1);\n        }\n        each_blocks_1.length = each_value_1.length;\n      }\n      if (!current || dirty[0] & /*$headerHeight*/256) {\n        set_style(div0, \"height\", /*$headerHeight*/ctx[8] + \"px\");\n      }\n      if (dirty[0] & /*visibleRows, tableHeaders, onRowExpanded, onRowCollapsed*/393264) {\n        each_value = ensure_array_like( /*visibleRows*/ctx[4]);\n        let i;\n        for (i = 0; i < each_value.length; i += 1) {\n          const child_ctx = get_each_context$1(ctx, each_value, i);\n          if (each_blocks[i]) {\n            each_blocks[i].p(child_ctx, dirty);\n            transition_in(each_blocks[i], 1);\n          } else {\n            each_blocks[i] = create_each_block$1(child_ctx);\n            each_blocks[i].c();\n            transition_in(each_blocks[i], 1);\n            each_blocks[i].m(div1, null);\n          }\n        }\n        group_outros();\n        for (i = each_value.length; i < each_blocks.length; i += 1) {\n          out(i);\n        }\n        check_outros();\n      }\n      if (!current || dirty[0] & /*paddingTop*/2) {\n        set_style(div1, \"padding-top\", /*paddingTop*/ctx[1] + \"px\");\n      }\n      if (!current || dirty[0] & /*paddingBottom*/4) {\n        set_style(div1, \"padding-bottom\", /*paddingBottom*/ctx[2] + \"px\");\n      }\n      if (!current || dirty[0] & /*rowContainerHeight*/8) {\n        set_style(div1, \"height\", /*rowContainerHeight*/ctx[3] + \"px\");\n      }\n      if (!current || dirty[0] & /*bottomScrollbarVisible*/128) {\n        toggle_class(div3, \"bottom-scrollbar-visible\", /*bottomScrollbarVisible*/ctx[7]);\n      }\n      if (!current || dirty[0] & /*tableWidth*/1) {\n        set_style(div4, \"width\", /*tableWidth*/ctx[0] + \"px\");\n      }\n    },\n    i(local) {\n      if (current) return;\n      for (let i = 0; i < each_value.length; i += 1) {\n        transition_in(each_blocks[i]);\n      }\n      current = true;\n    },\n    o(local) {\n      each_blocks = each_blocks.filter(Boolean);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        transition_out(each_blocks[i]);\n      }\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div4);\n      }\n      destroy_each(each_blocks_1, detaching);\n      /*div0_binding*/\n      ctx[22](null);\n      destroy_each(each_blocks, detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction hide(children) {\n  children.forEach(row => {\n    if (row.children) hide(row.children);\n    row.hidden = true;\n  });\n}\nfunction show(children, hidden = false) {\n  children.forEach(row => {\n    if (row.children) show(row.children, !row.expanded);\n    row.hidden = hidden;\n  });\n}\nfunction instance$2($$self, $$props, $$invalidate) {\n  let $visibleWidth;\n  let $width;\n  let $rowPadding;\n  let $taskStore;\n  let $rowStore;\n  let $rowHeight;\n  let $headerHeight;\n  const dispatch = createEventDispatcher();\n  let {\n    tableWidth\n  } = $$props;\n  let {\n    paddingTop\n  } = $$props;\n  let {\n    paddingBottom\n  } = $$props;\n  let {\n    rowContainerHeight\n  } = $$props;\n  let {\n    visibleRows\n  } = $$props;\n  let {\n    tableHeaders = [{\n      title: 'Name',\n      property: 'label',\n      width: 100\n    }]\n  } = $$props;\n  const {\n    from,\n    to,\n    width,\n    visibleWidth,\n    headerHeight\n  } = getContext('dimensions');\n  component_subscribe($$self, width, value => $$invalidate(21, $width = value));\n  component_subscribe($$self, visibleWidth, value => $$invalidate(20, $visibleWidth = value));\n  component_subscribe($$self, headerHeight, value => $$invalidate(8, $headerHeight = value));\n  const {\n    rowPadding,\n    rowHeight\n  } = getContext('options');\n  component_subscribe($$self, rowPadding, value => $$invalidate(23, $rowPadding = value));\n  component_subscribe($$self, rowHeight, value => $$invalidate(26, $rowHeight = value));\n  const {\n    rowStore,\n    taskStore\n  } = getContext('dataStore');\n  component_subscribe($$self, rowStore, value => $$invalidate(25, $rowStore = value));\n  component_subscribe($$self, taskStore, value => $$invalidate(24, $taskStore = value));\n  const {\n    scrollables\n  } = getContext('gantt');\n  onMount(() => {\n    dispatch('init', {\n      module: this\n    });\n  });\n  let headerContainer;\n  function scrollListener(node) {\n    scrollables.push({\n      node,\n      orientation: 'vertical'\n    });\n    function onScroll(event) {\n      $$invalidate(6, headerContainer.scrollLeft = node.scrollLeft, headerContainer);\n    }\n    node.addEventListener('scroll', onScroll);\n    return {\n      destroy() {\n        node.removeEventListener('scroll', onScroll);\n      }\n    };\n  }\n  let scrollWidth;\n  function onRowExpanded(event) {\n    const row = event.detail.row;\n    row.expanded = true;\n    if (row.children) show(row.children);\n    updateYPositions();\n  }\n  function onRowCollapsed(event) {\n    const row = event.detail.row;\n    row.expanded = false;\n    if (row.children) hide(row.children);\n    updateYPositions();\n  }\n  function updateYPositions() {\n    let y = 0;\n    $rowStore.ids.forEach(id => {\n      const row = $rowStore.entities[id];\n      if (!row.hidden) {\n        set_store_value(rowStore, $rowStore.entities[id].y = y, $rowStore);\n        y += $rowHeight;\n      }\n    });\n    $taskStore.ids.forEach(id => {\n      const task = $taskStore.entities[id];\n      const row = $rowStore.entities[task.model.resourceId];\n      set_store_value(taskStore, $taskStore.entities[id].top = row.y + $rowPadding, $taskStore);\n    });\n  }\n\n  // if gantt displays a bottom scrollbar and table does not, we need to pad out the table\n  let bottomScrollbarVisible;\n  function div0_binding($$value) {\n    binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n      headerContainer = $$value;\n      $$invalidate(6, headerContainer);\n    });\n  }\n  $$self.$$set = $$props => {\n    if ('tableWidth' in $$props) $$invalidate(0, tableWidth = $$props.tableWidth);\n    if ('paddingTop' in $$props) $$invalidate(1, paddingTop = $$props.paddingTop);\n    if ('paddingBottom' in $$props) $$invalidate(2, paddingBottom = $$props.paddingBottom);\n    if ('rowContainerHeight' in $$props) $$invalidate(3, rowContainerHeight = $$props.rowContainerHeight);\n    if ('visibleRows' in $$props) $$invalidate(4, visibleRows = $$props.visibleRows);\n    if ('tableHeaders' in $$props) $$invalidate(5, tableHeaders = $$props.tableHeaders);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty[0] & /*tableHeaders*/32) {\n      {\n        let sum = 0;\n        tableHeaders.forEach(header => {\n          sum += header.width;\n        });\n        $$invalidate(19, scrollWidth = sum);\n      }\n    }\n    if ($$self.$$.dirty[0] & /*$width, $visibleWidth, scrollWidth, tableWidth*/3670017) {\n      {\n        $$invalidate(7, bottomScrollbarVisible = $width > $visibleWidth && scrollWidth <= tableWidth);\n      }\n    }\n  };\n  return [tableWidth, paddingTop, paddingBottom, rowContainerHeight, visibleRows, tableHeaders, headerContainer, bottomScrollbarVisible, $headerHeight, width, visibleWidth, headerHeight, rowPadding, rowHeight, rowStore, taskStore, scrollListener, onRowExpanded, onRowCollapsed, scrollWidth, $visibleWidth, $width, div0_binding];\n}\nclass Table extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$2, create_fragment$2, safe_not_equal, {\n      tableWidth: 0,\n      paddingTop: 1,\n      paddingBottom: 2,\n      rowContainerHeight: 3,\n      visibleRows: 4,\n      tableHeaders: 5\n    }, null, [-1, -1]);\n  }\n}\nvar SvelteGanttTable = Table;\nvar css_248z$1 = \".sg-dependency.svelte-12syssu{position:absolute;width:100%;height:100%}.arrow.svelte-12syssu{position:absolute;left:0px;pointer-events:none}.select-area.svelte-12syssu{pointer-events:visible;position:absolute}\";\nstyleInject(css_248z$1);\n\n/* src\\modules\\dependencies\\Dependency.svelte generated by Svelte v4.2.1 */\n\nfunction create_if_block(ctx) {\n  let div;\n  let svg;\n  let path0;\n  let path1;\n  return {\n    c() {\n      div = element(\"div\");\n      svg = svg_element(\"svg\");\n      path0 = svg_element(\"path\");\n      path1 = svg_element(\"path\");\n      attr(path0, \"class\", \"select-area svelte-12syssu\");\n      attr(path0, \"d\", /*path*/ctx[6]);\n      attr(path0, \"stroke\", /*stroke*/ctx[1]);\n      attr(path0, \"stroke-width\", /*strokeWidth*/ctx[2]);\n      attr(path0, \"fill\", \"transparent\");\n      attr(path1, \"d\", /*arrowPath*/ctx[5]);\n      attr(path1, \"fill\", /*stroke*/ctx[1]);\n      attr(svg, \"class\", \"arrow svelte-12syssu\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"shape-rendering\", \"crispEdges\");\n      attr(svg, \"height\", \"100%\");\n      attr(svg, \"width\", \"100%\");\n      attr(div, \"class\", \"sg-dependency svelte-12syssu\");\n      set_style(div, \"left\", \"0\");\n      set_style(div, \"top\", \"0\");\n      attr(div, \"data-dependency-id\", /*id*/ctx[0]);\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, svg);\n      append(svg, path0);\n      append(svg, path1);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*path*/64) {\n        attr(path0, \"d\", /*path*/ctx[6]);\n      }\n      if (dirty & /*stroke*/2) {\n        attr(path0, \"stroke\", /*stroke*/ctx[1]);\n      }\n      if (dirty & /*strokeWidth*/4) {\n        attr(path0, \"stroke-width\", /*strokeWidth*/ctx[2]);\n      }\n      if (dirty & /*arrowPath*/32) {\n        attr(path1, \"d\", /*arrowPath*/ctx[5]);\n      }\n      if (dirty & /*stroke*/2) {\n        attr(path1, \"fill\", /*stroke*/ctx[1]);\n      }\n      if (dirty & /*id*/1) {\n        attr(div, \"data-dependency-id\", /*id*/ctx[0]);\n      }\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n    }\n  };\n}\nfunction create_fragment$1(ctx) {\n  let if_block_anchor;\n  let if_block = (! /*isFromRowHidden*/ctx[3] && ! /*isToRowHidden*/ctx[4] || /*isFromRowHidden*/ctx[3] !== /*isToRowHidden*/ctx[4]) && create_if_block(ctx);\n  return {\n    c() {\n      if (if_block) if_block.c();\n      if_block_anchor = empty();\n    },\n    m(target, anchor) {\n      if (if_block) if_block.m(target, anchor);\n      insert(target, if_block_anchor, anchor);\n    },\n    p(ctx, [dirty]) {\n      if (! /*isFromRowHidden*/ctx[3] && ! /*isToRowHidden*/ctx[4] || /*isFromRowHidden*/ctx[3] !== /*isToRowHidden*/ctx[4]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block(ctx);\n          if_block.c();\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(if_block_anchor);\n      }\n      if (if_block) if_block.d(detaching);\n    }\n  };\n}\nconst MIN_LEN = 12;\nconst ARROW_SIZE = 5;\nfunction instance$1($$self, $$props, $$invalidate) {\n  let $rowStore;\n  let $taskStore;\n  const {\n    rowStore,\n    taskStore\n  } = getContext('dataStore');\n  component_subscribe($$self, rowStore, value => $$invalidate(13, $rowStore = value));\n  component_subscribe($$self, taskStore, value => $$invalidate(14, $taskStore = value));\n  let {\n    id\n  } = $$props;\n  let {\n    fromId\n  } = $$props;\n  let {\n    toId\n  } = $$props;\n  let {\n    stroke = 'red'\n  } = $$props;\n  let {\n    strokeWidth = 2\n  } = $$props;\n  let arrowPath;\n  let path;\n  let fromTask;\n  let isFromRowHidden;\n  let toTask;\n  let isToRowHidden;\n  $$self.$$set = $$props => {\n    if ('id' in $$props) $$invalidate(0, id = $$props.id);\n    if ('fromId' in $$props) $$invalidate(9, fromId = $$props.fromId);\n    if ('toId' in $$props) $$invalidate(10, toId = $$props.toId);\n    if ('stroke' in $$props) $$invalidate(1, stroke = $$props.stroke);\n    if ('strokeWidth' in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*$taskStore, fromId, $rowStore, fromTask, toId, toTask, isFromRowHidden, path, isToRowHidden*/32344) {\n      {\n        $$invalidate(11, fromTask = $taskStore.entities[fromId]);\n        $$invalidate(3, isFromRowHidden = $rowStore.entities[fromTask.model.resourceId].hidden);\n        $$invalidate(12, toTask = $taskStore.entities[toId]);\n        $$invalidate(4, isToRowHidden = $rowStore.entities[toTask.model.resourceId].hidden);\n        let startY = fromTask.top + fromTask.height / 2;\n        let startX = fromTask.left + fromTask.width;\n        let endY = toTask.top + toTask.height / 2;\n        let endX = toTask.left;\n        let width = endX - startX;\n        let height = endY - startY;\n        if (isFromRowHidden) {\n          $$invalidate(6, path = `M${endX} ${endY}`);\n          if (startX + MIN_LEN >= endX && startY != endY) {\n            $$invalidate(6, path += `L ${endX + 1.5 - MIN_LEN} ${endY}`);\n          } else {\n            $$invalidate(6, path += `L ${endX + 1.5 - width / 2} ${endY}`);\n          }\n          $$invalidate(6, path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`);\n          $$invalidate(5, arrowPath = `M${toTask.left - ARROW_SIZE}  ${toTask.top + toTask.height / 2 - ARROW_SIZE} \n                            L${toTask.left} ${toTask.top + toTask.height / 2} \n                            L${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 + ARROW_SIZE} Z`);\n        } else if (isToRowHidden) {\n          $$invalidate(6, path = `M${startX} ${startY}`);\n          if (startX + MIN_LEN >= endX && startY != endY) {\n            $$invalidate(6, path += `L ${startX + 1.5 + MIN_LEN} ${startY}`);\n          } else {\n            $$invalidate(6, path += `L ${startX + 1.5 + width / 2} ${startY}`);\n          }\n          $$invalidate(6, path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`);\n          $$invalidate(5, arrowPath = ``);\n        } else if (!isFromRowHidden && !isToRowHidden) {\n          $$invalidate(6, path = `M${startX} ${startY}`);\n          if (startX + MIN_LEN >= endX && startY != endY) {\n            $$invalidate(6, path += `L ${startX + MIN_LEN} ${startY} \n                            L ${startX + MIN_LEN} ${startY + height / 2}\n                            L ${endX - MIN_LEN} ${startY + height / 2}\n                            L ${endX - MIN_LEN} ${endY}\n                            L ${endX - 2} ${endY}`);\n          } else {\n            $$invalidate(6, path += `L ${startX + width / 2} ${startY} \n                            L ${startX + width / 2} ${endY}\n                            L ${endX - 2} ${endY}`);\n          }\n          $$invalidate(5, arrowPath = `M${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 - ARROW_SIZE} \n                            L${toTask.left} ${toTask.top + toTask.height / 2} \n                            L${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 + ARROW_SIZE} Z`);\n        }\n      }\n    }\n  };\n  return [id, stroke, strokeWidth, isFromRowHidden, isToRowHidden, arrowPath, path, rowStore, taskStore, fromId, toId, fromTask, toTask, $rowStore, $taskStore];\n}\nclass Dependency extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$1, create_fragment$1, safe_not_equal, {\n      id: 0,\n      fromId: 9,\n      toId: 10,\n      stroke: 1,\n      strokeWidth: 2\n    });\n  }\n}\nvar css_248z = \".dependency-container.svelte-epxabx{position:absolute;width:100%;height:100%;pointer-events:none;top:0;float:left;overflow:hidden;z-index:0}\";\nstyleInject(css_248z);\n\n/* src\\modules\\dependencies\\GanttDependencies.svelte generated by Svelte v4.2.1 */\n\nfunction get_each_context(ctx, list, i) {\n  const child_ctx = ctx.slice();\n  child_ctx[7] = list[i];\n  return child_ctx;\n}\n\n// (27:4) {#each visibleDependencies as dependency (dependency.id)}\nfunction create_each_block(key_1, ctx) {\n  let first;\n  let dependency_1;\n  let current;\n  const dependency_1_spread_levels = [/*dependency*/ctx[7]];\n  let dependency_1_props = {};\n  for (let i = 0; i < dependency_1_spread_levels.length; i += 1) {\n    dependency_1_props = assign(dependency_1_props, dependency_1_spread_levels[i]);\n  }\n  dependency_1 = new Dependency({\n    props: dependency_1_props\n  });\n  return {\n    key: key_1,\n    first: null,\n    c() {\n      first = empty();\n      create_component(dependency_1.$$.fragment);\n      this.first = first;\n    },\n    m(target, anchor) {\n      insert(target, first, anchor);\n      mount_component(dependency_1, target, anchor);\n      current = true;\n    },\n    p(new_ctx, dirty) {\n      ctx = new_ctx;\n      const dependency_1_changes = dirty & /*visibleDependencies*/1 ? get_spread_update(dependency_1_spread_levels, [get_spread_object( /*dependency*/ctx[7])]) : {};\n      dependency_1.$set(dependency_1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(dependency_1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(dependency_1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(first);\n      }\n      destroy_component(dependency_1, detaching);\n    }\n  };\n}\nfunction create_fragment(ctx) {\n  let div;\n  let each_blocks = [];\n  let each_1_lookup = new Map();\n  let current;\n  let each_value = ensure_array_like( /*visibleDependencies*/ctx[0]);\n  const get_key = ctx => /*dependency*/ctx[7].id;\n  for (let i = 0; i < each_value.length; i += 1) {\n    let child_ctx = get_each_context(ctx, each_value, i);\n    let key = get_key(child_ctx);\n    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));\n  }\n  return {\n    c() {\n      div = element(\"div\");\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].c();\n      }\n      attr(div, \"class\", \"dependency-container svelte-epxabx\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        if (each_blocks[i]) {\n          each_blocks[i].m(div, null);\n        }\n      }\n      current = true;\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*visibleDependencies*/1) {\n        each_value = ensure_array_like( /*visibleDependencies*/ctx[0]);\n        group_outros();\n        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);\n        check_outros();\n      }\n    },\n    i(local) {\n      if (current) return;\n      for (let i = 0; i < each_value.length; i += 1) {\n        transition_in(each_blocks[i]);\n      }\n      current = true;\n    },\n    o(local) {\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        transition_out(each_blocks[i]);\n      }\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      for (let i = 0; i < each_blocks.length; i += 1) {\n        each_blocks[i].d();\n      }\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let $visibleHeight;\n  let $taskStore;\n  const {\n    visibleHeight\n  } = getContext('dimensions');\n  component_subscribe($$self, visibleHeight, value => $$invalidate(5, $visibleHeight = value));\n  const {\n    taskStore\n  } = getContext('dataStore');\n  component_subscribe($$self, taskStore, value => $$invalidate(6, $taskStore = value));\n  let {\n    paddingTop\n  } = $$props;\n  let {\n    dependencies = []\n  } = $$props;\n  let visibleDependencies = [];\n  $$self.$$set = $$props => {\n    if ('paddingTop' in $$props) $$invalidate(3, paddingTop = $$props.paddingTop);\n    if ('dependencies' in $$props) $$invalidate(4, dependencies = $$props.dependencies);\n  };\n  $$self.$$.update = () => {\n    if ($$self.$$.dirty & /*dependencies, $taskStore, paddingTop, $visibleHeight*/120) {\n      {\n        const result = [];\n        for (let i = 0; i < dependencies.length; i++) {\n          const dependency = dependencies[i];\n          const map = $taskStore.entities;\n          const fromTask = map[dependency.fromId];\n          const toTask = map[dependency.toId];\n          if (fromTask && toTask && Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight && Math.max(fromTask.top, toTask.top) >= paddingTop) {\n            result.push(dependency);\n          }\n        }\n        $$invalidate(0, visibleDependencies = result);\n      }\n    }\n  };\n  return [visibleDependencies, visibleHeight, taskStore, paddingTop, dependencies, $visibleHeight, $taskStore];\n}\nclass GanttDependencies extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {\n      paddingTop: 3,\n      dependencies: 4\n    });\n  }\n}\nconst SvelteGanttDependencies = GanttDependencies;\nconst defaults = {\n  enabled: true,\n  elementContent: () => {\n    const element = document.createElement('div');\n    element.innerHTML = 'New Task';\n    Object.assign(element.style, {\n      position: 'absolute',\n      background: '#eee',\n      padding: '0.5em 1em',\n      fontSize: '12px',\n      pointerEvents: 'none'\n    });\n    return element;\n  }\n};\nclass SvelteGanttExternal {\n  draggable;\n  element;\n  options;\n  constructor(node, options) {\n    this.options = Object.assign({}, defaults, options);\n    this.draggable = new Draggable(node, {\n      onDrag: this.onDrag.bind(this),\n      dragAllowed: () => this.options.enabled,\n      resizeAllowed: false,\n      onDrop: this.onDrop.bind(this),\n      container: document.body,\n      getX: event => event.pageX,\n      getY: event => event.pageY,\n      getWidth: () => 0\n    });\n  }\n  onDrag({\n    x,\n    y\n  }) {\n    if (!this.element) {\n      this.element = this.options.elementContent();\n      document.body.appendChild(this.element);\n      this.options.dragging = true;\n    }\n    this.element.style.top = y + 'px';\n    this.element.style.left = x + 'px';\n  }\n  onDrop(event) {\n    const gantt = this.options.gantt;\n    const targetRow = gantt.dndManager.getTarget('row', event.mouseEvent);\n    if (targetRow) {\n      const mousePos = getRelativePos(gantt.getRowContainer(), event.mouseEvent);\n      const date = gantt.utils.getDateByPosition(mousePos.x);\n      this.options.onsuccess?.(targetRow, date, gantt);\n    } else {\n      this.options.onfail?.();\n    }\n    document.body.removeChild(this.element);\n    this.options.dragging = false;\n    this.element = null;\n  }\n}\n\n/**\n * Date adapter that uses MomentJS\n */\nclass MomentSvelteGanttDateAdapter {\n  moment;\n  constructor(moment) {\n    this.moment = moment;\n  }\n  format(date, format) {\n    return this.moment(date).format(format);\n  }\n  roundTo(date, unit, offset) {\n    const m = this.moment(date);\n    roundMoment(m, offset, unit);\n    return m.valueOf();\n  }\n}\nconst aliases = {\n  hour: 'hours',\n  minute: 'minutes',\n  second: 'seconds',\n  millisecond: 'milliseconds'\n};\n// TODO: write tests for this\nfunction roundMoment(m, precision, key, direction = 'round') {\n  if (precision === 1 && key === 'day') {\n    precision = 24;\n    key = 'hours';\n  }\n  if (aliases[key]) {\n    key = aliases[key];\n  }\n  const methods = {\n    hours: 24,\n    minutes: 60,\n    seconds: 60,\n    milliseconds: 1000\n  };\n  if (!methods[key]) {\n    console.warn(`Rounding dates by ${key} is not supported`);\n  }\n  let value = 0;\n  let rounded = false;\n  let subRatio = 1;\n  let maxValue;\n  for (const k in methods) {\n    if (k === key) {\n      value = m.get(key);\n      maxValue = methods[k];\n      rounded = true;\n    } else if (rounded) {\n      subRatio *= methods[k];\n      value += m.get(k) / subRatio;\n      m.set(k, 0);\n    }\n  }\n  value = Math[direction](value / precision) * precision; // value is date represented in units of `key`, ignoring the bigger units, eg 14h30m->14.5h\n  value = Math.min(value, maxValue);\n  m.set(key, value);\n  return m;\n}\nconst SvelteGantt = Gantt;\nexport { MomentSvelteGanttDateAdapter, SvelteGantt, SvelteGanttDependencies, SvelteGanttExternal, SvelteGanttTable };","map":{"version":3,"names":["noop","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","src_url_equal","element_src","url","document","createElement","href","is_empty","obj","keys","length","subscribe","store","callbacks","callback","undefined","unsub","unsubscribe","get_store_value","value","_","component_subscribe","component","$$","on_destroy","push","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","slice","get_slot_changes","dirty","lets","merged","len","Math","max","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","p","get_all_dirty_from_scope","exclude_internal_props","props","result","compute_rest_props","rest","Set","has","null_to_empty","set_store_value","ret","set","action_destroyer","action_result","destroy","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","element","name","svg_element","createElementNS","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","stop_propagation","stopPropagation","call","attr","attribute","removeAttribute","getAttribute","setAttribute","children","Array","from","childNodes","set_data","set_style","key","important","style","removeProperty","setProperty","crossorigin","is_crossorigin","window","parent","error","add_iframe_resize_listener","computed_style","getComputedStyle","position","iframe","tabIndex","source","contentWindow","onload","toggle_class","toggle","classList","custom_event","type","detail","bubbles","cancelable","CustomEvent","HtmlTag","is_svg","e","n","t","constructor","c","html","h","m","nodeName","nodeType","tagName","content","innerHTML","construct_svelte_component","current_component","set_current_component","get_current_component","Error","onMount","on_mount","onDestroy","createEventDispatcher","defaultPrevented","setContext","context","getContext","get","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","then","flush","tick","add_render_callback","seen_callbacks","flushidx","saved_component","update","pop","add","clear","fragment","before_update","after_update","flush_render_callbacks","filtered","targets","indexOf","outroing","outros","group_outros","r","check_outros","transition_in","block","local","delete","transition_out","o","ensure_array_like","array_like_or_iterator","outro_and_destroy_block","lookup","update_keyed_each","old_blocks","get_key","dynamic","list","create_each_block","next","get_context","old_indexes","new_blocks","new_lookup","Map","deltas","updates","child_ctx","abs","will_move","did_move","first","new_block","old_block","new_key","old_key","get_spread_update","levels","to_null_out","accounted_for","get_spread_object","spread_props","create_component","mount_component","new_on_destroy","map","filter","destroy_component","make_dirty","fill","init","instance","create_fragment","not_equal","append_styles","parent_component","bound","on_disconnect","skip_bound","root","ready","hydrate","nodes","l","intro","SvelteComponent","$$set","$destroy","$on","index","splice","$set","PUBLIC_VERSION","__svelte","v","subscriber_queue","readable","start","writable","stop","subscribers","new_value","run_queue","subscriber","invalidate","size","derived","stores","initial_value","single","isArray","stores_array","every","Boolean","auto","started","values","pending","cleanup","sync","unsubscribers","createEntityStore","ids","entities","_update","item","model","id","state","deleteAll","idSet","upsert","hasIndex","upsertAll","items","addAll","refresh","all","results","createDataStore","taskStore","rowStore","timeRangeStore","allTasks","allRows","allTimeRanges","rowTaskCache","$allTasks","cache","task","resourceId","draggingTaskCache","TaskFactory","columnService","rowPadding","rowEntities","createTask","amountDone","classes","to","label","showButton","buttonClasses","buttonHtml","enableDragging","left","getPositionByDate","right","width","height","getHeight","top","getPosY","reflections","createTasks","tasks","row","y","reflectTask","reflectedId","reflected","reflectedOnParent","reflectedOnChild","originalId","isLeftClick","which","getRelativePos","rect","getBoundingClientRect","x","clientX","clientY","addEventListenerOnce","listener","addOptions","removeOptions","apply","arguments","setCursor","cursor","body","normalizeClassAttr","join","throttle","func","limit","wait","setTimeout","styleInject","css","ref","insertAt","head","getElementsByTagName","firstChild","styleSheet","cssText","div","t_value","raw_value","html_tag","span","span_class_value","labelBottom","create_if_block_5$1","if_block1","create_if_block_4$1","create_if_block_2$1","create_if_block_3$1","if_block3","create_if_block_1$2","if_block4","create_if_block$6","div1","div1_data_task_id_value","stickyLabel","div0","animating","DRAGGING_TO_SCROLL_TRESHOLD","DRAGGING_TO_SCROLL_DELTA","outOfBounds","bottom","$$props","topDelta","_dragging","_resizing","_position","updatePosition","rowContainer","mainContainer","taskContent","resizeHandleWidth","onTaskButtonClick","reflectOnParentRows","reflectOnChildRows","taskElementHook","dndManager","api","utils","selectionManager","selectedTasks","mainContainerRect","scrollIfOutOfBounds","bounds","scrollTo","scrollLeft","behavior","scrollTop","drag","onDrop","rowChangeValid","sourceRow","$rowStore","dragging","targetRow","getTarget","mouseEvent","$$invalidate","raise","switchRow","$taskStore","$draggingTaskCache","prevFrom","prevTo","newFrom","roundTo","getDateByPosition","newTo","newLeft","newRight","$rowPadding","newTask","changed","change","newTasksAndReflections","oldReflections","reflectedTasks","allChildren","opts","reflectedTask","allParents","taskSettings","toString","onDown","resizing","onMouseUp","moveEnd","onResize","onDrag","move","dragAllowed","resizeAllowed","container","getX","getY","getWidth","modelId","taskElement","onClick","resizeEnabled","contentHtml","create_if_block$5","rowHeight","hoveredRow","selectedRow","if_block","create_if_block$4","MIN_DRAG_X","MIN_DRAG_Y","Draggable","mouseStartPosX","mouseStartPosY","mouseStartRight","direction","initialX","initialY","initialW","resizeTriggered","settings","offsetPos","offsetWidth","overRezisedOffset","offsetData","onmousedown","passive","offsetEvent","preventDefault","canDrag","canResize","onmousemove","onmouseup","mousePos","resultX","resultWidth","DragDropManager","handlerMap","register","elements","elementsFromPoint","rowElement","find","rowId","div2","ondrop","draggable","timeranges","clicked","resized","isResizable","resizable","getDuration","unit","offset","addSeconds","date","setSeconds","getSeconds","addMinutes","setMinutes","getMinutes","addHours","setHours","getHours","addDays","setDate","getDate","addWeeks","day","getDay","diff","addMonths","setMonth","getMonth","addYears","setFullYear","getFullYear","getNextDate","units","getAllPeriods","highlightedDurations","tmsWorkOld","interval_duration","Date","dateWork","nextDate","tmsWork","getTime","firstDuration","all_periods","duration","isHighlighted","isUnitFraction","last_day_duration","localDate","timeInUnit","fractions","includes","GanttUtils","magnetOffset","magnetUnit","magnetDuration","dateAdapter","durationTo","durationToEnd","dateAtPosition","getIndicesOnly","input","comparer","strict","lo","hi","mid","floor","res","sticky","t0","t0_value","each_value","columns","dispatch","header","ganttBodyColumns","ganttBodyUnit","onHeaderClick","_header","click_handler","column","format","periods","$from","valueOf","$to","distance_point","period","$width","min","each_blocks","headers","createBackground","canvas","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","lineWidth","columnStrokeWidth","lineCap","strokeStyle","columnStrokeColor","translate","lineAt","dataURL","toDataURL","beginPath","moveTo","lineTo","stroke","bgHighlightColor","create_if_block$3","useCanvasColumns","columnDefaultColor","backgroundImage","dragOptions","resizer","GanttApi","listeners","listenersMap","registerEvent","featureName","eventName","feature","on","eventId","params","removeListener","RowFactory","createRow","expanded","createRows","rows","createChildRows","rowModels","level","parents","rowsAtLevel","rowModel","childLevel","nextLevel","TimeRangeFactory","enableResizing","SelectionManager","currentSelection","selectSingle","taskId","unSelectTasks","toggleSelection","HTMLElement","selections","dispatchSelectionEvent","taskSetting","selId","selectedItem","entries","selectedSetting","dragOrResizeTriggered","selectionDragOrResizing","selectionDropped","findByPosition","findByDate","createDelegatedEventDispatcher","onDelegatedEvent","offDelegatedEvent","onEvent","cbs","match","currentTarget","matches","parentElement","DefaultSvelteGanttDateAdapter","pad","month","String","toLocaleString","charAt","toUpperCase","substring","getWeekNumber","weeknumber","console","warn","getPeriodDuration","round","UTC","setUTCDate","getUTCDate","getUTCDay","yearStart","getUTCFullYear","weekNo","ceil","layout","yPos","intersectsWith","rowContentHeight","sort","_byStartThenByLongestSortFn","_intersects","numYSlots","_getMaxIntersectsWithLength","some","intersect","seen","innerLen","onModuleInit","div9","div8","div7","div6","div4","div3","div5","each_blocks_5","assertSet","toDateNum","module","ganttElement","mainHeaderContainer","scrollables","mounted","timeRanges","_rowHeight","_rowPadding","_from","_to","minWidth","fitWidth","_minWidth","_fitWidth","zoomLevels","tableWidth","setMagnetDuration","columnUnit","columnOffset","ganttTableModules","ganttBodyModules","highlightColor","layout$1","visibleWidth","visibleHeight","headerHeight","_width","visible","stretch","dataStore","getColumnByDate","pair","getColumnByPosition","positionDuration","disableTransition","tickWithoutCSSTransition","offsetHeight","getColumnsV2","cols","$_from","$_to","$_width","ganttContext","contains","ctrlKey","select","$hoveredRow","$selectedRow","dblclicked","__scrollTop","scrollable","onscroll","orientation","horizontalScrollListener","zoomLevel","zooming","onwheel","prevZoomLevel","deltaY","$_minWidth","scale","mousepos","before","after","clientWidth","$_fitWidth","viewChanged","onDateSelected","dateSelected","initRows","rowsData","rowFactory","initTasks","taskData","$_rowPadding","taskFactory","initTimeRanges","timeRangeData","timeRange","timeRangeFactory","refreshTimeRanges","refreshTasks","getRowContainer","selectTask","querySelector","unselectTasks","scrollToRow","scrollBehavior","clientHeight","$allRows","findIndex","targetTop","scrollToTask","targetLeft","rowIndex","updateTask","updateTasks","taskModels","updateRow","updateRows","getRow","getTask","getTasks","$rowTaskCache","filteredRows","rightScrollbarVisible","rowContainerHeight","startIndex","endIndex","paddingTop","paddingBottom","visibleRows","visibleTasks","$$value","$headerHeight","$visibleHeight","$visibleWidth","$_rowHeight","hidden","rendered","j","taskIds","create_if_block_1$1","create_if_block$2","onExpandToggle","iconClass","create_if_block_7","headerHtml","create_if_block_4","renderer","create_if_block_5","create_if_block_6","property","t1_value","imageSrc","img","img_src_value","t1","create_if_block_3","create_if_block_1","create_if_block_2","div_class_value","current","title","hide","show","tableHeaders","headerContainer","scrollListener","onScroll","scrollWidth","onRowExpanded","updateYPositions","onRowCollapsed","$rowHeight","bottomScrollbarVisible","sum","SvelteGanttTable","Table","svg","path0","path1","create_if_block","MIN_LEN","ARROW_SIZE","fromId","toId","strokeWidth","arrowPath","path","fromTask","isFromRowHidden","toTask","isToRowHidden","startY","startX","endY","endX","dependencies","visibleDependencies","dependency","SvelteGanttDependencies","GanttDependencies","defaults","enabled","elementContent","background","padding","fontSize","pointerEvents","SvelteGanttExternal","bind","pageX","pageY","gantt","onsuccess","onfail","MomentSvelteGanttDateAdapter","moment","roundMoment","aliases","hour","minute","second","millisecond","precision","methods","hours","minutes","seconds","milliseconds","rounded","subRatio","maxValue","SvelteGantt","Gantt"],"sources":["C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\utils.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\dom.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\lifecycle.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\scheduler.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\transitions.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\each.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\spread.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\Component.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\shared\\version.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\internal\\disclose-version\\index.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\svelte\\src\\runtime\\store\\index.js","../src/core/store.ts","../src/core/task.ts","../src/utils/dom.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\node_modules\\style-inject\\dist\\style-inject.es.js","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\entities\\Task.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\entities\\Row.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\entities\\TimeRange.svelte","../src/core/constants.ts","../src/core/drag/draggable.ts","../src/core/drag/dragDropManager.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\entities\\TimeRangeHeader.svelte","../src/utils/date.ts","../src/utils/utils.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\column\\ColumnHeaderRow.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\column\\ColumnHeader.svelte","../src/column/canvas.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\column\\Columns.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\ui\\Resizer.svelte","../src/core/api.ts","../src/core/row.ts","../src/core/timeRange.ts","../src/core/selectionManager.ts","../src/core/column.ts","../src/core/events.ts","../src/utils/defaultDateAdapter.ts","../src/core/pack-layout.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\Gantt.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\modules\\table\\TableTreeCell.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\modules\\table\\TableRow.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\modules\\table\\Table.svelte","../src/modules/table/index.ts","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\modules\\dependencies\\Dependency.svelte","C:\\Users\\MOA\\jhk\\reactTest\\client\\node_modules\\src\\modules\\dependencies\\GanttDependencies.svelte","../src/modules/dependencies/index.ts","../src/modules/external/external.ts","../src/utils/momentDateAdapter.ts","../src/index.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tif (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro — restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro — we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro — needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.1';\nexport const PUBLIC_VERSION = '4';\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","","","","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\r\n    import { getContext } from 'svelte';\r\n    import { TaskModel, reflectTask } from '../core/task';\r\n    import { normalizeClassAttr, setCursor, throttle } from '../utils/dom';\r\n    import type { GanttContext, GanttContextOptions, GanttContextServices } from '../gantt';\r\n    import type { GanttDataStore } from '../core/store';\r\n\r\n    export let model: TaskModel;\r\n    export let height: number;\r\n    export let left: number;\r\n    export let top: number;\r\n    export let topDelta: number = 0;\r\n    export let width: number;\r\n    export let reflected = false;\r\n\r\n    let animating = true;\r\n    let _dragging = false;\r\n    let _resizing = false;\r\n\r\n    let _position = {\r\n        x: left,\r\n        y: top + topDelta,\r\n        width: width\r\n    };\r\n\r\n    $: updatePosition(left, top + topDelta, width);\r\n    function updatePosition(x, y, width) {\r\n        if (!_dragging && !_resizing) {\r\n            _position.x = x;\r\n            _position.y = y;\r\n            _position.width = width;\r\n            // should NOT animate on resize/update of columns\r\n        }\r\n    }\r\n\r\n    const { taskStore, rowStore, draggingTaskCache } = getContext('dataStore') as GanttDataStore;\r\n    const { rowContainer, mainContainer }: GanttContext = getContext('gantt');\r\n    const {\r\n        taskContent,\r\n        resizeHandleWidth,\r\n        rowPadding,\r\n        onTaskButtonClick,\r\n        reflectOnParentRows,\r\n        reflectOnChildRows,\r\n        taskElementHook\r\n    }: GanttContextOptions = getContext('options');\r\n    const { dndManager, api, utils, columnService, selectionManager }: GanttContextServices =\r\n        getContext('services');\r\n\r\n    let selectedTasks = selectionManager.selectedTasks;\r\n\r\n    /** How much pixels near the bounds user has to drag to start scrolling */\r\n    const DRAGGING_TO_SCROLL_TRESHOLD = 40;\r\n    /** How much pixels does the view scroll when dragging */\r\n    const DRAGGING_TO_SCROLL_DELTA = 40;\r\n    /** Bounds of the main gantt area, changes only on window resize */\r\n    let mainContainerRect: DOMRect;\r\n    function outOfBounds(event: MouseEvent, rect: DOMRect) {\r\n        return {\r\n            left: event.clientX - rect.left < 0 + DRAGGING_TO_SCROLL_TRESHOLD,\r\n            top: event.clientY - rect.top < 0 + DRAGGING_TO_SCROLL_TRESHOLD,\r\n            right: event.clientX - rect.left > rect.width - DRAGGING_TO_SCROLL_TRESHOLD,\r\n            bottom: event.clientY - rect.top > rect.height - DRAGGING_TO_SCROLL_TRESHOLD\r\n        };\r\n    }\r\n\r\n    const scrollIfOutOfBounds = throttle((event: MouseEvent) => {\r\n        // throttle the following\r\n        const bounds = outOfBounds(event, mainContainerRect);\r\n        if (bounds.left || bounds.right) {\r\n            // scroll left\r\n            mainContainer.scrollTo({\r\n                left:\r\n                    mainContainer.scrollLeft +\r\n                    (bounds.left ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),\r\n                behavior: 'smooth'\r\n            });\r\n        }\r\n\r\n        if (bounds.top || bounds.bottom) {\r\n            // scroll top\r\n            mainContainer.scrollTo({\r\n                top:\r\n                    mainContainer.scrollTop +\r\n                    (bounds.top ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),\r\n                behavior: 'smooth'\r\n            });\r\n        }\r\n    }, 250);\r\n\r\n    function drag(_: HTMLElement) {\r\n        function onDrop(event) {\r\n            let rowChangeValid = true;\r\n            //row switching\r\n            const sourceRow = $rowStore.entities[model.resourceId];\r\n            if (event.dragging) {\r\n                const targetRow = dndManager.getTarget('row', event.mouseEvent);\r\n                if (targetRow) {\r\n                    model.resourceId = targetRow.model.id;\r\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\r\n                } else {\r\n                    rowChangeValid = false;\r\n                }\r\n            }\r\n\r\n            _dragging = _resizing = false;\r\n\r\n            const task = $taskStore.entities[model.id];\r\n            delete $draggingTaskCache[model.id];\r\n\r\n            if (rowChangeValid) {\r\n                const prevFrom = model.from;\r\n                const prevTo = model.to;\r\n                const newFrom = (model.from = utils.roundTo(\r\n                    columnService.getDateByPosition(event.x)\r\n                ));\r\n                const newTo = (model.to = utils.roundTo(\r\n                    columnService.getDateByPosition(event.x + event.width)\r\n                ));\r\n                const newLeft = columnService.getPositionByDate(newFrom) | 0;\r\n                const newRight = columnService.getPositionByDate(newTo) | 0;\r\n\r\n                const targetRow = $rowStore.entities[model.resourceId];\r\n                const left = newLeft;\r\n                const width = newRight - newLeft;\r\n                const top = $rowPadding + targetRow.y;\r\n\r\n                updatePosition(left, top + topDelta, width);\r\n\r\n                const newTask = {\r\n                    ...task,\r\n                    left: left,\r\n                    width: width,\r\n                    top: top,\r\n                    model\r\n                };\r\n\r\n                const changed =\r\n                    prevFrom != newFrom ||\r\n                    prevTo != newTo ||\r\n                    (sourceRow && sourceRow.model.id !== targetRow.model.id);\r\n                if (changed) {\r\n                    api.tasks.raise.change({ task: newTask, sourceRow, targetRow });\r\n                }\r\n                selectionManager.newTasksAndReflections.push(newTask);\r\n\r\n                if (changed) {\r\n                    api.tasks.raise.changed({ task: newTask, sourceRow, targetRow });\r\n                }\r\n\r\n                // update shadow tasks\r\n                if (newTask.reflections) {\r\n                    selectionManager.oldReflections.push(...newTask.reflections);\r\n                }\r\n\r\n                const reflectedTasks = [];\r\n                if (reflectOnChildRows && targetRow.allChildren) {\r\n                    if (!newTask.reflections) newTask.reflections = [];\r\n\r\n                    const opts = { rowPadding: $rowPadding };\r\n                    targetRow.allChildren.forEach(r => {\r\n                        const reflectedTask = reflectTask(newTask, r, opts);\r\n                        newTask.reflections.push(reflectedTask.model.id);\r\n                        reflectedTasks.push(reflectedTask);\r\n                    });\r\n                }\r\n\r\n                if (reflectOnParentRows && targetRow.allParents.length > 0) {\r\n                    if (!newTask.reflections) newTask.reflections = [];\r\n\r\n                    const opts = { rowPadding: $rowPadding };\r\n                    targetRow.allParents.forEach(r => {\r\n                        const reflectedTask = reflectTask(newTask, r, opts);\r\n                        newTask.reflections.push(reflectedTask.model.id);\r\n                        reflectedTasks.push(reflectedTask);\r\n                    });\r\n                }\r\n\r\n                if (reflectedTasks.length > 0) {\r\n                    selectionManager.newTasksAndReflections.push(...reflectedTasks);\r\n                }\r\n\r\n                if (!(targetRow.allParents.length > 0) && !targetRow.allChildren) {\r\n                    newTask.reflections = null;\r\n                }\r\n            } else {\r\n                // reset position\r\n                (_position.x = task.left), (_position.width = task.width), (_position.y = task.top);\r\n            }\r\n        }\r\n\r\n        if (!reflected) {\r\n            // reflected tasks must not be resized or dragged\r\n            selectionManager.taskSettings.set(model.id.toString(), {\r\n                onDown: event => {\r\n                    mainContainerRect = mainContainer.getBoundingClientRect();\r\n                    if (event.dragging) {\r\n                        setCursor('move');\r\n                    }\r\n                    if (event.resizing) {\r\n                        setCursor('e-resize');\r\n                    }\r\n                    $draggingTaskCache[model.id] = true;\r\n                },\r\n                onMouseUp: () => {\r\n                    setCursor('default');\r\n                    api.tasks.raise.moveEnd(model);\r\n                },\r\n                onResize: event => {\r\n                    _position.x = event.x;\r\n                    _position.width = event.width;\r\n                    _resizing = true;\r\n                    scrollIfOutOfBounds(event.event);\r\n                },\r\n                onDrag: event => {\r\n                    _position.x = event.x;\r\n                    _position.y = event.y;\r\n                    _dragging = true;\r\n                    api.tasks.raise.move(model);\r\n                    scrollIfOutOfBounds(event.event);\r\n                },\r\n                dragAllowed: () => {\r\n                    return (\r\n                        $rowStore.entities[model.resourceId].model.enableDragging &&\r\n                        model.enableDragging\r\n                    );\r\n                },\r\n                resizeAllowed: () => {\r\n                    return (\r\n                        model.type !== 'milestone' &&\r\n                        $rowStore.entities[model.resourceId].model.enableDragging &&\r\n                        model.enableDragging\r\n                    );\r\n                },\r\n                onDrop: onDrop,\r\n                container: rowContainer,\r\n                resizeHandleWidth,\r\n                getX: () => _position.x,\r\n                getY: () => _position.y,\r\n                getWidth: () => _position.width,\r\n                modelId: model.id\r\n            });\r\n\r\n            return {\r\n                destroy: () => selectionManager.taskSettings.delete(model.id.toString())\r\n            };\r\n        }\r\n    }\r\n\r\n    function taskElement(node, model) {\r\n        if (taskElementHook) {\r\n            return taskElementHook(node, model);\r\n        }\r\n    }\r\n\r\n    function onClick(event: MouseEvent) {\r\n        if (onTaskButtonClick) {\r\n            onTaskButtonClick(model, event);\r\n        }\r\n    }\r\n\r\n    let classes;\r\n    $: {\r\n        classes = normalizeClassAttr(model.classes);\r\n    }\r\n\r\n    let resizeEnabled: boolean;\r\n    $: {\r\n        resizeEnabled = model.type !== 'milestone' && $rowStore.entities[model.resourceId].model.enableDragging && model.enableDragging;\r\n    }\r\n</script>\r\n\r\n<div\r\n    data-task-id={model.id}\r\n    use:drag\r\n    use:taskElement={model}\r\n    class=\"sg-task {classes}\"\r\n    class:sg-milestone={model.type === 'milestone'}\r\n    style=\"width:{_position.width}px; height:{height}px; left: {_position.x}px; top: {_position.y}px;\"\r\n    class:moving={_dragging || _resizing}\r\n    class:animating\r\n    class:sg-task-reflected={reflected}\r\n    class:sg-task-selected={$selectedTasks[model.id]}\r\n    class:resize-enabled={resizeEnabled}\r\n    class:sg-task--sticky={model.stickyLabel}\r\n>\r\n    {#if model.type === 'milestone'}\r\n        <div class=\"sg-milestone__diamond\"></div>\r\n    {/if}\r\n    {#if model.amountDone}\r\n        <div class=\"sg-task-background\" style=\"width:{model.amountDone}%\" />\r\n    {/if}\r\n    <div class=\"sg-task-content\">\r\n        {#if model.html}\r\n            {@html model.html}\r\n        {:else if taskContent}\r\n            {@html taskContent(model)}\r\n        {:else}\r\n            {model.label}\r\n        {/if}\r\n        <!-- <span class=\"debug\">x:{_position.x} y:{_position.y}, x:{left} y:{top}</span> -->\r\n        {#if model.showButton}\r\n            <!-- svelte-ignore a11y-click-events-have-key-events -->\r\n            <span class=\"sg-task-button {model.buttonClasses}\" on:click={onClick} role=\"button\" tabindex=\"0\">\r\n                {@html model.buttonHtml}\r\n            </span>\r\n        {/if}\r\n    </div>\r\n\r\n    {#if model.labelBottom}\r\n        <!-- svelte-ignore a11y-label-has-associated-control -->\r\n        <label class=\"sg-label-bottom\">{model.labelBottom}</label>\r\n    {/if}\r\n</div>\r\n\r\n<style>\r\n    .sg-label-bottom {\r\n        position: absolute;\r\n        top: calc(100% + 10px);\r\n        color: #888;\r\n    }\r\n\r\n    .debug {\r\n        position: absolute;\r\n        top: -10px;\r\n        right: 0;\r\n        font-size: 8px;\r\n        color: black;\r\n    }\r\n\r\n    .sg-task {\r\n        position: absolute;\r\n        border-radius: 2px;\r\n\r\n        white-space: nowrap;\r\n        /* overflow: hidden; */\r\n        \r\n        transition:\r\n            background-color 0.2s,\r\n            opacity 0.2s;\r\n        pointer-events: all;\r\n    }\r\n\r\n    .sg-task-background {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n    }\r\n\r\n    .sg-task-content {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n\r\n        padding-left: 14px;\r\n        font-size: 14px;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: flex-start;\r\n        user-select: none;\r\n    }\r\n\r\n    .sg-task:not(.moving) {\r\n        transition:\r\n            left 0.2s, top 0.2s,\r\n            transform 0.2s,\r\n            background-color 0.2s,\r\n            width 0.2s, \r\n            height 0.2s;\r\n    }\r\n\r\n    .sg-task--sticky:not(.moving) {\r\n        transition:\r\n            left 0.2s, top 0.2s,\r\n            transform 0.2s,\r\n            background-color 0.2s,\r\n            width 0.2s, \r\n            height 0.2s;\r\n    }\r\n\r\n    .sg-task--sticky > .sg-task-content {\r\n        position: sticky;\r\n        left: 0;\r\n        max-width: 100px;\r\n    }\r\n\r\n    .sg-task.moving {\r\n        z-index: 10000;\r\n        opacity: 0.5;\r\n    }\r\n\r\n    .sg-task.resize-enabled:hover::before {\r\n        content: '';\r\n        width: 4px;\r\n        height: 50%;\r\n        top: 25%;\r\n        position: absolute;\r\n        border-style: solid;\r\n        border-color: rgba(255, 255, 255, 0.5);\r\n        cursor: ew-resize;\r\n        margin-left: 3px;\r\n        left: 0;\r\n        border-width: 0 1px;\r\n        z-index: 1;\r\n    }\r\n\r\n    .sg-task.resize-enabled:hover::after {\r\n        content: '';\r\n        width: 4px;\r\n        height: 50%;\r\n        top: 25%;\r\n        position: absolute;\r\n        border-style: solid;\r\n        border-color: rgba(255, 255, 255, 0.5);\r\n        cursor: ew-resize;\r\n        margin-right: 3px;\r\n        right: 0;\r\n        border-width: 0 1px;\r\n        z-index: 1;\r\n    }\r\n\r\n    .sg-task-reflected {\r\n        opacity: 0.5;\r\n    }\r\n\r\n    .sg-task-background {\r\n        background: rgba(0, 0, 0, 0.2);\r\n    }\r\n\r\n    :global(.sg-task) {\r\n        color: white;\r\n        background: rgb(116, 191, 255);\r\n    }\r\n\r\n    :global(.sg-task:hover) {\r\n        background: rgb(98, 161, 216);\r\n    }\r\n\r\n    :global(.sg-task.selected) {\r\n        background: rgb(69, 112, 150);\r\n    }\r\n\r\n    .sg-milestone {\r\n        /* height: 20px; */\r\n        width: 20px !important;\r\n        min-width: 40px;\r\n        margin-left: -20px;\r\n    }\r\n\r\n    .sg-task.sg-milestone {\r\n        background: transparent;\r\n    }\r\n\r\n    .sg-milestone .sg-milestone__diamond {\r\n        position: relative;\r\n    }\r\n\r\n    .sg-milestone .sg-milestone__diamond:before {\r\n        position: absolute;\r\n        top: 0;\r\n        left: 50%;\r\n        content: ' ';\r\n        height: 28px;\r\n        width: 28px;\r\n        transform-origin: 0 0;\r\n        transform: rotate(45deg);\r\n    }\r\n\r\n    :global(.sg-milestone__diamond:before) {\r\n        background: rgb(116, 191, 255);\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import type { SvelteRow } from '../core/row';\r\n    import { getContext } from 'svelte';\r\n    export let row: SvelteRow;\r\n    const { rowHeight } = getContext('options');\r\n    const { hoveredRow, selectedRow } = getContext('gantt');\r\n</script>\r\n\r\n<div\r\n    class=\"sg-row {row.model.classes}\"\r\n    data-row-id={row.model.id}\r\n    class:sg-hover={$hoveredRow == row.model.id}\r\n    class:sg-selected={$selectedRow == row.model.id}\r\n    style=\"height:{$rowHeight}px\"\r\n>\r\n    {#if row.model.contentHtml}\r\n        {@html row.model.contentHtml}\r\n    {/if}\r\n</div>\r\n\r\n<style>\r\n    .sg-row {\r\n        position: relative;\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import { normalizeClassAttr } from '../utils/dom';\r\n\r\n    export let model;\r\n    export let left;\r\n    export let width;\r\n    export let resizing = false;\r\n\r\n    const _position = {\r\n        width,\r\n        x: left\r\n    };\r\n    $: {\r\n        _position.x = left;\r\n        _position.width = width;\r\n    }\r\n\r\n    let classes;\r\n    $: {\r\n        classes = normalizeClassAttr(model.classes);\r\n    }\r\n</script>\r\n\r\n<div\r\n    class=\"sg-time-range {classes}\"\r\n    class:moving={resizing}\r\n    style=\"width:{_position.width}px;left:{_position.x}px\"\r\n>\r\n    {#if model.label}\r\n        <div class=\"sg-time-range-label\">{model.label}</div>\r\n    {/if}\r\n</div>\r\n\r\n<style>\r\n    .sg-time-range {\r\n        height: 100%;\r\n        position: absolute;\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: center;\r\n\r\n        background-image: linear-gradient(\r\n            -45deg,\r\n            rgba(0, 0, 0, 0) 46%,\r\n            #e03218 49%,\r\n            #e03218 51%,\r\n            rgba(0, 0, 0, 0) 55%\r\n        );\r\n        background-size: 6px 6px !important;\r\n        color: red;\r\n        font-weight: 400;\r\n    }\r\n\r\n    .sg-time-range-label {\r\n        margin-top: 10px;\r\n        background: #fff;\r\n        white-space: nowrap;\r\n        padding: 4px;\r\n        font-weight: 400;\r\n        font-size: 10px;\r\n    }\r\n</style>\r\n","","","","<script lang=\"ts\">\r\n    import { getContext } from 'svelte';\r\n    import type { GanttContext, GanttContextServices, GanttContextOptions } from '../gantt';\r\n    import { Draggable } from '../core/drag';\r\n    import type { GanttDataStore } from '../core/store';\r\n    import { normalizeClassAttr } from '../utils/dom';\r\n\r\n    const { rowContainer }: GanttContext = getContext('gantt');\r\n    const { api, utils, columnService }: GanttContextServices = getContext('services');\r\n    const { resizeHandleWidth }: GanttContextOptions = getContext('options');\r\n    const { timeRangeStore } = getContext('dataStore') as GanttDataStore;\r\n\r\n    export let model;\r\n    export let width;\r\n    export let left;\r\n\r\n    const _position = {\r\n        width,\r\n        x: left\r\n    };\r\n    $: {\r\n        (_position.x = left), (_position.width = width);\r\n    }\r\n\r\n    function drag(node) {\r\n        const ondrop = event => {\r\n            const newFrom = utils.roundTo(columnService.getDateByPosition(event.x));\r\n            const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\r\n            const newLeft = columnService.getPositionByDate(newFrom);\r\n            const newRight = columnService.getPositionByDate(newTo);\r\n\r\n            Object.assign(model, {\r\n                from: newFrom,\r\n                to: newTo\r\n            });\r\n\r\n            update({\r\n                left: newLeft,\r\n                width: newRight - newLeft,\r\n                model,\r\n                resizing: false\r\n            });\r\n\r\n            window.removeEventListener('mousemove', onmousemove, false);\r\n        };\r\n\r\n        function update(state) {\r\n            timeRangeStore.update(state);\r\n            _position.x = state.left;\r\n            _position.width = state.width;\r\n        }\r\n\r\n        const draggable = new Draggable(node, {\r\n            onDown: event => {\r\n                api.timeranges.raise.clicked({ model });\r\n                update({\r\n                    left: event.x,\r\n                    width: event.width,\r\n                    model,\r\n                    resizing: true\r\n                });\r\n            },\r\n            onResize: event => {\r\n                api.timeranges.raise.resized({ model, left: event.x, width: event.width });\r\n                update({\r\n                    left: event.x,\r\n                    width: event.width,\r\n                    model,\r\n                    resizing: true\r\n                });\r\n            },\r\n            dragAllowed: false,\r\n            resizeAllowed: () => isResizable(),\r\n            onDrop: ondrop,\r\n            container: rowContainer,\r\n            resizeHandleWidth,\r\n            getX: () => _position.x,\r\n            getY: () => 0,\r\n            getWidth: () => _position.width\r\n        });\r\n\r\n        return { destroy: () => draggable.destroy() };\r\n    }\r\n\r\n    function isResizable() {\r\n        return model.resizable !== undefined ? model.resizable : true;\r\n    }\r\n\r\n    let classes;\r\n    $: {\r\n        classes = normalizeClassAttr(model.classes);\r\n    }\r\n</script>\r\n\r\n<div\r\n    class=\"sg-time-range-control {classes}\"\r\n    style=\"width:{_position.width}px;left:{_position.x}px\"\r\n    class:sg-time-range-disabled={!isResizable()}\r\n>\r\n    <div class=\"sg-time-range-handle-left\" use:drag></div>\r\n    <div class=\"sg-time-range-handle-right\" use:drag></div>\r\n</div>\r\n\r\n<style>\r\n    .sg-time-range-control {\r\n        position: absolute;\r\n    }\r\n\r\n    .sg-time-range-handle-left {\r\n        position: absolute;\r\n        left: 0;\r\n    }\r\n\r\n    .sg-time-range-handle-right {\r\n        position: absolute;\r\n        right: 0;\r\n    }\r\n\r\n    .sg-time-range-disabled {\r\n        display: none;\r\n    }\r\n\r\n    .sg-time-range-handle-left::before,\r\n    .sg-time-range-handle-right::before {\r\n        position: absolute;\r\n        content: '';\r\n        bottom: 4px;\r\n        border-radius: 6px 6px 6px 0;\r\n        border: 2px solid #b0b0b7;\r\n        width: 9px;\r\n        height: 9px;\r\n        transform: translateX(-50%) rotate(-45deg);\r\n        background-color: #fff;\r\n\r\n        border-color: #e03218;\r\n        cursor: ew-resize;\r\n    }\r\n</style>\r\n","","","<script lang=\"ts\">\r\n    import { createEventDispatcher, getContext } from 'svelte';\r\n    import type { GanttContextDimensions } from '../gantt';\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import type { SvelteGanttDateAdapter } from '../utils/date';\r\n    import { getAllPeriods } from '../utils/date';\r\n    import { getPositionByDate } from '../utils/utils';\r\n\r\n    const { from, to, width }: GanttContextDimensions = getContext('dimensions');\r\n    const { dateAdapter }: { dateAdapter: SvelteGanttDateAdapter } = getContext('options');\r\n\r\n    export let header;\r\n\r\n    export let ganttBodyColumns;\r\n    export let ganttBodyUnit;\r\n\r\n    $: {\r\n        if (header.unit === ganttBodyUnit) {\r\n            header.columns = ganttBodyColumns.map(column => ({\r\n                ...column,\r\n                label: dateAdapter.format(column.from, header.format)\r\n            }));\r\n        } else {\r\n            const periods = getAllPeriods($from.valueOf(), $to.valueOf(), header.unit);\r\n            let distance_point = 0;\r\n            let left = 0;\r\n\r\n            header.columns = periods.map(period => {\r\n                left = distance_point;\r\n                distance_point = getPositionByDate(\r\n                    period.to,\r\n                    $from.valueOf(),\r\n                    $to.valueOf(),\r\n                    $width\r\n                );\r\n                return {\r\n                    width: Math.min(distance_point - left, $width),\r\n                    label: dateAdapter.format(period.from, header.format),\r\n                    from: period.from,\r\n                    to: period.to,\r\n                    left: left\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    function onHeaderClick(_header) {\r\n        dispatch('dateSelected', { from: _header.from, to: _header.to, unit: header.unit });\r\n    }\r\n</script>\r\n\r\n<div class=\"column-header-row\">\r\n    {#each header.columns as _header}\r\n        <!-- svelte-ignore a11y-click-events-have-key-events -->\r\n        <div\r\n            class=\"column-header-cell\"\r\n            role=\"button\"\r\n            tabindex=\"0\"\r\n            class:sticky={header.sticky}\r\n            style=\"left:{_header.left}px;width:{_header.width}px\"\r\n            on:click={() => onHeaderClick(_header)}\r\n        >\r\n            <div class=\"column-header-cell-label\">{_header.label || 'N/A'}</div>\r\n        </div>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .column-header-row {\r\n        position: relative;\r\n\r\n        white-space: nowrap;\r\n        height: 32px;\r\n    }\r\n\r\n    .column-header-cell {\r\n        position: absolute;\r\n\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        text-align: center;\r\n\r\n        display: inline-flex;\r\n\r\n        justify-content: center;\r\n        align-items: center;\r\n\r\n        font-size: 1em;\r\n        font-size: 14px;\r\n        font-weight: 300;\r\n        transition: background 0.2s;\r\n\r\n        cursor: pointer;\r\n        user-select: none;\r\n\r\n        border-right: #efefef 1px solid;\r\n        border-bottom: #efefef 1px solid;\r\n    }\r\n\r\n    .column-header-cell:hover {\r\n        background: #f9f9f9;\r\n    }\r\n\r\n    .column-header-cell.sticky > .column-header-cell-label {\r\n        position: sticky;\r\n        left: 1rem;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import ColumnHeaderRow from './ColumnHeaderRow.svelte';\r\n\r\n    /**\r\n     * Container component for header rows\r\n     */\r\n    export let headers;\r\n    export let ganttBodyColumns;\r\n    export let ganttBodyUnit;\r\n</script>\r\n\r\n{#each headers as header}\r\n    <ColumnHeaderRow {header} {ganttBodyColumns} {ganttBodyUnit} on:dateSelected />\r\n{/each}\r\n","","<script lang=\"ts\">\r\n    import { createBackground } from './canvas';\r\n\r\n    /**\r\n     * Container component for columns rendered as gantt body background\r\n     */\r\n    export let columns;\r\n\r\n    export let useCanvasColumns = true;\r\n    export let columnStrokeWidth;\r\n    export let columnStrokeColor;\r\n    export let columnDefaultColor = '#ffffff';\r\n\r\n    let backgroundImage;\r\n    $: {\r\n        // TODO: background repeats and so do columns so passing every element is not needed, but line alignment issues occur on later rows\r\n        // TODO: I used to make column widths and positions whole numbers, now they contain decimals again, check if this is because of that\r\n        backgroundImage = createBackground(columns, {\r\n            // columns.slice(0,5)\r\n            columnStrokeColor,\r\n            columnStrokeWidth\r\n        });\r\n    }\r\n</script>\r\n\r\n{#if useCanvasColumns}\r\n    <div class=\"sg-columns sg-columns--background\" style:background-image={backgroundImage}></div>\r\n{:else}\r\n    <div class=\"sg-columns\">\r\n        {#each columns as column}\r\n            <div\r\n                class=\"sg-column\"\r\n                style=\"\r\n                border-right: {column.bgHighlightColor\r\n                    ? 0\r\n                    : columnStrokeWidth}px solid {column.bgHighlightColor || columnStrokeColor};\r\n                left: {column.left}px;\r\n                width: {column.width}px;\r\n                background-color: {column.bgHighlightColor || columnDefaultColor};\"\r\n            ></div>\r\n        {/each}\r\n    </div>\r\n{/if}\r\n\r\n<style>\r\n    .sg-columns {\r\n        position: absolute;\r\n        height: 100%;\r\n        width: 100%;\r\n        /* BUG: column borders are not showing correctly when width is very small */\r\n    }\r\n\r\n    .sg-columns--background {\r\n        overflow: hidden;\r\n        background-repeat: repeat;\r\n        background-position-x: -1px;\r\n    }\r\n\r\n    .sg-column {\r\n        position: absolute;\r\n        height: 100%;\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n","<script>\r\n    import { createEventDispatcher } from 'svelte';\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import { Draggable } from '../core/drag';\r\n    import { setCursor } from '../utils/dom';\r\n\r\n    export let x;\r\n    export let container;\r\n\r\n    let dragging = false;\r\n    const dragOptions = {\r\n        onDrag: event => {\r\n            (x = event.x), (dragging = true);\r\n            dispatch('resize', { left: x });\r\n            setCursor('col-resize');\r\n        },\r\n        onDrop: event => {\r\n            (x = event.x), (dragging = false);\r\n            dispatch('resize', { left: x });\r\n            setCursor('default');\r\n        },\r\n        dragAllowed: true,\r\n        resizeAllowed: false,\r\n        container: container,\r\n        getX: () => x,\r\n        getY: () => 0,\r\n        getWidth: () => 0\r\n    };\r\n\r\n    $: dragOptions.container = container;\r\n\r\n    function resizer(node) {\r\n        const draggable = new Draggable(node, dragOptions, 'resizer');\r\n\r\n        return { destroy: () => draggable.destroy() };\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-resize\" style=\"left:{x}px\" use:resizer></div>\r\n\r\n<style>\r\n    .sg-resize {\r\n        z-index: 2;\r\n        background: #e9eaeb;\r\n        width: 5px;\r\n        cursor: col-resize;\r\n        position: absolute;\r\n        height: 100%;\r\n\r\n        transition:\r\n            width 0.2s,\r\n            transform 0.2s;\r\n    }\r\n\r\n    .sg-resize:hover {\r\n        transform: translateX(-2px);\r\n        width: 10px;\r\n    }\r\n</style>\r\n","","","","","","","","","<script lang=\"ts\">\r\n    import { onMount, setContext, tick, onDestroy } from 'svelte';\r\n    import { writable, derived } from 'svelte/store';\r\n\r\n    let ganttElement: HTMLElement;\r\n    let mainHeaderContainer: HTMLElement;\r\n    let mainContainer;\r\n    let rowContainer: HTMLElement;\r\n    let scrollables = [];\r\n    let mounted = false;\r\n\r\n    import { createDataStore } from './core/store';\r\n    import { Task, Row, TimeRange, TimeRangeHeader } from './entities';\r\n    import { Columns, ColumnHeader } from './column';\r\n    import { Resizer } from './ui';\r\n\r\n    import { GanttUtils, getPositionByDate } from './utils/utils';\r\n    import { getRelativePos, isLeftClick } from './utils/dom';\r\n    import { GanttApi } from './core/api';\r\n    import { TaskFactory, reflectTask } from './core/task';\r\n    import type { SvelteTask } from './core/task';\r\n    import { RowFactory } from './core/row';\r\n    import { TimeRangeFactory } from './core/timeRange';\r\n    import { DragDropManager } from './core/drag';\r\n    import { SelectionManager } from './core/selectionManager';\r\n    import { findByPosition, findByDate } from './core/column';\r\n    import type { HighlightedDurations, Column as IColumn } from './core/column';\r\n    import { createDelegatedEventDispatcher } from './core/events';\r\n    import { getDuration, getAllPeriods } from './utils/date';\r\n    import { DefaultSvelteGanttDateAdapter } from './utils/defaultDateAdapter';\r\n    import type { SvelteGanttDateAdapter } from './utils/date';\r\n    import * as packLayout from './core/pack-layout';\r\n\r\n    function assertSet(values) {\r\n        for (const name in values) {\r\n            if (values[name] == null) {\r\n                throw new Error(`\"${name}\" is not set`);\r\n            }\r\n        }\r\n    }\r\n\r\n    export let rows;\r\n    export let tasks = [];\r\n    export let timeRanges = [];\r\n\r\n    assertSet({ rows });\r\n    $: if (mounted) initRows(rows);\r\n    $: if (mounted) initTasks(tasks);\r\n    $: if (mounted) initTimeRanges(timeRanges);\r\n\r\n    export let rowPadding = 6;\r\n    export let rowHeight = 52;\r\n    const _rowHeight = writable(rowHeight);\r\n    const _rowPadding = writable(rowPadding);\r\n    $: $_rowHeight = rowHeight;\r\n    $: $_rowPadding = rowPadding;\r\n\r\n    function toDateNum(date: number | Date) {\r\n        return date instanceof Date ? date.valueOf() : date;\r\n    }\r\n\r\n    export let from;\r\n    export let to;\r\n    assertSet({ from, to });\r\n    const _from = writable(toDateNum(from));\r\n    const _to = writable(toDateNum(to));\r\n    $: $_from = toDateNum(from);\r\n    $: $_to = toDateNum(to);\r\n\r\n    export let minWidth = 800;\r\n    export let fitWidth = false;\r\n    const _minWidth = writable(minWidth);\r\n    const _fitWidth = writable(fitWidth);\r\n    $: {\r\n        $_minWidth = minWidth;\r\n        $_fitWidth = fitWidth;\r\n    }\r\n\r\n    export let classes = [];\r\n    export let headers = [\r\n        { unit: 'day', format: 'MMMM Do' },\r\n        { unit: 'hour', format: 'H:mm' }\r\n    ];\r\n    export let zoomLevels = [\r\n        {\r\n            headers: [\r\n                { unit: 'day', format: 'DD.MM.YYYY' },\r\n                { unit: 'hour', format: 'HH' }\r\n            ],\r\n            minWidth: 800,\r\n            fitWidth: true\r\n        },\r\n        {\r\n            headers: [\r\n                { unit: 'hour', format: 'ddd D/M, H A' },\r\n                { unit: 'minute', format: 'mm', offset: 15 }\r\n            ],\r\n            minWidth: 5000,\r\n            fitWidth: false\r\n        }\r\n    ];\r\n    export let taskContent = null;\r\n    export let tableWidth = 240;\r\n    export let resizeHandleWidth = 10;\r\n    export let onTaskButtonClick = null;\r\n\r\n    export let dateAdapter: SvelteGanttDateAdapter = new DefaultSvelteGanttDateAdapter();\r\n\r\n    export let magnetUnit = 'minute';\r\n    export let magnetOffset = 15;\r\n    let magnetDuration;\r\n    $: setMagnetDuration(magnetUnit, magnetOffset);\r\n    setMagnetDuration(magnetUnit, magnetOffset);\r\n\r\n    function setMagnetDuration(unit, offset) {\r\n        if (unit && offset) {\r\n            magnetDuration = getDuration(unit, offset);\r\n        }\r\n    }\r\n\r\n    export let columnUnit = 'minute';\r\n    export let columnOffset = 15;\r\n\r\n    // export until Svelte3 implements Svelte2's setup(component) hook\r\n    export let ganttTableModules = [];\r\n    export let ganttBodyModules = [];\r\n\r\n    export let reflectOnParentRows = true;\r\n    export let reflectOnChildRows = false;\r\n\r\n    /**\r\n     * Render columns in a canvas, results in a better performance.\r\n     * Set to false if advanced CSS styling is needed.\r\n     **/\r\n    export let useCanvasColumns = true;\r\n    export let columnStrokeColor = '#efefef';\r\n    export let columnStrokeWidth = 1;\r\n\r\n    export let highlightedDurations: HighlightedDurations;\r\n    export let highlightColor = '#6eb859';\r\n\r\n    /** Allows working with the actual DOM node */\r\n    export let taskElementHook = null;\r\n\r\n    /** Controls how the tasks will render */\r\n    export let layout: 'overlap' | 'pack' = 'overlap';\r\n\r\n    const visibleWidth = writable<number>(null);\r\n    const visibleHeight = writable<number>(null);\r\n    const headerHeight = writable<number>(null);\r\n    const _width = derived([visibleWidth, _minWidth, _fitWidth], ([visible, min, stretch]) => {\r\n        return stretch && visible > min ? visible : min;\r\n    });\r\n\r\n    const dataStore = createDataStore();\r\n    setContext('dataStore', dataStore);\r\n    const {\r\n        rowStore,\r\n        taskStore,\r\n        timeRangeStore,\r\n        allTasks,\r\n        allRows,\r\n        allTimeRanges,\r\n        rowTaskCache,\r\n        draggingTaskCache\r\n    } = dataStore;\r\n\r\n    export const columnService = {\r\n        getColumnByDate(date: number) {\r\n            const pair = findByDate(columns, date);\r\n            return !pair[0] ? pair[1] : pair[0];\r\n        },\r\n        getColumnByPosition(x: number) {\r\n            const pair = findByPosition(columns, x);\r\n            return !pair[0] ? pair[1] : pair[0];\r\n        },\r\n        getPositionByDate(date: number) {\r\n            if (!date) return null;\r\n            const column = this.getColumnByDate(date);\r\n\r\n            let durationTo = date - column.from;\r\n            const position = (durationTo / column.duration) * column.width;\r\n\r\n            //multiples - skip every nth col, use other duration\r\n            return column.left + position;\r\n        },\r\n        getDateByPosition(x: number) {\r\n            const column = this.getColumnByPosition(x);\r\n            x = x - column.left;\r\n\r\n            let positionDuration = (column.duration / column.width) * x;\r\n            const date = column.from + positionDuration;\r\n\r\n            return date;\r\n        },\r\n        /**\r\n         * TODO: remove, currently unused\r\n         * @param {number} date - Date\r\n         * @returns {number} rounded date passed as parameter\r\n         */\r\n        roundTo(date: number) {\r\n            let value = Math.round(date / magnetDuration) * magnetDuration;\r\n            return value;\r\n        }\r\n    };\r\n\r\n    let disableTransition = false;\r\n\r\n    async function tickWithoutCSSTransition() {\r\n        disableTransition = true;\r\n        await tick();\r\n        ganttElement.offsetHeight; // force a reflow\r\n        disableTransition = false;\r\n    }\r\n\r\n    let columns: IColumn[];\r\n    $: {\r\n        columns = getColumnsV2($_from, $_to, columnUnit, columnOffset, $_width);\r\n        tickWithoutCSSTransition();\r\n        refreshTimeRanges();\r\n        refreshTasks();\r\n    }\r\n\r\n    function getColumnsV2(\r\n        from: number | Date,\r\n        to: number | Date,\r\n        unit: string,\r\n        offset: number,\r\n        width: number\r\n    ): IColumn[] {\r\n        //BUG: Function is running twice on init, how to prevent it?\r\n\r\n        if (from instanceof Date) from = from.valueOf();\r\n        if (to instanceof Date) to = to.valueOf();\r\n\r\n        let cols = [];\r\n        const periods = getAllPeriods(\r\n            from.valueOf(),\r\n            to.valueOf(),\r\n            unit,\r\n            offset,\r\n            highlightedDurations\r\n        );\r\n        let left = 0;\r\n        let distance_point = 0;\r\n        periods.forEach(function (period) {\r\n            left = distance_point;\r\n            distance_point = getPositionByDate(period.to, $_from, $_to, $_width);\r\n            cols.push({\r\n                width: distance_point - left,\r\n                from: period.from,\r\n                to: period.to,\r\n                left: left,\r\n                duration: period.duration,\r\n                ...(period.isHighlighted && { bgHighlightColor: highlightColor })\r\n            });\r\n        });\r\n        return cols;\r\n    }\r\n\r\n    setContext('dimensions', {\r\n        from: _from,\r\n        to: _to,\r\n        width: _width,\r\n        visibleWidth,\r\n        visibleHeight,\r\n        headerHeight\r\n    });\r\n\r\n    setContext('options', {\r\n        dateAdapter,\r\n        taskElementHook,\r\n        taskContent,\r\n        rowPadding: _rowPadding,\r\n        rowHeight: _rowHeight,\r\n        resizeHandleWidth: resizeHandleWidth,\r\n        reflectOnParentRows,\r\n        reflectOnChildRows,\r\n        onTaskButtonClick\r\n    });\r\n\r\n    const hoveredRow = writable<number | string>(null);\r\n    const selectedRow = writable<number | string>(null);\r\n\r\n    const ganttContext = {\r\n        scrollables,\r\n        hoveredRow,\r\n        selectedRow\r\n    };\r\n    setContext('gantt', ganttContext);\r\n\r\n    onMount(() => {\r\n        Object.assign(ganttContext, {\r\n            rowContainer,\r\n            mainContainer,\r\n            mainHeaderContainer\r\n        });\r\n\r\n        api.registerEvent('tasks', 'move');\r\n        api.registerEvent('tasks', 'select');\r\n        api.registerEvent('tasks', 'switchRow');\r\n        api.registerEvent('tasks', 'moveEnd');\r\n        api.registerEvent('tasks', 'change');\r\n        api.registerEvent('tasks', 'changed');\r\n        api.registerEvent('gantt', 'viewChanged');\r\n        api.registerEvent('gantt', 'dateSelected');\r\n        api.registerEvent('tasks', 'dblclicked');\r\n        api.registerEvent('timeranges', 'clicked');\r\n        api.registerEvent('timeranges', 'resized');\r\n\r\n        mounted = true;\r\n    });\r\n\r\n    const { onDelegatedEvent, offDelegatedEvent, onEvent } = createDelegatedEventDispatcher();\r\n\r\n    onDelegatedEvent('mousedown', 'data-task-id', (event, data, target) => {\r\n        const taskId = data;\r\n        if (isLeftClick(event) && !target.classList.contains('sg-task-reflected')) {\r\n            if (event.ctrlKey) {\r\n                selectionManager.toggleSelection(taskId, target);\r\n            } else {\r\n                selectionManager.selectSingle(taskId, target);\r\n            }\r\n            selectionManager.dispatchSelectionEvent(taskId, event);\r\n        }\r\n        api['tasks'].raise.select($taskStore.entities[taskId]);\r\n    });\r\n\r\n    onDelegatedEvent('mouseover', 'data-row-id', (event, data, target) => {\r\n        $hoveredRow = data;\r\n    });\r\n\r\n    onDelegatedEvent('click', 'data-row-id', (event, data, target) => {\r\n        selectionManager.unSelectTasks();\r\n        if ($selectedRow == data) {\r\n            $selectedRow = null;\r\n            return;\r\n        }\r\n        $selectedRow = data;\r\n    });\r\n\r\n    onDelegatedEvent('dblclick', 'data-task-id', (event, data, target) => {\r\n        const taskId = data;\r\n        api['tasks'].raise.dblclicked($taskStore.entities[taskId], event);\r\n    });\r\n\r\n    onDelegatedEvent('mouseleave', 'empty', (event, data, target) => {\r\n        $hoveredRow = null;\r\n    });\r\n\r\n    onDestroy(() => {\r\n        offDelegatedEvent('click', 'data-task-id');\r\n        offDelegatedEvent('click', 'data-row-id');\r\n        offDelegatedEvent('mousedown', 'data-task-id');\r\n        offDelegatedEvent('dblclick', 'data-task-id');\r\n\r\n        selectionManager.unSelectTasks();\r\n    });\r\n\r\n    let __scrollTop = 0;\r\n    let __scrollLeft = 0;\r\n    function scrollable(node) {\r\n        const onscroll = event => {\r\n            const { scrollTop, scrollLeft } = node;\r\n\r\n            scrollables.forEach(scrollable => {\r\n                if (scrollable.orientation === 'horizontal') {\r\n                    scrollable.node.scrollLeft = scrollLeft;\r\n                } else {\r\n                    scrollable.node.scrollTop = scrollTop;\r\n                }\r\n            });\r\n\r\n            __scrollTop = scrollTop;\r\n            __scrollLeft = scrollLeft;\r\n        };\r\n\r\n        node.addEventListener('scroll', onscroll);\r\n        return {\r\n            destroy() {\r\n                node.removeEventListener('scroll', onscroll, false);\r\n            }\r\n        };\r\n    }\r\n\r\n    function horizontalScrollListener(node) {\r\n        scrollables.push({ node, orientation: 'horizontal' });\r\n    }\r\n\r\n    function onResize(event) {\r\n        tableWidth = event.detail.left;\r\n    }\r\n\r\n    let zoomLevel = 0;\r\n    let zooming = false;\r\n    async function onwheel(event: WheelEvent) {\r\n        if (event.ctrlKey) {\r\n            event.preventDefault();\r\n\r\n            const prevZoomLevel = zoomLevel;\r\n            if (event.deltaY > 0) {\r\n                zoomLevel = Math.max(zoomLevel - 1, 0);\r\n            } else {\r\n                zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1);\r\n            }\r\n\r\n            if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {\r\n                const options = {\r\n                    columnUnit: columnUnit,\r\n                    columnOffset: columnOffset,\r\n                    minWidth: $_minWidth,\r\n                    ...zoomLevels[zoomLevel]\r\n                };\r\n\r\n                const scale = options.minWidth / $_width;\r\n                const node = mainContainer;\r\n                const mousepos = getRelativePos(node, event);\r\n                const before = node.scrollLeft + mousepos.x;\r\n                const after = before * scale;\r\n                const scrollLeft = after - mousepos.x + node.clientWidth / 2;\r\n\r\n                columnUnit = options.columnUnit;\r\n                columnOffset = options.columnOffset;\r\n                $_minWidth = options.minWidth;\r\n\r\n                if (options.headers) headers = options.headers;\r\n\r\n                if (options.fitWidth) $_fitWidth = options.fitWidth;\r\n\r\n                api['gantt'].raise.viewChanged();\r\n                zooming = true;\r\n                await tick();\r\n                node.scrollLeft = scrollLeft;\r\n                zooming = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDateSelected(event) {\r\n        $_from = event.detail.from;\r\n        $_to = event.detail.to;\r\n        api['gantt'].raise.dateSelected({ from: $_from, to: $_to });\r\n    }\r\n\r\n    function initRows(rowsData) {\r\n        //Bug: Running twice on change options\r\n        const rows = rowFactory.createRows(rowsData);\r\n        rowStore.addAll(rows);\r\n    }\r\n\r\n    async function initTasks(taskData) {\r\n        await tick();\r\n\r\n        const tasks = [];\r\n        const opts = { rowPadding: $_rowPadding };\r\n        taskData.forEach(t => {\r\n            const task = taskFactory.createTask(t);\r\n            const row = $rowStore.entities[task.model.resourceId];\r\n            task.reflections = [];\r\n\r\n            if (reflectOnChildRows && row.allChildren) {\r\n                row.allChildren.forEach(r => {\r\n                    const reflectedTask = reflectTask(task, r, opts);\r\n                    task.reflections.push(reflectedTask.model.id);\r\n                    tasks.push(reflectedTask);\r\n                });\r\n            }\r\n\r\n            if (reflectOnParentRows && row.allParents.length > 0) {\r\n                row.allParents.forEach(r => {\r\n                    const reflectedTask = reflectTask(task, r, opts);\r\n                    task.reflections.push(reflectedTask.model.id);\r\n                    tasks.push(reflectedTask);\r\n                });\r\n            }\r\n\r\n            tasks.push(task);\r\n        });\r\n        taskStore.addAll(tasks);\r\n    }\r\n\r\n    function initTimeRanges(timeRangeData) {\r\n        const timeRanges = timeRangeData.map(timeRange => {\r\n            return timeRangeFactory.create(timeRange);\r\n        });\r\n        timeRangeStore.addAll(timeRanges);\r\n    }\r\n\r\n    function onModuleInit(module) {}\r\n\r\n    export const api = new GanttApi();\r\n    const selectionManager = new SelectionManager(taskStore);\r\n\r\n    export const taskFactory = new TaskFactory(columnService);\r\n    $: {\r\n        taskFactory.rowPadding = $_rowPadding;\r\n        taskFactory.rowEntities = $rowStore.entities;\r\n    }\r\n\r\n    export const rowFactory = new RowFactory();\r\n    $: rowFactory.rowHeight = rowHeight;\r\n\r\n    export const dndManager = new DragDropManager(rowStore);\r\n    export const timeRangeFactory = new TimeRangeFactory(columnService);\r\n\r\n    export const utils = new GanttUtils();\r\n    $: {\r\n        utils.from = $_from;\r\n        utils.to = $_to;\r\n        utils.width = $_width;\r\n        utils.magnetOffset = magnetOffset;\r\n        utils.magnetUnit = magnetUnit;\r\n        utils.magnetDuration = magnetDuration;\r\n        utils.dateAdapter = dateAdapter;\r\n        //utils.to = columns[columns.length - 1].to;\r\n        //utils.width = columns.length * columns[columns.length - 1].width;\r\n    }\r\n\r\n    setContext('services', {\r\n        utils,\r\n        api,\r\n        dndManager,\r\n        selectionManager,\r\n        columnService\r\n    });\r\n\r\n    export function refreshTimeRanges() {\r\n        timeRangeStore._update(({ ids, entities }) => {\r\n            ids.forEach(id => {\r\n                const timeRange = entities[id];\r\n                const newLeft = columnService.getPositionByDate(timeRange.model.from) | 0;\r\n                const newRight = columnService.getPositionByDate(timeRange.model.to) | 0;\r\n\r\n                timeRange.left = newLeft;\r\n                timeRange.width = newRight - newLeft;\r\n            });\r\n            return { ids, entities };\r\n        });\r\n    }\r\n\r\n    export function refreshTasks() {\r\n        $allTasks.forEach(task => {\r\n            const newLeft = columnService.getPositionByDate(task.model.from) | 0;\r\n            const newRight = columnService.getPositionByDate(task.model.to) | 0;\r\n\r\n            task.left = newLeft;\r\n            task.width = newRight - newLeft;\r\n        });\r\n        taskStore.refresh();\r\n    }\r\n\r\n    export function getRowContainer() {\r\n        return rowContainer;\r\n    }\r\n\r\n    export function selectTask(id) {\r\n        const task = $taskStore.entities[id];\r\n        if (task) {\r\n            selectionManager.selectSingle(id, ganttElement.querySelector(`data-task-id='${id}'`)); // TODO:: fix\r\n        }\r\n    }\r\n\r\n    export function unselectTasks() {\r\n        selectionManager.unSelectTasks();\r\n    }\r\n\r\n    export function scrollToRow(id, scrollBehavior = 'auto') {\r\n        const { scrollTop, clientHeight } = mainContainer;\r\n\r\n        const index = $allRows.findIndex(r => r.model.id == id);\r\n        if (index === -1) return;\r\n        const targetTop = index * rowHeight;\r\n\r\n        if (targetTop < scrollTop) {\r\n            mainContainer.scrollTo({\r\n                top: targetTop,\r\n                behavior: scrollBehavior\r\n            });\r\n        }\r\n\r\n        if (targetTop > scrollTop + clientHeight) {\r\n            mainContainer.scrollTo({\r\n                top: targetTop + rowHeight - clientHeight,\r\n                behavior: scrollBehavior\r\n            });\r\n        }\r\n    }\r\n\r\n    export function scrollToTask(id, scrollBehavior = 'auto') {\r\n        const { scrollLeft, scrollTop, clientWidth, clientHeight } = mainContainer;\r\n\r\n        const task = $taskStore.entities[id];\r\n        if (!task) return;\r\n        const targetLeft = task.left;\r\n        const rowIndex = $allRows.findIndex(r => r.model.id == task.model.resourceId);\r\n        const targetTop = rowIndex * rowHeight;\r\n\r\n        const options = {\r\n            top: undefined,\r\n            left: undefined,\r\n            behavior: scrollBehavior\r\n        };\r\n\r\n        if (targetLeft < scrollLeft) {\r\n            options.left = targetLeft;\r\n        }\r\n\r\n        if (targetLeft > scrollLeft + clientWidth) {\r\n            options.left = targetLeft + task.width - clientWidth;\r\n        }\r\n\r\n        if (targetTop < scrollTop) {\r\n            options.top = targetTop;\r\n        }\r\n\r\n        if (targetTop > scrollTop + clientHeight) {\r\n            options.top = targetTop + rowHeight - clientHeight;\r\n        }\r\n\r\n        mainContainer.scrollTo(options);\r\n    }\r\n\r\n    export function updateTask(model) {\r\n        const task = taskFactory.createTask(model);\r\n        taskStore.upsert(task);\r\n    }\r\n\r\n    export function updateTasks(taskModels) {\r\n        const tasks = taskModels.map(model => taskFactory.createTask(model));\r\n        taskStore.upsertAll(tasks);\r\n    }\r\n\r\n    export function updateRow(model) {\r\n        const row = rowFactory.createRow(model, null);\r\n        rowStore.upsert(row);\r\n    }\r\n\r\n    export function updateRows(rowModels) {\r\n        const rows = rowModels.map(model => rowFactory.createRow(model, null));\r\n        rowStore.upsertAll(rows);\r\n    }\r\n\r\n    export function getRow(resourceId) {\r\n        return $rowStore.entities[resourceId];\r\n    }\r\n\r\n    export function getTask(id) {\r\n        return $taskStore.entities[id];\r\n    }\r\n\r\n    export function getTasks(resourceId) {\r\n        if ($rowTaskCache[resourceId]) {\r\n            return $rowTaskCache[resourceId].map(id => $taskStore.entities[id]);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    let filteredRows = [];\r\n    $: filteredRows = $allRows.filter(row => !row.hidden);\r\n    \r\n    let rightScrollbarVisible: boolean;\r\n    $: rightScrollbarVisible = rowContainerHeight > $visibleHeight;\r\n\r\n    let rowContainerHeight;\r\n    $: rowContainerHeight = filteredRows.length * rowHeight;\r\n\r\n    let startIndex;\r\n    $: startIndex = Math.floor(__scrollTop / rowHeight);\r\n\r\n    let endIndex;\r\n    $: endIndex = Math.min(\r\n        startIndex + Math.ceil($visibleHeight / rowHeight),\r\n        filteredRows.length - 1\r\n    );\r\n\r\n    let paddingTop = 0;\r\n    $: paddingTop = startIndex * rowHeight;\r\n\r\n    let paddingBottom = 0;\r\n    $: paddingBottom = (filteredRows.length - endIndex - 1) * rowHeight;\r\n\r\n    let visibleRows = [];\r\n    $: visibleRows = filteredRows.slice(startIndex, endIndex + 1);\r\n\r\n    let visibleTasks: SvelteTask[];\r\n    $: {\r\n        const tasks = [];\r\n        const rendered: { [id: string]: boolean } = {};\r\n        for (let i = 0; i < visibleRows.length; i++) {\r\n            const row = visibleRows[i];\r\n            if ($rowTaskCache[row.model.id]) {\r\n                for (let j = 0; j < $rowTaskCache[row.model.id].length; j++) {\r\n                    const id = $rowTaskCache[row.model.id][j];\r\n                    tasks.push($taskStore.entities[id]);\r\n                    rendered[id] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // render all tasks being dragged if not already\r\n        for (const id in $draggingTaskCache) {\r\n            if (!rendered[id]) {\r\n                tasks.push($taskStore.entities[id]);\r\n                rendered[id] = true;\r\n            }\r\n        }\r\n\r\n        visibleTasks = tasks;\r\n    }\r\n\r\n    $: {\r\n        if (layout === 'pack') {\r\n            for (const rowId of $rowStore.ids) {\r\n                // const row = $rowStore.entities[rowId];\r\n                const taskIds = $rowTaskCache[rowId];\r\n                if (taskIds) {\r\n                    const tasks = taskIds.map(taskId => $taskStore.entities[taskId]);\r\n                    packLayout.layout(tasks, { \r\n                        rowContentHeight: rowHeight - rowPadding * 2\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<!-- svelte-ignore a11y-click-events-have-key-events -->\r\n<!-- svelte-ignore a11y-mouse-events-have-key-events -->\r\n<div\r\n    class=\"sg-gantt {classes}\"\r\n    class:sg-disable-transition={disableTransition}\r\n    bind:this={ganttElement}\r\n    on:mousedown|stopPropagation={onEvent}\r\n    on:click|stopPropagation={onEvent}\r\n    on:dblclick={onEvent}\r\n    on:mouseover={onEvent}\r\n    on:mouseleave={onEvent}\r\n>\r\n    {#each ganttTableModules as module}\r\n        <svelte:component\r\n            this={module}\r\n            {rowContainerHeight}\r\n            {paddingTop}\r\n            {paddingBottom}\r\n            {tableWidth}\r\n            {...$$restProps}\r\n            on:init={onModuleInit}\r\n            {visibleRows}\r\n        />\r\n\r\n        <Resizer x={tableWidth} on:resize={onResize} container={ganttElement}></Resizer>\r\n    {/each}\r\n\r\n    <div class=\"sg-timeline sg-view\">\r\n        <div class=\"sg-header\" bind:this={mainHeaderContainer} bind:clientHeight={$headerHeight} class:right-scrollbar-visible=\"{rightScrollbarVisible}\">\r\n            <div class=\"sg-header-scroller\" use:horizontalScrollListener>\r\n                <div class=\"header-container\" style=\"width:{$_width}px\">\r\n                    <ColumnHeader\r\n                        {headers}\r\n                        ganttBodyColumns={columns}\r\n                        ganttBodyUnit={columnUnit}\r\n                        on:dateSelected={onDateSelected}\r\n                    />\r\n                    {#each $allTimeRanges as timeRange (timeRange.model.id)}\r\n                        <TimeRangeHeader {...timeRange} />\r\n                    {/each}\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div\r\n            class=\"sg-timeline-body\"\r\n            bind:this={mainContainer}\r\n            use:scrollable\r\n            class:zooming\r\n            on:wheel={onwheel}\r\n            bind:clientHeight={$visibleHeight}\r\n            bind:clientWidth={$visibleWidth}\r\n        >\r\n            <div class=\"content\" style=\"width:{$_width}px\">\r\n                <Columns {columns} {columnStrokeColor} {columnStrokeWidth} {useCanvasColumns} />\r\n\r\n                <div\r\n                    class=\"sg-rows\"\r\n                    bind:this={rowContainer}\r\n                    style=\"height:{rowContainerHeight}px;\"\r\n                >\r\n                    <div style=\"transform: translateY({paddingTop}px);\">\r\n                        {#each visibleRows as row (row.model.id)}\r\n                            <Row {row} />\r\n                        {/each}\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"sg-foreground\">\r\n                    {#each $allTimeRanges as timeRange (timeRange.model.id)}\r\n                        <TimeRange {...timeRange} />\r\n                    {/each}\r\n\r\n                    {#each visibleTasks as task (task.model.id)}\r\n                        <Task\r\n                            model={task.model}\r\n                            left={task.left}\r\n                            width={task.width}\r\n                            height={task.height}\r\n                            top={task.top}\r\n                            {...task}\r\n                        />\r\n                    {/each}\r\n                </div>\r\n                {#each ganttBodyModules as module}\r\n                    <svelte:component\r\n                        this={module}\r\n                        {paddingTop}\r\n                        {paddingBottom}\r\n                        {visibleRows}\r\n                        {...$$restProps}\r\n                        on:init={onModuleInit}\r\n                    />\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .sg-disable-transition :global(.sg-task),\r\n    .sg-disable-transition :global(.sg-milestone) {\r\n        transition:\r\n            transform 0s,\r\n            background-color 0.2s,\r\n            width 0s !important;\r\n    }\r\n\r\n    :global(.sg-view:not(:first-child)) {\r\n        margin-left: 5px;\r\n    }\r\n\r\n    /* This class should take into account varying widths of the scroll bar */\r\n    :global(.right-scrollbar-visible) { \r\n        /* set this value to your scrollbar width */\r\n        padding-right: 17px;\r\n    } \r\n\r\n    .sg-timeline {\r\n        flex: 1 1 0%;\r\n        display: flex;\r\n        flex-direction: column;\r\n        overflow-x: auto;\r\n    }\r\n\r\n    .sg-gantt {\r\n        display: flex;\r\n\r\n        width: 100%;\r\n        height: 100%;\r\n        position: relative;\r\n    }\r\n\r\n    .sg-foreground {\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n        top: 0;\r\n        left: 0;\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        z-index: 1;\r\n        pointer-events: none;\r\n    }\r\n\r\n    .sg-rows {\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .sg-timeline-body {\r\n        overflow: auto;\r\n        flex: 1 1 auto;\r\n    }\r\n\r\n    .sg-header-scroller {\r\n        border-right: 1px solid #efefef;\r\n        overflow: hidden;\r\n        position: relative;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n\r\n    :global(*) {\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import type { SvelteRow } from '../../core/row';\r\n\r\n    import { createEventDispatcher } from 'svelte';\r\n\r\n    export let row: SvelteRow;\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    function onExpandToggle() {\r\n        if (row.expanded) {\r\n            dispatch('rowCollapsed', { row });\r\n        } else {\r\n            dispatch('rowExpanded', { row });\r\n        }\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-cell-inner\" style=\"padding-left: {row.childLevel * 3}em\">\r\n    {#if row.children}\r\n        <div class=\"sg-tree-expander\" on:click={onExpandToggle}>\r\n            {#if row.expanded}\r\n                <i class=\"fas fa-angle-down\"></i>\r\n            {:else}\r\n                <i class=\"fas fa-angle-right\"></i>\r\n            {/if}\r\n        </div>\r\n    {/if}\r\n    <slot />\r\n</div>\r\n\r\n<style>\r\n    .sg-tree-expander {\r\n        cursor: pointer;\r\n        min-width: 1.4em;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n\r\n    .sg-cell-inner {\r\n        display: flex;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import { createEventDispatcher, getContext, onMount } from 'svelte';\r\n\r\n    import TableTreeCell from './TableTreeCell.svelte';\r\n    import type { TableHeader } from './tableHeader';\r\n    import type { SvelteRow } from '../../core/row';\r\n\r\n    export let headers: TableHeader[] = null;\r\n    export let row: SvelteRow = null;\r\n\r\n    const { rowHeight } = getContext('options');\r\n    const { hoveredRow, selectedRow } = getContext('gantt');\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    let treeIndentationStyle = '';\r\n    $: {\r\n        treeIndentationStyle = row.parent ? `padding-left: ${row.childLevel * 3}em;` : '';\r\n    }\r\n\r\n    onMount(() => {\r\n        if (row.model.expanded == false) dispatch('rowCollapsed', { row });\r\n    });\r\n</script>\r\n\r\n<div\r\n    data-row-id={row.model.id}\r\n    style=\"height:{$rowHeight}px\"\r\n    class=\"sg-table-row {row.model.classes || ''}\"\r\n    class:sg-row-expanded={row.expanded}\r\n    class:sg-hover={$hoveredRow == row.model.id}\r\n    class:sg-selected={$selectedRow == row.model.id}\r\n>\r\n    {#each headers as header}\r\n        <div class=\"sg-table-body-cell sg-table-cell\" style=\"width:{header.width}px\">\r\n            {#if header.type == 'tree'}\r\n                <TableTreeCell on:rowCollapsed on:rowExpanded {row}>\r\n                    {#if row.model.iconClass}\r\n                        <div class=\"sg-table-icon\">\r\n                            <i class={row.model.iconClass}></i>\r\n                        </div>\r\n                    {/if}\r\n\r\n                    {#if row.model.headerHtml}\r\n                        {@html row.model.headerHtml}\r\n                    {:else if header.renderer}\r\n                        {@html header.renderer(row)}\r\n                    {:else}\r\n                        {row.model[header.property]}\r\n                    {/if}\r\n                </TableTreeCell>\r\n            {:else}\r\n                {#if row.model.iconClass}\r\n                    <div class=\"sg-table-icon\">\r\n                        <i class={row.model.iconClass}></i>\r\n                    </div>\r\n                {/if}\r\n\r\n                {#if row.model.headerHtml}\r\n                    {@html row.model.headerHtml}\r\n                {:else if header.renderer}\r\n                    {@html header.renderer(row)}\r\n                {:else if header.type === 'resourceInfo'}\r\n                    <img class=\"sg-resource-image\" src={row.model.imageSrc} alt=\"\" />\r\n                    <div class=\"sg-resource-title\">\r\n                        {row.model[header.property]}\r\n                    </div>\r\n                {:else}\r\n                    {row.model[header.property]}\r\n                {/if}\r\n            {/if}\r\n        </div>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .sg-table-row {\r\n        display: inline-flex;\r\n        min-width: 100%;\r\n        align-items: stretch;\r\n\r\n        position: relative;\r\n\r\n        font-weight: 400;\r\n        font-size: 14px;\r\n    }\r\n\r\n    .sg-table-cell {\r\n        border-left: 1px solid #eee;\r\n    }\r\n\r\n    .sg-table-body-cell {\r\n        border-bottom: #efefef 1px solid;\r\n        background-color: #fff;\r\n        font-weight: bold;\r\n    }\r\n\r\n    .sg-resource-image {\r\n        width: 2.4em;\r\n        height: 2.4em;\r\n        border-radius: 50%;\r\n        margin-right: 0.6em;\r\n\r\n        background: #047c69;\r\n    }\r\n\r\n    .sg-resource-info {\r\n        flex: 1;\r\n        height: 100%;\r\n        display: flex;\r\n        flex-direction: row;\r\n        align-items: center;\r\n    }\r\n\r\n    .sg-table-icon {\r\n        margin-right: 0.5em;\r\n    }\r\n</style>\r\n","<script context=\"module\">\r\n    export const type = 'table';\r\n</script>\r\n\r\n<script lang=\"ts\">\r\n    import { createEventDispatcher, onMount, getContext } from 'svelte';\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import TableRow from './TableRow.svelte';\r\n    import type { GanttDataStore } from '../../core/store';\r\n    import type { TableHeader } from './tableHeader';\r\n    import type { SvelteRow } from '../../core/row';\r\n\r\n    export let tableWidth;\r\n    export let paddingTop;\r\n    export let paddingBottom;\r\n    export let rowContainerHeight;\r\n    export let visibleRows: SvelteRow[];\r\n    // list of columns used in the table\r\n    // title: label to display in the header\r\n    // property: property of row to display in the cell\r\n    // width: width of column\r\n    export let tableHeaders: TableHeader[] = [{ title: 'Name', property: 'label', width: 100 }];\r\n\r\n    const { from, to, width, visibleWidth, headerHeight } = getContext('dimensions');\r\n    const { rowPadding, rowHeight } = getContext('options');\r\n    const { rowStore, taskStore } = getContext('dataStore') as GanttDataStore;\r\n    const { scrollables } = getContext('gantt');\r\n\r\n    onMount(() => {\r\n        dispatch('init', { module: this });\r\n    });\r\n\r\n    let headerContainer;\r\n    function scrollListener(node) {\r\n        scrollables.push({ node, orientation: 'vertical' });\r\n\r\n        function onScroll(event) {\r\n            headerContainer.scrollLeft = node.scrollLeft;\r\n        }\r\n\r\n        node.addEventListener('scroll', onScroll);\r\n\r\n        return {\r\n            destroy() {\r\n                node.removeEventListener('scroll', onScroll);\r\n            }\r\n        };\r\n    }\r\n\r\n    let scrollWidth;\r\n    $: {\r\n        let sum = 0;\r\n        tableHeaders.forEach(header => {\r\n            sum += header.width;\r\n        });\r\n        scrollWidth = sum;\r\n    }\r\n\r\n    function onRowExpanded(event) {\r\n        const row = event.detail.row;\r\n        row.expanded = true;\r\n        if (row.children) show(row.children);\r\n        updateYPositions();\r\n    }\r\n\r\n    function onRowCollapsed(event) {\r\n        const row = event.detail.row;\r\n        row.expanded = false;\r\n        if (row.children) hide(row.children);\r\n        updateYPositions();\r\n    }\r\n\r\n    function updateYPositions() {\r\n        let y = 0;\r\n        $rowStore.ids.forEach(id => {\r\n            const row = $rowStore.entities[id];\r\n            if (!row.hidden) {\r\n                $rowStore.entities[id].y = y;\r\n                y += $rowHeight;\r\n            }\r\n        });\r\n\r\n        $taskStore.ids.forEach(id => {\r\n            const task = $taskStore.entities[id];\r\n            const row = $rowStore.entities[task.model.resourceId];\r\n            $taskStore.entities[id].top = row.y + $rowPadding;\r\n        });\r\n    }\r\n\r\n    function hide(children) {\r\n        children.forEach(row => {\r\n            if (row.children) hide(row.children);\r\n            row.hidden = true;\r\n        });\r\n    }\r\n\r\n    function show(children, hidden = false) {\r\n        children.forEach(row => {\r\n            if (row.children) show(row.children, !row.expanded);\r\n            row.hidden = hidden;\r\n        });\r\n    }\r\n\r\n    // if gantt displays a bottom scrollbar and table does not, we need to pad out the table\r\n    let bottomScrollbarVisible;\r\n    $: {\r\n        bottomScrollbarVisible = $width > $visibleWidth && scrollWidth <= tableWidth;\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-table sg-view\" style=\"width:{tableWidth}px;\">\r\n    <div class=\"sg-table-header\" style=\"height:{$headerHeight}px\" bind:this={headerContainer}>\r\n        {#each tableHeaders as header}\r\n            <div class=\"sg-table-header-cell sg-table-cell\" style=\"width:{header.width}px\">\r\n                {header.title}\r\n            </div>\r\n        {/each}\r\n    </div>\r\n\r\n    <div class=\"sg-table-body\" class:bottom-scrollbar-visible={bottomScrollbarVisible}>\r\n        <div class=\"sg-table-scroller\" use:scrollListener>\r\n            <div\r\n                class=\"sg-table-rows\"\r\n                style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"\r\n            >\r\n                {#each visibleRows as row}\r\n                    <TableRow\r\n                        {row}\r\n                        headers={tableHeaders}\r\n                        on:rowExpanded={onRowExpanded}\r\n                        on:rowCollapsed={onRowCollapsed}\r\n                    />\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    /* This class should take into account varying widths of the scroll bar */\r\n    .bottom-scrollbar-visible {\r\n        padding-bottom: 17px;\r\n    }\r\n\r\n    .sg-table {\r\n        overflow-x: auto;\r\n        display: flex;\r\n        flex-direction: column;\r\n    }\r\n\r\n    .sg-table-scroller {\r\n        width: 100%;\r\n        border-bottom: 1px solid #efefef;\r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .sg-table-header {\r\n        display: flex;\r\n        align-items: stretch;\r\n        overflow: hidden;\r\n        border-bottom: #efefef 1px solid;\r\n        background-color: #fbfbfb;\r\n    }\r\n\r\n    .sg-table-rows {\r\n    }\r\n\r\n    .sg-table-body {\r\n        display: flex;\r\n        flex: 1 1 0;\r\n        width: 100%;\r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .sg-table-header-cell {\r\n        font-size: 14px;\r\n        font-weight: 400;\r\n    }\r\n\r\n    :global(.sg-table-cell) {\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n\r\n        display: flex;\r\n        align-items: center;\r\n        flex-shrink: 0;\r\n\r\n        padding: 0 0.5em;\r\n        height: 100%;\r\n    }\r\n\r\n    :global(.sg-table-cell:last-child) {\r\n        flex-grow: 1;\r\n    }\r\n</style>\r\n","","<script lang=\"ts\">\r\n    import { getContext } from 'svelte';\r\n    import type { GanttDataStore } from '../../core/store';\r\n    const { rowStore, taskStore } = getContext('dataStore') as GanttDataStore;\r\n\r\n    export let id;\r\n    export let fromId;\r\n    export let toId;\r\n    export let stroke = 'red';\r\n    export let strokeWidth = 2;\r\n\r\n    const MIN_LEN = 12;\r\n    const ARROW_SIZE = 5;\r\n\r\n    let arrowPath;\r\n    let path;\r\n\r\n    let fromTask;\r\n    let isFromRowHidden;\r\n    let toTask;\r\n    let isToRowHidden;\r\n\r\n    $: {\r\n        fromTask = $taskStore.entities[fromId];\r\n        isFromRowHidden = $rowStore.entities[fromTask.model.resourceId].hidden;\r\n        toTask = $taskStore.entities[toId];\r\n        isToRowHidden = $rowStore.entities[toTask.model.resourceId].hidden;\r\n\r\n        let startY = fromTask.top + fromTask.height / 2;\r\n        let startX = fromTask.left + fromTask.width;\r\n        let endY = toTask.top + toTask.height / 2;\r\n        let endX = toTask.left;\r\n        let width = endX - startX;\r\n        let height = endY - startY;\r\n\r\n        if (isFromRowHidden) {\r\n            path = `M${endX} ${endY}`;\r\n            if (startX + MIN_LEN >= endX && startY != endY) {\r\n                path += `L ${endX + 1.5 - MIN_LEN} ${endY}`;\r\n            } else {\r\n                path += `L ${endX + 1.5 - width / 2} ${endY}`;\r\n            }\r\n            path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`;\r\n            arrowPath = `M${toTask.left - ARROW_SIZE}  ${\r\n                toTask.top + toTask.height / 2 - ARROW_SIZE\r\n            } \r\n                            L${toTask.left} ${toTask.top + toTask.height / 2} \r\n                            L${toTask.left - ARROW_SIZE} ${\r\n                                toTask.top + toTask.height / 2 + ARROW_SIZE\r\n                            } Z`;\r\n        } else if (isToRowHidden) {\r\n            path = `M${startX} ${startY}`;\r\n            if (startX + MIN_LEN >= endX && startY != endY) {\r\n                path += `L ${startX + 1.5 + MIN_LEN} ${startY}`;\r\n            } else {\r\n                path += `L ${startX + 1.5 + width / 2} ${startY}`;\r\n            }\r\n            path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`;\r\n            arrowPath = ``;\r\n        } else if (!isFromRowHidden && !isToRowHidden) {\r\n            path = `M${startX} ${startY}`;\r\n            if (startX + MIN_LEN >= endX && startY != endY) {\r\n                path += `L ${startX + MIN_LEN} ${startY} \r\n                            L ${startX + MIN_LEN} ${startY + height / 2}\r\n                            L ${endX - MIN_LEN} ${startY + height / 2}\r\n                            L ${endX - MIN_LEN} ${endY}\r\n                            L ${endX - 2} ${endY}`;\r\n            } else {\r\n                path += `L ${startX + width / 2} ${startY} \r\n                            L ${startX + width / 2} ${endY}\r\n                            L ${endX - 2} ${endY}`;\r\n            }\r\n            arrowPath = `M${toTask.left - ARROW_SIZE} ${\r\n                toTask.top + toTask.height / 2 - ARROW_SIZE\r\n            } \r\n                            L${toTask.left} ${toTask.top + toTask.height / 2} \r\n                            L${toTask.left - ARROW_SIZE} ${\r\n                                toTask.top + toTask.height / 2 + ARROW_SIZE\r\n                            } Z`;\r\n        }\r\n    }\r\n</script>\r\n\r\n{#if (!isFromRowHidden && !isToRowHidden) || isFromRowHidden !== isToRowHidden}\r\n    <div class=\"sg-dependency\" style=\"left:0;top:0\" data-dependency-id={id}>\r\n        <svg\r\n            class=\"arrow\"\r\n            xmlns=\"http://www.w3.org/2000/svg\"\r\n            shape-rendering=\"crispEdges\"\r\n            height=\"100%\"\r\n            width=\"100%\"\r\n        >\r\n            <path\r\n                class=\"select-area\"\r\n                d={path}\r\n                {stroke}\r\n                stroke-width={strokeWidth}\r\n                fill=\"transparent\"\r\n            />\r\n            <path d={arrowPath} fill={stroke} />\r\n        </svg>\r\n    </div>\r\n{/if}\r\n\r\n<style>\r\n    .sg-dependency {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n    .arrow {\r\n        position: absolute;\r\n        left: 0px;\r\n        pointer-events: none;\r\n    }\r\n    .select-area {\r\n        pointer-events: visible;\r\n        position: absolute;\r\n    }\r\n</style>\r\n","<script lang=\"ts\">\r\n    import { getContext } from 'svelte';\r\n    import type { GanttDataStore } from '../../core/store';\r\n\r\n    import Dependency from './Dependency.svelte';\r\n\r\n    const { visibleHeight } = getContext('dimensions');\r\n    const { taskStore } = getContext('dataStore') as GanttDataStore;\r\n\r\n    export let paddingTop;\r\n    export let dependencies = [];\r\n\r\n    let visibleDependencies = [];\r\n    $: {\r\n        const result = [];\r\n        for (let i = 0; i < dependencies.length; i++) {\r\n            const dependency = dependencies[i];\r\n            const map = $taskStore.entities;\r\n\r\n            const fromTask = map[dependency.fromId];\r\n            const toTask = map[dependency.toId];\r\n            if (\r\n                fromTask &&\r\n                toTask &&\r\n                Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight &&\r\n                Math.max(fromTask.top, toTask.top) >= paddingTop\r\n            ) {\r\n                result.push(dependency);\r\n            }\r\n        }\r\n        visibleDependencies = result;\r\n    }\r\n</script>\r\n\r\n<div class=\"dependency-container\">\r\n    {#each visibleDependencies as dependency (dependency.id)}\r\n        <Dependency {...dependency} />\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .dependency-container {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n\r\n        pointer-events: none;\r\n        top: 0;\r\n        float: left;\r\n        overflow: hidden;\r\n        z-index: 0;\r\n    }\r\n</style>\r\n","","","",""],"mappings":"AAAA;AACO,SAASA,IAAIA,CAAA,EAAG;;AAIvB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,MAAMA,CAACC,GAAG,EAAEC,GAAG,EAAE;EACjC;EACC,KAAK,MAAMC,CAAC,IAAID,GAAG,EAAED,GAAG,CAACE,CAAC,CAAC,GAAGD,GAAG,CAACC,CAAC,CAAC;EACpC,2BAA6BF,GAAG;AACjC;AAuBO,SAASG,GAAGA,CAACC,EAAE,EAAE;EACvB,OAAOA,EAAE,EAAE;AACZ;AAEO,SAASC,YAAYA,CAAA,EAAG;EAC9B,OAAOC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACO,SAASC,OAAOA,CAACC,GAAG,EAAE;EAC5BA,GAAG,CAACC,OAAO,CAACP,GAAG,CAAC;AACjB;;AAEA;AACA;AACA;AACA;AACO,SAASQ,WAAWA,CAACC,KAAK,EAAE;EAClC,OAAO,OAAOA,KAAK,KAAK,UAAU;AACnC;;AAEA;AACO,SAASC,cAAcA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACpC,OAAOD,CAAC,IAAIA,CAAC,GAAGC,CAAC,IAAIA,CAAC,GAAGD,CAAC,KAAKC,CAAC,IAAKD,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAS,IAAI,OAAOA,CAAC,KAAK,UAAU;AAC5F;AAEA,IAAIE,oBAAoB;;AAExB;AACA;AACA;AACA;AACA;AACO,SAASC,aAAaA,CAACC,WAAW,EAAEC,GAAG,EAAE;EAC/C,IAAID,WAAW,KAAKC,GAAG,EAAE,OAAO,IAAI;EACpC,IAAI,CAACH,oBAAoB,EAAE;IAC1BA,oBAAoB,GAAGI,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;EACpD;EACA;EACCL,oBAAoB,CAACM,IAAI,GAAGH,GAAG;EAC/B,OAAOD,WAAW,KAAKF,oBAAoB,CAACM,IAAI;AACjD;;AAoCA;AACO,SAASC,QAAQA,CAACC,GAAG,EAAE;EAC7B,OAAOlB,MAAM,CAACmB,IAAI,CAACD,GAAG,CAAC,CAACE,MAAM,KAAK,CAAC;AACrC;AASO,SAASC,SAASA,CAACC,KAAK,EAAE,GAAGC,SAAS,EAAE;EAC9C,IAAID,KAAK,IAAI,IAAI,EAAE;IAClB,KAAK,MAAME,QAAQ,IAAID,SAAS,EAAE;MACjCC,QAAQ,CAACC,SAAS,CAAC;IACtB;IACE,OAAOjC,IAAI;EACb;EACC,MAAMkC,KAAK,GAAGJ,KAAK,CAACD,SAAS,CAAC,GAAGE,SAAS,CAAC;EAC3C,OAAOG,KAAK,CAACC,WAAW,GAAG,MAAMD,KAAK,CAACC,WAAW,EAAE,GAAGD,KAAK;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,eAAeA,CAACN,KAAK,EAAE;EACtC,IAAIO,KAAK;EACTR,SAAS,CAACC,KAAK,EAAGQ,CAAC,IAAMD,KAAK,GAAGC,CAAE,CAAC,EAAE;EACtC,OAAOD,KAAK;AACb;;AAEA;AACO,SAASE,mBAAmBA,CAACC,SAAS,EAAEV,KAAK,EAAEE,QAAQ,EAAE;EAC/DQ,SAAS,CAACC,EAAE,CAACC,UAAU,CAACC,IAAI,CAACd,SAAS,CAACC,KAAK,EAAEE,QAAQ,CAAC,CAAC;AACzD;AAEO,SAASY,WAAWA,CAACC,UAAU,EAAEC,GAAG,EAAEC,OAAO,EAAEzC,EAAE,EAAE;EACzD,IAAIuC,UAAU,EAAE;IACf,MAAMG,QAAQ,GAAGC,gBAAgB,CAACJ,UAAU,EAAEC,GAAG,EAAEC,OAAO,EAAEzC,EAAE,CAAC;IAC/D,OAAOuC,UAAU,CAAC,CAAC,CAAC,CAACG,QAAQ,CAAC;EAChC;AACA;AAEA,SAASC,gBAAgBA,CAACJ,UAAU,EAAEC,GAAG,EAAEC,OAAO,EAAEzC,EAAE,EAAE;EACvD,OAAOuC,UAAU,CAAC,CAAC,CAAC,IAAIvC,EAAE,GAAGL,MAAM,CAAC8C,OAAO,CAACD,GAAG,CAACI,KAAK,EAAE,EAAEL,UAAU,CAAC,CAAC,CAAC,CAACvC,EAAE,CAACwC,GAAG,CAAC,CAAC,CAAC,GAAGC,OAAO,CAACD,GAAG;AAC/F;AAEO,SAASK,gBAAgBA,CAACN,UAAU,EAAEE,OAAO,EAAEK,KAAK,EAAE9C,EAAE,EAAE;EAChE,IAAIuC,UAAU,CAAC,CAAC,CAAC,IAAIvC,EAAE,EAAE;IACxB,MAAM+C,IAAI,GAAGR,UAAU,CAAC,CAAC,CAAC,CAACvC,EAAE,CAAC8C,KAAK,CAAC,CAAC;IACrC,IAAIL,OAAO,CAACK,KAAK,KAAKnB,SAAS,EAAE;MAChC,OAAOoB,IAAI;IACd;IACE,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC7B,MAAMC,MAAM,GAAG,EAAE;MACjB,MAAMC,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACV,OAAO,CAACK,KAAK,CAACxB,MAAM,EAAEyB,IAAI,CAACzB,MAAM,CAAC;MACvD,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,GAAG,EAAEG,CAAC,IAAI,CAAC,EAAE;QAChCJ,MAAM,CAACI,CAAC,CAAC,GAAGX,OAAO,CAACK,KAAK,CAACM,CAAC,CAAC,GAAGL,IAAI,CAACK,CAAC,CAAC;MAC1C;MACG,OAAOJ,MAAM;IAChB;IACE,OAAOP,OAAO,CAACK,KAAK,GAAGC,IAAI;EAC7B;EACC,OAAON,OAAO,CAACK,KAAK;AACrB;;AAEA;AACO,SAASO,gBAAgBA,CAC/BC,IAAI,EACJC,eAAe,EACff,GAAG,EACHC,OAAO,EACPe,YAAY,EACZC,mBAAmB,EAClB;EACD,IAAID,YAAY,EAAE;IACjB,MAAME,YAAY,GAAGf,gBAAgB,CAACY,eAAe,EAAEf,GAAG,EAAEC,OAAO,EAAEgB,mBAAmB,CAAC;IACzFH,IAAI,CAACK,CAAC,CAACD,YAAY,EAAEF,YAAY,CAAC;EACpC;AACA;;AAgBA;AACO,SAASI,wBAAwBA,CAACnB,OAAO,EAAE;EACjD,IAAIA,OAAO,CAACD,GAAG,CAAClB,MAAM,GAAG,EAAE,EAAE;IAC5B,MAAMwB,KAAK,GAAG,EAAE;IAChB,MAAMxB,MAAM,GAAGmB,OAAO,CAACD,GAAG,CAAClB,MAAM,GAAG,EAAE;IACtC,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,MAAM,EAAE8B,CAAC,EAAE,EAAE;MAChCN,KAAK,CAACM,CAAC,CAAC,GAAG,CAAC,CAAC;IAChB;IACE,OAAON,KAAK;EACd;EACC,OAAO,CAAC,CAAC;AACV;;AAEA;AACO,SAASe,sBAAsBA,CAACC,KAAK,EAAE;EAC7C,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMjE,CAAC,IAAIgE,KAAK,EAAE,IAAIhE,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAEiE,MAAM,CAACjE,CAAC,CAAC,GAAGgE,KAAK,CAAChE,CAAC,CAAC;EAC7D,OAAOiE,MAAM;AACd;;AAEA;AACO,SAASC,kBAAkBA,CAACF,KAAK,EAAEzC,IAAI,EAAE;EAC/C,MAAM4C,IAAI,GAAG,EAAE;EACf5C,IAAI,GAAG,IAAI6C,GAAG,CAAC7C,IAAI,CAAC;EACpB,KAAK,MAAMvB,CAAC,IAAIgE,KAAK,EAAE,IAAI,CAACzC,IAAI,CAAC8C,GAAG,CAACrE,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAEmE,IAAI,CAACnE,CAAC,CAAC,GAAGgE,KAAK,CAAChE,CAAC,CAAC;EAC3E,OAAOmE,IAAI;AACZ;AAqBO,SAASG,aAAaA,CAACrC,KAAK,EAAE;EACpC,OAAOA,KAAK,IAAI,IAAI,GAAG,EAAE,GAAGA,KAAK;AAClC;AAEO,SAASsC,eAAeA,CAAC7C,KAAK,EAAE8C,GAAG,EAAEvC,KAAK,EAAE;EAClDP,KAAK,CAAC+C,GAAG,CAACxC,KAAK,CAAC;EAChB,OAAOuC,GAAG;AACX;AAIO,SAASE,gBAAgBA,CAACC,aAAa,EAAE;EAC/C,OAAOA,aAAa,IAAIlE,WAAW,CAACkE,aAAa,CAACC,OAAO,CAAC,GAAGD,aAAa,CAACC,OAAO,GAAGhF,IAAI;AAC1F;;AC/IA;AACA;AACA;AACA;AACA;AACO,SAASiF,MAAMA,CAACC,MAAM,EAAEC,IAAI,EAAE;EACpCD,MAAM,CAACE,WAAW,CAACD,IAAI,CAAC;AACzB;;AAwFA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,MAAMA,CAACH,MAAM,EAAEC,IAAI,EAAEG,MAAM,EAAE;EAC5CJ,MAAM,CAACK,YAAY,CAACJ,IAAI,EAAEG,MAAM,IAAI,IAAI,CAAC;AAC1C;;AAgBA;AACA;AACA;AACA;AACO,SAASE,MAAMA,CAACL,IAAI,EAAE;EAC5B,IAAIA,IAAI,CAACM,UAAU,EAAE;IACpBN,IAAI,CAACM,UAAU,CAACC,WAAW,CAACP,IAAI,CAAC;EACnC;AACA;;AAEA;AACA;AACO,SAASQ,YAAYA,CAACC,UAAU,EAAEC,SAAS,EAAE;EACnD,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,UAAU,CAAChE,MAAM,EAAE8B,CAAC,IAAI,CAAC,EAAE;IAC9C,IAAIkC,UAAU,CAAClC,CAAC,CAAC,EAAEkC,UAAU,CAAClC,CAAC,CAAC,CAACoC,CAAC,CAACD,SAAS,CAAC;EAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASE,OAAOA,CAACC,IAAI,EAAE;EAC7B,OAAO1E,QAAQ,CAACC,aAAa,CAACyE,IAAI,CAAC;AACpC;;AAkCA;AACA;AACA;AACA;AACA;AACO,SAASC,WAAWA,CAACD,IAAI,EAAE;EACjC,OAAO1E,QAAQ,CAAC4E,eAAe,CAAC,4BAA4B,EAAEF,IAAI,CAAC;AACpE;;AAEA;AACA;AACA;AACA;AACO,SAASG,IAAIA,CAACC,IAAI,EAAE;EAC1B,OAAO9E,QAAQ,CAAC+E,cAAc,CAACD,IAAI,CAAC;AACrC;;AAEA;AACA;AACO,SAASE,KAAKA,CAAA,EAAG;EACvB,OAAOH,IAAI,CAAC,GAAG,CAAC;AACjB;;AAEA;AACA;AACO,SAASI,KAAKA,CAAA,EAAG;EACvB,OAAOJ,IAAI,CAAC,EAAE,CAAC;AAChB;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASK,MAAMA,CAACrB,IAAI,EAAEsB,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACrDxB,IAAI,CAACyB,gBAAgB,CAACH,KAAK,EAAEC,OAAO,EAAEC,OAAO,CAAC;EAC9C,OAAO,MAAMxB,IAAI,CAAC0B,mBAAmB,CAACJ,KAAK,EAAEC,OAAO,EAAEC,OAAO,CAAC;AAC/D;;AAYA;AACA;AACO,SAASG,gBAAgBA,CAACxG,EAAE,EAAE;EACpC,OAAO,UAAUmG,KAAK,EAAE;IACvBA,KAAK,CAACM,eAAe,EAAE;IACzB;IACE,OAAOzG,EAAE,CAAC0G,IAAI,CAAC,IAAI,EAAEP,KAAK,CAAC;EAC7B,CAAE;AACF;;AA8BA;AACA;AACA;AACA;AACA;AACA;AACO,SAASQ,IAAIA,CAAC9B,IAAI,EAAE+B,SAAS,EAAE7E,KAAK,EAAE;EAC5C,IAAIA,KAAK,IAAI,IAAI,EAAE8C,IAAI,CAACgC,eAAe,CAACD,SAAS,CAAC,CAAC,KAC9C,IAAI/B,IAAI,CAACiC,YAAY,CAACF,SAAS,CAAC,KAAK7E,KAAK,EAAE8C,IAAI,CAACkC,YAAY,CAACH,SAAS,EAAE7E,KAAK,CAAC;AACrF;;AAyLA;AACA;AACA;AACA;AACO,SAASiF,QAAQA,CAACvB,OAAO,EAAE;EACjC,OAAOwB,KAAK,CAACC,IAAI,CAACzB,OAAO,CAAC0B,UAAU,CAAC;AACtC;;AAyMA;AACA;AACA;AACA;AACA;AACO,SAASC,QAAQA,CAACvB,IAAI,EAAEC,IAAI,EAAE;EACpCA,IAAI,GAAG,EAAE,GAAGA,IAAI;EAChB,IAAID,IAAI,CAACC,IAAI,KAAKA,IAAI,EAAE;EACxBD,IAAI,CAACC,IAAI,wBAA0BA,IAAK;AACzC;;AA2CA;AACA;AACO,SAASuB,SAASA,CAACxC,IAAI,EAAEyC,GAAG,EAAEvF,KAAK,EAAEwF,SAAS,EAAE;EACtD,IAAIxF,KAAK,IAAI,IAAI,EAAE;IAClB8C,IAAI,CAAC2C,KAAK,CAACC,cAAc,CAACH,GAAG,CAAC;EAChC,CAAE,MAAM;IACNzC,IAAI,CAAC2C,KAAK,CAACE,WAAW,CAACJ,GAAG,EAAEvF,KAAK,EAAEwF,SAAS,GAAG,WAAW,GAAG,EAAE,CAAC;EAClE;AACA;AAkCA;AACA;;AAEA;AACA;AACA,IAAII,WAAW;;AAEf;AACA;AACO,SAASC,cAAcA,CAAA,EAAG;EAChC,IAAID,WAAW,KAAKhG,SAAS,EAAE;IAC9BgG,WAAW,GAAG,KAAK;IACnB,IAAI;MACH,IAAI,OAAOE,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,MAAM,EAAE;QACnD,KAAKD,MAAM,CAACC,MAAM,CAAC9G,QAAQ;MAC/B;IACA,CAAG,CAAC,OAAO+G,KAAK,EAAE;MACfJ,WAAW,GAAG,IAAI;IACrB;EACA;EACC,OAAOA,WAAW;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASK,0BAA0BA,CAACnD,IAAI,EAAE7E,EAAE,EAAE;EACpD,MAAMiI,cAAc,GAAGC,gBAAgB,CAACrD,IAAI,CAAC;EAC7C,IAAIoD,cAAc,CAACE,QAAQ,KAAK,QAAQ,EAAE;IACzCtD,IAAI,CAAC2C,KAAK,CAACW,QAAQ,GAAG,UAAU;EAClC;EACC,MAAMC,MAAM,GAAG3C,OAAO,CAAC,QAAQ,CAAC;EAChC2C,MAAM,CAACrB,YAAY,CAClB,OAAO,EACP,kFAAkF,GACjF,6EACH,CAAE;EACDqB,MAAM,CAACrB,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;EAC1CqB,MAAM,CAACC,QAAQ,GAAG,CAAC,CAAC;EACpB,MAAMV,WAAW,GAAGC,cAAc,EAAE;;EAErC;AACA;AACA;EACC,IAAI/F,WAAW;EACf,IAAI8F,WAAW,EAAE;IAChBS,MAAM,CAACvI,GAAG,GAAG,gFAAgF;IAC7FgC,WAAW,GAAGqE,MAAM,CACnB2B,MAAM,EACN,SAAS,EACZ,kCAAuC1B,KAAK,IAAK;MAC7C,IAAIA,KAAK,CAACmC,MAAM,KAAKF,MAAM,CAACG,aAAa,EAAEvI,EAAE,EAAE;IACnD,CACA,CAAG;EACH,CAAE,MAAM;IACNoI,MAAM,CAACvI,GAAG,GAAG,aAAa;IAC1BuI,MAAM,CAACI,MAAM,GAAG,MAAM;MACrB3G,WAAW,GAAGqE,MAAM,CAACkC,MAAM,CAACG,aAAa,EAAE,QAAQ,EAAEvI,EAAE,CAAC;MAC3D;MACA;MACGA,EAAE,EAAE;IACP,CAAG;EACH;EACC2E,MAAM,CAACE,IAAI,EAAEuD,MAAM,CAAC;EACpB,OAAO,MAAM;IACZ,IAAIT,WAAW,EAAE;MAChB9F,WAAW,EAAE;IAChB,CAAG,MAAM,IAAIA,WAAW,IAAIuG,MAAM,CAACG,aAAa,EAAE;MAC/C1G,WAAW,EAAE;IAChB;IACEqD,MAAM,CAACkD,MAAM,CAAC;EAChB,CAAE;AACF;;AAYA;AACA;AACO,SAASK,YAAYA,CAAChD,OAAO,EAAEC,IAAI,EAAEgD,MAAM,EAAE;EACpD;EACCjD,OAAO,CAACkD,SAAS,CAACD,MAAM,CAAChD,IAAI,EAAE,CAAC,CAACgD,MAAM,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,YAAYA,CAACC,IAAI,EAAEC,MAAM,EAAE;EAAEC,OAAO,GAAG,KAAK;EAAEC,UAAU,GAAG;AAAK,CAAE,GAAG,EAAE,EAAE;EACxF,OAAO,IAAIC,WAAW,CAACJ,IAAI,EAAE;IAAEC,MAAM;IAAEC,OAAO;IAAEC;EAAU,CAAE,CAAC;AAC9D;AAmCA;AACO,MAAME,OAAO,CAAC;EACrB;AACA;AACA;AACA;EACCC,MAAM,GAAG,KAAK;EACf;EACCC,CAAC,GAAGzH,SAAS;EACd;EACC0H,CAAC,GAAG1H,SAAS;EACd;EACC2H,CAAC,GAAG3H,SAAS;EACd;EACCjB,CAAC,GAAGiB,SAAS;EACb4H,WAAWA,CAACJ,MAAM,GAAG,KAAK,EAAE;IAC3B,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,CAAC,GAAG,IAAI,CAACC,CAAC,GAAG,IAAI;EACxB;;EAEA;AACA;AACA;AACA;EACCG,CAACA,CAACC,IAAI,EAAE;IACP,IAAI,CAACC,CAAC,CAACD,IAAI,CAAC;EACd;;EAEA;AACA;AACA;AACA;AACA;AACA;EACCE,CAACA,CAACF,IAAI,EAAE7E,MAAM,EAAEI,MAAM,GAAG,IAAI,EAAE;IAC9B,IAAI,CAAC,IAAI,CAACoE,CAAC,EAAE;MACZ,IAAI,IAAI,CAACD,MAAM,EACd,IAAI,CAACC,CAAC,GAAGzD,WAAW,2CAA4Cf,MAAM,CAACgF,QAAQ,CAAE;MACrF,kFACI,IAAI,CAACR,CAAC,GAAG3D,OAAO,EACpB;MACMb,MAAM,CAACiF,QAAQ,KAAK,EAAE,GAAG,UAAU,GAAGjF,MAAM,CAACgF,QAEnD,CAAK;MACF,IAAI,CAACN,CAAC,GACL1E,MAAM,CAACkF,OAAO,KAAK,UAAU,GAC1BlF,MAAM,GACb,kCAA2CA,MAAM,CAAEmF,OAAO;MACvD,IAAI,CAACP,CAAC,CAACC,IAAI,CAAC;IACf;IACE,IAAI,CAACrG,CAAC,CAAC4B,MAAM,CAAC;EAChB;;EAEA;AACA;AACA;AACA;EACC0E,CAACA,CAACD,IAAI,EAAE;IACP,IAAI,CAACL,CAAC,CAACY,SAAS,GAAGP,IAAI;IACvB,IAAI,CAACJ,CAAC,GAAGpC,KAAK,CAACC,IAAI,CAClB,IAAI,CAACkC,CAAC,CAACQ,QAAQ,KAAK,UAAU,GAAG,IAAI,CAACR,CAAC,CAACW,OAAO,CAAC5C,UAAU,GAAG,IAAI,CAACiC,CAAC,CAACjC,UACvE,CAAG;EACH;;EAEA;AACA;EACC/D,CAACA,CAAC4B,MAAM,EAAE;IACT,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACiG,CAAC,CAAC/H,MAAM,EAAE8B,CAAC,IAAI,CAAC,EAAE;MAC1C2B,MAAM,CAAC,IAAI,CAACuE,CAAC,EAAE,IAAI,CAACD,CAAC,CAACjG,CAAC,CAAC,EAAE4B,MAAM,CAAC;IACpC;EACA;;EAEA;AACA;AACA;AACA;EACCrB,CAACA,CAAC8F,IAAI,EAAE;IACP,IAAI,CAACjE,CAAC,EAAE;IACR,IAAI,CAACkE,CAAC,CAACD,IAAI,CAAC;IACZ,IAAI,CAACrG,CAAC,CAAC,IAAI,CAAC1C,CAAC,CAAC;EAChB;;EAEA;AACA;EACC8E,CAACA,CAAA,EAAG;IACH,IAAI,CAAC6D,CAAC,CAAC/I,OAAO,CAAC4E,MAAM,CAAC;EACxB;AACA;AA2DO,SAAS+E,0BAA0BA,CAAC/H,SAAS,EAAE4B,KAAK,EAAE;EAC5D,OAAO,IAAI5B,SAAS,CAAC4B,KAAK,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5rCO,IAAIoG,iBAAiB;;AAE5B;AACO,SAASC,qBAAqBA,CAACjI,SAAS,EAAE;EAChDgI,iBAAiB,GAAGhI,SAAS;AAC9B;AAEO,SAASkI,qBAAqBA,CAAA,EAAG;EACvC,IAAI,CAACF,iBAAiB,EAAE,MAAM,IAAIG,KAAK,CAAC,kDAAkD,CAAC;EAC3F,OAAOH,iBAAiB;AACzB;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,OAAOA,CAACtK,EAAE,EAAE;EAC3BoK,qBAAqB,EAAE,CAACjI,EAAE,CAACoI,QAAQ,CAAClI,IAAI,CAACrC,EAAE,CAAC;AAC7C;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASwK,SAASA,CAACxK,EAAE,EAAE;EAC7BoK,qBAAqB,EAAE,CAACjI,EAAE,CAACC,UAAU,CAACC,IAAI,CAACrC,EAAE,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASyK,qBAAqBA,CAAA,EAAG;EACvC,MAAMvI,SAAS,GAAGkI,qBAAqB,EAAE;EACzC,OAAO,CAACvB,IAAI,EAAEC,MAAM,EAAE;IAAEE,UAAU,GAAG;EAAK,CAAE,GAAG,EAAE,KAAK;IACrD,MAAMvH,SAAS,GAAGS,SAAS,CAACC,EAAE,CAACV,SAAS,CAACoH,IAAI,CAAC;IAC9C,IAAIpH,SAAS,EAAE;MACjB;MACA;MACG,MAAM0E,KAAK,GAAGyC,YAAY,uBAAwBC,IAAI,EAAGC,MAAM,EAAE;QAAEE;MAAU,CAAE,CAAC;MAChFvH,SAAS,CAACmB,KAAK,EAAE,CAACtC,OAAO,CAAEN,EAAE,IAAK;QACjCA,EAAE,CAAC0G,IAAI,CAACxE,SAAS,EAAEiE,KAAK,CAAC;MAC7B,CAAI,CAAC;MACF,OAAO,CAACA,KAAK,CAACuE,gBAAgB;IACjC;IACE,OAAO,IAAI;EACb,CAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,UAAUA,CAACrD,GAAG,EAAEsD,OAAO,EAAE;EACxCR,qBAAqB,EAAE,CAACjI,EAAE,CAACyI,OAAO,CAACrG,GAAG,CAAC+C,GAAG,EAAEsD,OAAO,CAAC;EACpD,OAAOA,OAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,UAAUA,CAACvD,GAAG,EAAE;EAC/B,OAAO8C,qBAAqB,EAAE,CAACjI,EAAE,CAACyI,OAAO,CAACE,GAAG,CAACxD,GAAG,CAAC;AACnD;;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASyD,MAAMA,CAAC7I,SAAS,EAAEiE,KAAK,EAAE;EACxC,MAAM1E,SAAS,GAAGS,SAAS,CAACC,EAAE,CAACV,SAAS,CAAC0E,KAAK,CAAC0C,IAAI,CAAC;EACpD,IAAIpH,SAAS,EAAE;IAChB;IACEA,SAAS,CAACmB,KAAK,EAAE,CAACtC,OAAO,CAAEN,EAAE,IAAKA,EAAE,CAAC0G,IAAI,CAAC,IAAI,EAAEP,KAAK,CAAC,CAAC;EACzD;AACA;ACnLO,MAAM6E,gBAAgB,GAAG,EAAE;AAE3B,MAAMC,iBAAiB,GAAG,EAAE;AAEnC,IAAIC,gBAAgB,GAAG,EAAE;AAEzB,MAAMC,eAAe,GAAG,EAAE;AAE1B,MAAMC,gBAAgB,kBAAmBC,OAAO,CAACC,OAAO,EAAE;AAE1D,IAAIC,gBAAgB,GAAG,KAAK;;AAE5B;AACO,SAASC,eAAeA,CAAA,EAAG;EACjC,IAAI,CAACD,gBAAgB,EAAE;IACtBA,gBAAgB,GAAG,IAAI;IACvBH,gBAAgB,CAACK,IAAI,CAACC,KAAK,CAAC;EAC9B;AACA;;AAEA;AACO,SAASC,IAAIA,CAAA,EAAG;EACtBH,eAAe,EAAE;EACjB,OAAOJ,gBAAgB;AACxB;;AAEA;AACO,SAASQ,mBAAmBA,CAAC5L,EAAE,EAAE;EACvCkL,gBAAgB,CAAC7I,IAAI,CAACrC,EAAE,CAAC;AAC1B;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM6L,cAAc,GAAG,IAAI3H,GAAG,EAAE;AAEhC,IAAI4H,QAAQ,GAAG,CAAC,CAAC;;AAEjB;AACO,SAASJ,KAAKA,CAAA,EAAG;EACxB;EACA;EACA;EACC,IAAII,QAAQ,KAAK,CAAC,EAAE;IACnB;EACF;EACC,MAAMC,eAAe,GAAG7B,iBAAiB;EACzC,GAAG;IACJ;IACA;IACE,IAAI;MACH,OAAO4B,QAAQ,GAAGd,gBAAgB,CAAC1J,MAAM,EAAE;QAC1C,MAAMY,SAAS,GAAG8I,gBAAgB,CAACc,QAAQ,CAAC;QAC5CA,QAAQ,EAAE;QACV3B,qBAAqB,CAACjI,SAAS,CAAC;QAChC8J,MAAM,CAAC9J,SAAS,CAACC,EAAE,CAAC;MACxB;IACA,CAAG,CAAC,OAAOiH,CAAC,EAAE;MACd;MACG4B,gBAAgB,CAAC1J,MAAM,GAAG,CAAC;MAC3BwK,QAAQ,GAAG,CAAC;MACZ,MAAM1C,CAAC;IACV;IACEe,qBAAqB,CAAC,IAAI,CAAC;IAC3Ba,gBAAgB,CAAC1J,MAAM,GAAG,CAAC;IAC3BwK,QAAQ,GAAG,CAAC;IACZ,OAAOb,iBAAiB,CAAC3J,MAAM,EAAE2J,iBAAiB,CAACgB,GAAG,EAAE,EAAE;IAC5D;IACA;IACA;IACE,KAAK,IAAI7I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8H,gBAAgB,CAAC5J,MAAM,EAAE8B,CAAC,IAAI,CAAC,EAAE;MACpD,MAAM1B,QAAQ,GAAGwJ,gBAAgB,CAAC9H,CAAC,CAAC;MACpC,IAAI,CAACyI,cAAc,CAAC1H,GAAG,CAACzC,QAAQ,CAAC,EAAE;QACtC;QACImK,cAAc,CAACK,GAAG,CAACxK,QAAQ,CAAC;QAC5BA,QAAQ,EAAE;MACd;IACA;IACEwJ,gBAAgB,CAAC5J,MAAM,GAAG,CAAC;EAC7B,CAAE,QAAQ0J,gBAAgB,CAAC1J,MAAM;EAChC,OAAO6J,eAAe,CAAC7J,MAAM,EAAE;IAC9B6J,eAAe,CAACc,GAAG,EAAE,EAAE;EACzB;EACCV,gBAAgB,GAAG,KAAK;EACxBM,cAAc,CAACM,KAAK,EAAE;EACtBhC,qBAAqB,CAAC4B,eAAe,CAAC;AACvC;;AAEA;AACA,SAASC,MAAMA,CAAC7J,EAAE,EAAE;EACnB,IAAIA,EAAE,CAACiK,QAAQ,KAAK,IAAI,EAAE;IACzBjK,EAAE,CAAC6J,MAAM,EAAE;IACX5L,OAAO,CAAC+B,EAAE,CAACkK,aAAa,CAAC;IACzB,MAAMvJ,KAAK,GAAGX,EAAE,CAACW,KAAK;IACtBX,EAAE,CAACW,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;IACfX,EAAE,CAACiK,QAAQ,IAAIjK,EAAE,CAACiK,QAAQ,CAACzI,CAAC,CAACxB,EAAE,CAACK,GAAG,EAAEM,KAAK,CAAC;IAC3CX,EAAE,CAACmK,YAAY,CAAChM,OAAO,CAACsL,mBAAmB,CAAC;EAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASW,sBAAsBA,CAAClM,GAAG,EAAE;EAC3C,MAAMmM,QAAQ,GAAG,EAAE;EACnB,MAAMC,OAAO,GAAG,EAAE;EAClBvB,gBAAgB,CAAC5K,OAAO,CAAEkJ,CAAC,IAAMnJ,GAAG,CAACqM,OAAO,CAAClD,CAAC,CAAC,KAAK,CAAC,CAAC,GAAGgD,QAAQ,CAACnK,IAAI,CAACmH,CAAC,CAAC,GAAGiD,OAAO,CAACpK,IAAI,CAACmH,CAAC,CAAE,CAAC;EAC7FiD,OAAO,CAACnM,OAAO,CAAEkJ,CAAC,IAAKA,CAAC,EAAE,CAAC;EAC3B0B,gBAAgB,GAAGsB,QAAQ;AAC5B;ACnGA,MAAMG,QAAQ,GAAG,IAAIzI,GAAG,EAAE;;AAE1B;AACA;AACA;AACA,IAAI0I,MAAM;;AAEV;AACA;AACO,SAASC,YAAYA,CAAA,EAAG;EAC9BD,MAAM,GAAG;IACRE,CAAC,EAAE,CAAC;IACJtD,CAAC,EAAE,EAAE;IACL7F,CAAC,EAAEiJ,MAAM;EACX,CAAE;AACF;;AAEA;AACA;AACO,SAASG,YAAYA,CAAA,EAAG;EAC9B,IAAI,CAACH,MAAM,CAACE,CAAC,EAAE;IACd1M,OAAO,CAACwM,MAAM,CAACpD,CAAC,CAAC;EACnB;EACCoD,MAAM,GAAGA,MAAM,CAACjJ,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASqJ,aAAaA,CAACC,KAAK,EAAEC,KAAK,EAAE;EAC3C,IAAID,KAAK,IAAIA,KAAK,CAAC7J,CAAC,EAAE;IACrBuJ,QAAQ,CAACQ,MAAM,CAACF,KAAK,CAAC;IACtBA,KAAK,CAAC7J,CAAC,CAAC8J,KAAK,CAAC;EAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,cAAcA,CAACH,KAAK,EAAEC,KAAK,EAAEhI,MAAM,EAAExD,QAAQ,EAAE;EAC9D,IAAIuL,KAAK,IAAIA,KAAK,CAACI,CAAC,EAAE;IACrB,IAAIV,QAAQ,CAACxI,GAAG,CAAC8I,KAAK,CAAC,EAAE;IACzBN,QAAQ,CAACT,GAAG,CAACe,KAAK,CAAC;IACnBL,MAAM,CAACpD,CAAC,CAACnH,IAAI,CAAC,MAAM;MACnBsK,QAAQ,CAACQ,MAAM,CAACF,KAAK,CAAC;MACtB,IAAIvL,QAAQ,EAAE;QACb,IAAIwD,MAAM,EAAE+H,KAAK,CAACzH,CAAC,CAAC,CAAC,CAAC;QACtB9D,QAAQ,EAAE;MACd;IACA,CAAG,CAAC;IACFuL,KAAK,CAACI,CAAC,CAACH,KAAK,CAAC;EAChB,CAAE,MAAM,IAAIxL,QAAQ,EAAE;IACpBA,QAAQ,EAAE;EACZ;AACA;;AAiVA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzcA;;AAEO,SAAS4L,iBAAiBA,CAACC,sBAAsB,EAAE;EACzD,OAAOA,sBAAsB,EAAEjM,MAAM,KAAKK,SAAS,GAChD4L,sBAAsB,GACtBtG,KAAK,CAACC,IAAI,CAACqG,sBAAsB,CAAC;AACtC;;AAUA;AACO,SAASC,uBAAuBA,CAACP,KAAK,EAAEQ,MAAM,EAAE;EACtDL,cAAc,CAACH,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,MAAM;IACjCQ,MAAM,CAACN,MAAM,CAACF,KAAK,CAAC3F,GAAG,CAAC;EAC1B,CAAE,CAAC;AACH;;AAcA;AACO,SAASoG,iBAAiBA,CAChCC,UAAU,EACV7K,KAAK,EACL8K,OAAO,EACPC,OAAO,EACPrL,GAAG,EACHsL,IAAI,EACJL,MAAM,EACN5I,IAAI,EACJH,OAAO,EACPqJ,iBAAiB,EACjBC,IAAI,EACJC,WAAW,EACV;EACD,IAAIZ,CAAC,GAAGM,UAAU,CAACrM,MAAM;EACzB,IAAI+H,CAAC,GAAGyE,IAAI,CAACxM,MAAM;EACnB,IAAI8B,CAAC,GAAGiK,CAAC;EACT,MAAMa,WAAW,GAAG,EAAE;EACtB,OAAO9K,CAAC,EAAE,EAAE8K,WAAW,CAACP,UAAU,CAACvK,CAAC,CAAC,CAACkE,GAAG,CAAC,GAAGlE,CAAC;EAC9C,MAAM+K,UAAU,GAAG,EAAE;EACrB,MAAMC,UAAU,GAAG,IAAIC,GAAG,EAAE;EAC5B,MAAMC,MAAM,GAAG,IAAID,GAAG,EAAE;EACxB,MAAME,OAAO,GAAG,EAAE;EAClBnL,CAAC,GAAGiG,CAAC;EACL,OAAOjG,CAAC,EAAE,EAAE;IACX,MAAMoL,SAAS,GAAGP,WAAW,CAACzL,GAAG,EAAEsL,IAAI,EAAE1K,CAAC,CAAC;IAC3C,MAAMkE,GAAG,GAAGsG,OAAO,CAACY,SAAS,CAAC;IAC9B,IAAIvB,KAAK,GAAGQ,MAAM,CAAC3C,GAAG,CAACxD,GAAG,CAAC;IAC3B,IAAI,CAAC2F,KAAK,EAAE;MACXA,KAAK,GAAGc,iBAAiB,CAACzG,GAAG,EAAEkH,SAAS,CAAC;MACzCvB,KAAK,CAACzD,CAAC,EAAE;IACZ,CAAG,MAAM,IAAIqE,OAAO,EAAE;MACtB;MACGU,OAAO,CAAClM,IAAI,CAAC,MAAM4K,KAAK,CAACtJ,CAAC,CAAC6K,SAAS,EAAE1L,KAAK,CAAC,CAAC;IAChD;IACEsL,UAAU,CAAC7J,GAAG,CAAC+C,GAAG,EAAG6G,UAAU,CAAC/K,CAAC,CAAC,GAAG6J,KAAK,CAAE;IAC5C,IAAI3F,GAAG,IAAI4G,WAAW,EAAEI,MAAM,CAAC/J,GAAG,CAAC+C,GAAG,EAAEpE,IAAI,CAACuL,GAAG,CAACrL,CAAC,GAAG8K,WAAW,CAAC5G,GAAG,CAAC,CAAC,CAAC;EACzE;EACC,MAAMoH,SAAS,GAAG,IAAIxK,GAAG,EAAE;EAC3B,MAAMyK,QAAQ,GAAG,IAAIzK,GAAG,EAAE;EAC3B;EACC,SAASa,MAAMA,CAACkI,KAAK,EAAE;IACtBD,aAAa,CAACC,KAAK,EAAE,CAAC,CAAC;IACvBA,KAAK,CAACtD,CAAC,CAAC9E,IAAI,EAAEmJ,IAAI,CAAC;IACnBP,MAAM,CAAClJ,GAAG,CAAC0I,KAAK,CAAC3F,GAAG,EAAE2F,KAAK,CAAC;IAC5Be,IAAI,GAAGf,KAAK,CAAC2B,KAAK;IAClBvF,CAAC,EAAE;EACL;EACC,OAAOgE,CAAC,IAAIhE,CAAC,EAAE;IACd,MAAMwF,SAAS,GAAGV,UAAU,CAAC9E,CAAC,GAAG,CAAC,CAAC;IACnC,MAAMyF,SAAS,GAAGnB,UAAU,CAACN,CAAC,GAAG,CAAC,CAAC;IACnC,MAAM0B,OAAO,GAAGF,SAAS,CAACvH,GAAG;IAC7B,MAAM0H,OAAO,GAAGF,SAAS,CAACxH,GAAG;IAC7B,IAAIuH,SAAS,KAAKC,SAAS,EAAE;MAC/B;MACGd,IAAI,GAAGa,SAAS,CAACD,KAAK;MACtBvB,CAAC,EAAE;MACHhE,CAAC,EAAE;IACN,CAAG,MAAM,IAAI,CAAC+E,UAAU,CAACjK,GAAG,CAAC6K,OAAO,CAAC,EAAE;MACvC;MACGtK,OAAO,CAACoK,SAAS,EAAErB,MAAM,CAAC;MAC1BJ,CAAC,EAAE;IACN,CAAG,MAAM,IAAI,CAACI,MAAM,CAACtJ,GAAG,CAAC4K,OAAO,CAAC,IAAIL,SAAS,CAACvK,GAAG,CAAC4K,OAAO,CAAC,EAAE;MAC1DhK,MAAM,CAAC8J,SAAS,CAAC;IACpB,CAAG,MAAM,IAAIF,QAAQ,CAACxK,GAAG,CAAC6K,OAAO,CAAC,EAAE;MACjC3B,CAAC,EAAE;IACN,CAAG,MAAM,IAAIiB,MAAM,CAACxD,GAAG,CAACiE,OAAO,CAAC,GAAGT,MAAM,CAACxD,GAAG,CAACkE,OAAO,CAAC,EAAE;MACrDL,QAAQ,CAACzC,GAAG,CAAC6C,OAAO,CAAC;MACrBhK,MAAM,CAAC8J,SAAS,CAAC;IACpB,CAAG,MAAM;MACNH,SAAS,CAACxC,GAAG,CAAC8C,OAAO,CAAC;MACtB3B,CAAC,EAAE;IACN;EACA;EACC,OAAOA,CAAC,EAAE,EAAE;IACX,MAAMyB,SAAS,GAAGnB,UAAU,CAACN,CAAC,CAAC;IAC/B,IAAI,CAACe,UAAU,CAACjK,GAAG,CAAC2K,SAAS,CAACxH,GAAG,CAAC,EAAE5C,OAAO,CAACoK,SAAS,EAAErB,MAAM,CAAC;EAChE;EACC,OAAOpE,CAAC,EAAEtE,MAAM,CAACoJ,UAAU,CAAC9E,CAAC,GAAG,CAAC,CAAC,CAAC;EACnCjJ,OAAO,CAACmO,OAAO,CAAC;EAChB,OAAOJ,UAAU;AAClB;;ACxHA;AACO,SAASc,iBAAiBA,CAACC,MAAM,EAAEX,OAAO,EAAE;EAClD,MAAMvC,MAAM,GAAG,EAAE;EACjB,MAAMmD,WAAW,GAAG,EAAE;EACtB,MAAMC,aAAa,GAAG;IAAE3M,OAAO,EAAE;EAAC,CAAE;EACpC,IAAIW,CAAC,GAAG8L,MAAM,CAAC5N,MAAM;EACrB,OAAO8B,CAAC,EAAE,EAAE;IACX,MAAMiK,CAAC,GAAG6B,MAAM,CAAC9L,CAAC,CAAC;IACnB,MAAMiG,CAAC,GAAGkF,OAAO,CAACnL,CAAC,CAAC;IACpB,IAAIiG,CAAC,EAAE;MACN,KAAK,MAAM/B,GAAG,IAAI+F,CAAC,EAAE;QACpB,IAAI,EAAE/F,GAAG,IAAI+B,CAAC,CAAC,EAAE8F,WAAW,CAAC7H,GAAG,CAAC,GAAG,CAAC;MACzC;MACG,KAAK,MAAMA,GAAG,IAAI+B,CAAC,EAAE;QACpB,IAAI,CAAC+F,aAAa,CAAC9H,GAAG,CAAC,EAAE;UACxB0E,MAAM,CAAC1E,GAAG,CAAC,GAAG+B,CAAC,CAAC/B,GAAG,CAAC;UACpB8H,aAAa,CAAC9H,GAAG,CAAC,GAAG,CAAC;QAC3B;MACA;MACG4H,MAAM,CAAC9L,CAAC,CAAC,GAAGiG,CAAC;IAChB,CAAG,MAAM;MACN,KAAK,MAAM/B,GAAG,IAAI+F,CAAC,EAAE;QACpB+B,aAAa,CAAC9H,GAAG,CAAC,GAAG,CAAC;MAC1B;IACA;EACA;EACC,KAAK,MAAMA,GAAG,IAAI6H,WAAW,EAAE;IAC9B,IAAI,EAAE7H,GAAG,IAAI0E,MAAM,CAAC,EAAEA,MAAM,CAAC1E,GAAG,CAAC,GAAG3F,SAAS;EAC/C;EACC,OAAOqK,MAAM;AACd;AAEO,SAASqD,iBAAiBA,CAACC,YAAY,EAAE;EAC/C,OAAO,OAAOA,YAAY,KAAK,QAAQ,IAAIA,YAAY,KAAK,IAAI,GAAGA,YAAY,GAAG,EAAE;AACrF;;ACJA;AACO,SAASC,gBAAgBA,CAACtC,KAAK,EAAE;EACvCA,KAAK,IAAIA,KAAK,CAACzD,CAAC,EAAE;AACnB;;AAOA;AACO,SAASgG,eAAeA,CAACtN,SAAS,EAAE0C,MAAM,EAAEI,MAAM,EAAE;EAC1D,MAAM;IAAEoH,QAAQ;IAAEE;EAAY,CAAE,GAAGpK,SAAS,CAACC,EAAE;EAC/CiK,QAAQ,IAAIA,QAAQ,CAACzC,CAAC,CAAC/E,MAAM,EAAEI,MAAM,CAAC;EACvC;EACC4G,mBAAmB,CAAC,MAAM;IACzB,MAAM6D,cAAc,GAAGvN,SAAS,CAACC,EAAE,CAACoI,QAAQ,CAACmF,GAAG,CAAC3P,GAAG,CAAC,CAAC4P,MAAM,CAACpP,WAAW,CAAC;IAC3E;IACA;IACA;IACE,IAAI2B,SAAS,CAACC,EAAE,CAACC,UAAU,EAAE;MAC5BF,SAAS,CAACC,EAAE,CAACC,UAAU,CAACC,IAAI,CAAC,GAAGoN,cAAc,CAAC;IAClD,CAAG,MAAM;MACT;MACA;MACGrP,OAAO,CAACqP,cAAc,CAAC;IAC1B;IACEvN,SAAS,CAACC,EAAE,CAACoI,QAAQ,GAAG,EAAE;EAC5B,CAAE,CAAC;EACF+B,YAAY,CAAChM,OAAO,CAACsL,mBAAmB,CAAC;AAC1C;;AAEA;AACO,SAASgE,iBAAiBA,CAAC1N,SAAS,EAAEqD,SAAS,EAAE;EACvD,MAAMpD,EAAE,GAAGD,SAAS,CAACC,EAAE;EACvB,IAAIA,EAAE,CAACiK,QAAQ,KAAK,IAAI,EAAE;IACzBG,sBAAsB,CAACpK,EAAE,CAACmK,YAAY,CAAC;IACvClM,OAAO,CAAC+B,EAAE,CAACC,UAAU,CAAC;IACtBD,EAAE,CAACiK,QAAQ,IAAIjK,EAAE,CAACiK,QAAQ,CAAC5G,CAAC,CAACD,SAAS,CAAC;IACzC;IACA;IACEpD,EAAE,CAACC,UAAU,GAAGD,EAAE,CAACiK,QAAQ,GAAG,IAAI;IAClCjK,EAAE,CAACK,GAAG,GAAG,EAAE;EACb;AACA;;AAEA;AACA,SAASqN,UAAUA,CAAC3N,SAAS,EAAEkB,CAAC,EAAE;EACjC,IAAIlB,SAAS,CAACC,EAAE,CAACW,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;IACjCkI,gBAAgB,CAAC3I,IAAI,CAACH,SAAS,CAAC;IAChCsJ,eAAe,EAAE;IACjBtJ,SAAS,CAACC,EAAE,CAACW,KAAK,CAACgN,IAAI,CAAC,CAAC,CAAC;EAC5B;EACC5N,SAAS,CAACC,EAAE,CAACW,KAAK,CAAEM,CAAC,GAAG,EAAE,GAAI,CAAC,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAG,EAAE;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS2M,IAAIA,CACnB7N,SAAS,EACTmE,OAAO,EACP2J,QAAQ,EACRC,eAAe,EACfC,SAAS,EACTpM,KAAK,EACLqM,aAAa,GAAG,IAAI,EACpBrN,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,EACX;EACD,MAAMsN,gBAAgB,GAAGlG,iBAAiB;EAC1CC,qBAAqB,CAACjI,SAAS,CAAC;EACjC;EACC,MAAMC,EAAE,GAAID,SAAS,CAACC,EAAE,GAAG;IAC1BiK,QAAQ,EAAE,IAAI;IACd5J,GAAG,EAAE,EAAE;IACT;IACEsB,KAAK;IACLkI,MAAM,EAAEtM,IAAI;IACZwQ,SAAS;IACTG,KAAK,EAAEpQ,YAAY,EAAE;IACvB;IACEsK,QAAQ,EAAE,EAAE;IACZnI,UAAU,EAAE,EAAE;IACdkO,aAAa,EAAE,EAAE;IACjBjE,aAAa,EAAE,EAAE;IACjBC,YAAY,EAAE,EAAE;IAChB1B,OAAO,EAAE,IAAIyD,GAAG,CAAChI,OAAO,CAACuE,OAAO,KAAKwF,gBAAgB,GAAGA,gBAAgB,CAACjO,EAAE,CAACyI,OAAO,GAAG,EAAE,CAAC,CAAC;IAC5F;IACEnJ,SAAS,EAAExB,YAAY,EAAE;IACzB6C,KAAK;IACLyN,UAAU,EAAE,KAAK;IACjBC,IAAI,EAAEnK,OAAO,CAACzB,MAAM,IAAIwL,gBAAgB,CAACjO,EAAE,CAACqO;EAC9C,CAAG;EACFL,aAAa,IAAIA,aAAa,CAAChO,EAAE,CAACqO,IAAI,CAAC;EACvC,IAAIC,KAAK,GAAG,KAAK;EACjBtO,EAAE,CAACK,GAAG,GAAGwN,QAAQ,GACdA,QAAQ,CAAC9N,SAAS,EAAEmE,OAAO,CAACvC,KAAK,IAAI,EAAE,EAAE,CAACV,CAAC,EAAEkB,GAAG,EAAE,GAAGL,IAAI,KAAK;IAC9D,MAAMlC,KAAK,GAAGkC,IAAI,CAAC3C,MAAM,GAAG2C,IAAI,CAAC,CAAC,CAAC,GAAGK,GAAG;IACzC,IAAInC,EAAE,CAACK,GAAG,IAAI0N,SAAS,CAAC/N,EAAE,CAACK,GAAG,CAACY,CAAC,CAAC,EAAGjB,EAAE,CAACK,GAAG,CAACY,CAAC,CAAC,GAAGrB,KAAK,CAAE,EAAE;MACxD,IAAI,CAACI,EAAE,CAACoO,UAAU,IAAIpO,EAAE,CAACkO,KAAK,CAACjN,CAAC,CAAC,EAAEjB,EAAE,CAACkO,KAAK,CAACjN,CAAC,CAAC,CAACrB,KAAK,CAAC;MACrD,IAAI0O,KAAK,EAAEZ,UAAU,CAAC3N,SAAS,EAAEkB,CAAC,CAAC;IACxC;IACI,OAAOkB,GAAG;EACd,CAAK,CAAC,GACF,EAAE;EACLnC,EAAE,CAAC6J,MAAM,EAAE;EACXyE,KAAK,GAAG,IAAI;EACZrQ,OAAO,CAAC+B,EAAE,CAACkK,aAAa,CAAC;EAC1B;EACClK,EAAE,CAACiK,QAAQ,GAAG6D,eAAe,GAAGA,eAAe,CAAC9N,EAAE,CAACK,GAAG,CAAC,GAAG,KAAK;EAC/D,IAAI6D,OAAO,CAACzB,MAAM,EAAE;IACnB,IAAIyB,OAAO,CAACqK,OAAO,EAAE;MAEvB;MACA;MACG,MAAMC,KAAK,GAAG3J,QAAQ,CAACX,OAAO,CAACzB,MAAM,CAAC;MACtCzC,EAAE,CAACiK,QAAQ,IAAIjK,EAAE,CAACiK,QAAQ,CAACwE,CAAC,CAACD,KAAK,CAAC;MACnCA,KAAK,CAACrQ,OAAO,CAAC4E,MAAM,CAAC;IACxB,CAAG,MAAM;MACT;MACG/C,EAAE,CAACiK,QAAQ,IAAIjK,EAAE,CAACiK,QAAQ,CAAC5C,CAAC,EAAE;IACjC;IACE,IAAInD,OAAO,CAACwK,KAAK,EAAE7D,aAAa,CAAC9K,SAAS,CAACC,EAAE,CAACiK,QAAQ,CAAC;IACvDoD,eAAe,CAACtN,SAAS,EAAEmE,OAAO,CAACzB,MAAM,EAAEyB,OAAO,CAACrB,MAAM,CAAC;IAE1D0G,KAAK,EAAE;EACT;EACCvB,qBAAqB,CAACiG,gBAAgB,CAAC;AACxC;;AAsRA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMU,eAAe,CAAC;EAC7B;AACA;AACA;AACA;AACA;AACA;AACA;EACC3O,EAAE,GAAGR,SAAS;EACf;AACA;AACA;AACA;AACA;AACA;AACA;EACCoP,KAAK,GAAGpP,SAAS;;EAElB;EACCqP,QAAQA,CAAA,EAAG;IACVpB,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1B,IAAI,CAACoB,QAAQ,GAAGtR,IAAI;EACtB;;EAEA;AACA;AACA;AACA;AACA;AACA;EACCuR,GAAGA,CAACpI,IAAI,EAAEnH,QAAQ,EAAE;IACnB,IAAI,CAACnB,WAAW,CAACmB,QAAQ,CAAC,EAAE;MAC3B,OAAOhC,IAAI;IACd;IACE,MAAM+B,SAAS,GAAG,IAAI,CAACU,EAAE,CAACV,SAAS,CAACoH,IAAI,CAAC,KAAK,IAAI,CAAC1G,EAAE,CAACV,SAAS,CAACoH,IAAI,CAAC,GAAG,EAAE,CAAC;IAC3EpH,SAAS,CAACY,IAAI,CAACX,QAAQ,CAAC;IACxB,OAAO,MAAM;MACZ,MAAMwP,KAAK,GAAGzP,SAAS,CAACiL,OAAO,CAAChL,QAAQ,CAAC;MACzC,IAAIwP,KAAK,KAAK,CAAC,CAAC,EAAEzP,SAAS,CAAC0P,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IAC/C,CAAG;EACH;;EAEA;AACA;AACA;AACA;EACCE,IAAIA,CAACtN,KAAK,EAAE;IACX,IAAI,IAAI,CAACiN,KAAK,IAAI,CAAC5P,QAAQ,CAAC2C,KAAK,CAAC,EAAE;MACnC,IAAI,CAAC3B,EAAE,CAACoO,UAAU,GAAG,IAAI;MACzB,IAAI,CAACQ,KAAK,CAACjN,KAAK,CAAC;MACjB,IAAI,CAAC3B,EAAE,CAACoO,UAAU,GAAG,KAAK;IAC7B;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AC9fA;AASO,MAAMc,cAAc,GAAG,GAAG;ACPjC,IAAI,OAAOxJ,MAAM,KAAK,WAAW;EACjC;EACC,CAACA,MAAM,CAACyJ,QAAQ,KAAKzJ,MAAM,CAACyJ,QAAQ,GAAG;IAAEC,CAAC,EAAE,IAAIrN,GAAG;EAAE,CAAE,CAAC,EAAEqN,CAAC,CAACrF,GAAG,CAACmF,cAAc,CAAC;ACKhF,MAAMG,gBAAgB,GAAG,EAAE;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,QAAQA,CAAC1P,KAAK,EAAE2P,KAAK,EAAE;EACtC,OAAO;IACNnQ,SAAS,EAAEoQ,QAAQ,CAAC5P,KAAK,EAAE2P,KAAK,CAAC,CAACnQ;EACpC,CAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoQ,QAAQA,CAAC5P,KAAK,EAAE2P,KAAK,GAAGhS,IAAI,EAAE;EAC9C;EACC,IAAIkS,IAAI;EACT;EACC,MAAMC,WAAW,GAAG,IAAI3N,GAAG,EAAE;EAC9B;AACA;AACA;EACC,SAASK,GAAGA,CAACuN,SAAS,EAAE;IACvB,IAAIrR,cAAc,CAACsB,KAAK,EAAE+P,SAAS,CAAC,EAAE;MACrC/P,KAAK,GAAG+P,SAAS;MACjB,IAAIF,IAAI,EAAE;QACb;QACI,MAAMG,SAAS,GAAG,CAACP,gBAAgB,CAAClQ,MAAM;QAC1C,KAAK,MAAM0Q,UAAU,IAAIH,WAAW,EAAE;UACrCG,UAAU,CAAC,CAAC,CAAC,EAAE;UACfR,gBAAgB,CAACnP,IAAI,CAAC2P,UAAU,EAAEjQ,KAAK,CAAC;QAC7C;QACI,IAAIgQ,SAAS,EAAE;UACd,KAAK,IAAI3O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoO,gBAAgB,CAAClQ,MAAM,EAAE8B,CAAC,IAAI,CAAC,EAAE;YACpDoO,gBAAgB,CAACpO,CAAC,CAAC,CAAC,CAAC,CAAC,CAACoO,gBAAgB,CAACpO,CAAC,GAAG,CAAC,CAAC,CAAC;UACrD;UACKoO,gBAAgB,CAAClQ,MAAM,GAAG,CAAC;QAChC;MACA;IACA;EACA;;EAEA;AACA;AACA;AACA;EACC,SAAS0K,MAAMA,CAAChM,EAAE,EAAE;IACnBuE,GAAG,CAACvE,EAAE,CAAC+B,KAAK,CAAC,CAAC;EAChB;;EAEA;AACA;AACA;AACA;AACA;EACC,SAASR,SAASA,CAACxB,GAAG,EAAEkS,UAAU,GAAGvS,IAAI,EAAE;IAC5C;IACE,MAAMsS,UAAU,GAAG,CAACjS,GAAG,EAAEkS,UAAU,CAAC;IACpCJ,WAAW,CAAC3F,GAAG,CAAC8F,UAAU,CAAC;IAC3B,IAAIH,WAAW,CAACK,IAAI,KAAK,CAAC,EAAE;MAC3BN,IAAI,GAAGF,KAAK,CAACnN,GAAG,EAAEyH,MAAM,CAAC,IAAItM,IAAI;IACpC;IACEK,GAAG,CAACgC,KAAK,CAAC;IACV,OAAO,MAAM;MACZ8P,WAAW,CAAC1E,MAAM,CAAC6E,UAAU,CAAC;MAC9B,IAAIH,WAAW,CAACK,IAAI,KAAK,CAAC,IAAIN,IAAI,EAAE;QACnCA,IAAI,EAAE;QACNA,IAAI,GAAG,IAAI;MACf;IACA,CAAG;EACH;EACC,OAAO;IAAErN,GAAG;IAAEyH,MAAM;IAAEzK;EAAS,CAAE;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS4Q,OAAOA,CAACC,MAAM,EAAEpS,EAAE,EAAEqS,aAAa,EAAE;EAClD,MAAMC,MAAM,GAAG,CAACrL,KAAK,CAACsL,OAAO,CAACH,MAAM,CAAC;EACtC;EACC,MAAMI,YAAY,GAAGF,MAAM,GAAG,CAACF,MAAM,CAAC,GAAGA,MAAM;EAC/C,IAAI,CAACI,YAAY,CAACC,KAAK,CAACC,OAAO,CAAC,EAAE;IACjC,MAAM,IAAIrI,KAAK,CAAC,sDAAsD,CAAC;EACzE;EACC,MAAMsI,IAAI,GAAG3S,EAAE,CAACsB,MAAM,GAAG,CAAC;EAC1B,OAAOmQ,QAAQ,CAACY,aAAa,EAAE,CAAC9N,GAAG,EAAEyH,MAAM,KAAK;IAC/C,IAAI4G,OAAO,GAAG,KAAK;IACnB,MAAMC,MAAM,GAAG,EAAE;IACjB,IAAIC,OAAO,GAAG,CAAC;IACf,IAAIC,OAAO,GAAGrT,IAAI;IAClB,MAAMsT,IAAI,GAAGA,CAAA,KAAM;MAClB,IAAIF,OAAO,EAAE;QACZ;MACJ;MACGC,OAAO,EAAE;MACT,MAAMhP,MAAM,GAAG/D,EAAE,CAACsS,MAAM,GAAGO,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,EAAEtO,GAAG,EAAEyH,MAAM,CAAC;MAC3D,IAAI2G,IAAI,EAAE;QACTpO,GAAG,CAACR,MAAM,CAAC;MACf,CAAI,MAAM;QACNgP,OAAO,GAAGxS,WAAW,CAACwD,MAAM,CAAC,GAAGA,MAAM,GAAGrE,IAAI;MACjD;IACA,CAAG;IACD,MAAMuT,aAAa,GAAGT,YAAY,CAAC9C,GAAG,CAAC,CAAClO,KAAK,EAAE4B,CAAC,KAC/C7B,SAAS,CACRC,KAAK,EACJO,KAAK,IAAK;MACV8Q,MAAM,CAACzP,CAAC,CAAC,GAAGrB,KAAK;MACjB+Q,OAAO,IAAI,EAAE,CAAC,IAAI1P,CAAC,CAAC;MACpB,IAAIwP,OAAO,EAAE;QACZI,IAAI,EAAE;MACZ;IACA,CAAK,EACD,MAAM;MACLF,OAAO,IAAI,CAAC,IAAI1P,CAAC;IACtB,CACA,CACA,CAAG;IACDwP,OAAO,GAAG,IAAI;IACdI,IAAI,EAAE;IACN,OAAO,SAASpB,IAAIA,CAAA,EAAG;MACtBxR,OAAO,CAAC6S,aAAa,CAAC;MACtBF,OAAO,EAAE;MACZ;MACA;MACA;MACGH,OAAO,GAAG,KAAK;IAClB,CAAG;EACH,CAAE,CAAC;AACH;ACrJA,SAASM,iBAAiBA,CAAA;EAItB,MAAM;IAAE3R,SAAS;IAAEgD,GAAG;IAAEyH;EAAM,CAAE,GAAG2F,QAAQ,CAAiB;IAAEwB,GAAG,EAAE,EAAE;IAAEC,QAAQ,EAAE;EAAE,CAAE,CAAC;EAEtF,OAAO;IACH7O,GAAG;IACH8O,OAAO,EAAErH,MAAM;IACfzK,SAAS;IACT2K,GAAG,EAAGoH,IAAO,IACTtH,MAAM,CAAC,CAAC;MAAEmH,GAAG;MAAEC;IAAQ,CAAE,MAAM;MAC3BD,GAAG,EAAE,CAAC,GAAGA,GAAG,EAAEG,IAAI,CAACC,KAAK,CAACC,EAAE,CAAC;MAC5BJ,QAAQ,EAAE;QACN,GAAGA,QAAQ;QACX,CAACE,IAAI,CAACC,KAAK,CAACC,EAAE,GAAGF;MACpB;IACJ,EAAC,CAAC;IACPnG,MAAM,EAAGqG,EAAmB,IACxBxH,MAAM,CAACyH,KAAK,IAAG;MACX,MAAM;QAAE,CAACD,EAAE,GAAGxR,CAAC;QAAE,GAAGoR;MAAQ,CAAE,GAAGK,KAAK,CAACL,QAAQ;MAC/C,OAAO;QACHD,GAAG,EAAEM,KAAK,CAACN,GAAG,CAACxD,MAAM,CAACvM,CAAC,IAAIA,CAAC,KAAKoQ,EAAE,CAAC;QACpCJ;OACH;IACL,CAAC,CAAC;IACNM,SAAS,EAAGP,GAAwB,IAChCnH,MAAM,CAACyH,KAAK,IAAG;MACX,MAAML,QAAQ,GAAG;QAAE,GAAGK,KAAK,CAACL;MAAQ,CAAE;MACtC,MAAMO,KAAK,GAAG,IAAIzP,GAAG,CAACiP,GAAG,CAAC;MAE1B,KAAK,IAAI/P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqQ,KAAK,CAACN,GAAG,CAAC7R,MAAM,EAAE8B,CAAC,EAAE,EAAE;QACvC,IAAIuQ,KAAK,CAACxP,GAAG,CAACsP,KAAK,CAACN,GAAG,CAAC/P,CAAC,CAAC,CAAC,EAAE;UACzB,OAAOgQ,QAAQ,CAACK,KAAK,CAACN,GAAG,CAAC/P,CAAC,CAAC,CAAC;QAChC;MACJ;MAED,OAAO;QACH+P,GAAG,EAAEM,KAAK,CAACN,GAAG,CAACxD,MAAM,CAACvM,CAAC,IAAI,CAACuQ,KAAK,CAACxP,GAAG,CAACf,CAAC,CAAC,CAAC;QACzCgQ;OACH;IACL,CAAC,CAAC;IACNpH,MAAM,EAAGsH,IAAO,IACZtH,MAAM,CAAC,CAAC;MAAEmH,GAAG;MAAEC;IAAQ,CAAE,MAAM;MAC3BD,GAAG;MACHC,QAAQ,EAAE;QACN,GAAGA,QAAQ;QACX,CAACE,IAAI,CAACC,KAAK,CAACC,EAAE,GAAGF;MACpB;IACJ,EAAC,CAAC;IACPM,MAAM,EAAGN,IAAO,IACZtH,MAAM,CAAC,CAAC;MAAEmH,GAAG;MAAEC;IAAQ,CAAE,KAAI;MACzB,MAAMS,QAAQ,GAAGV,GAAG,CAACzG,OAAO,CAAC4G,IAAI,CAACC,KAAK,CAACC,EAAE,CAAC,KAAK,CAAC,CAAC;MAElD,OAAO;QACHL,GAAG,EAAEU,QAAQ,GAAGV,GAAG,GAAG,CAAC,GAAGA,GAAG,EAAEG,IAAI,CAACC,KAAK,CAACC,EAAE,CAAC;QAC7CJ,QAAQ,EAAE;UACN,GAAGA,QAAQ;UACX,CAACE,IAAI,CAACC,KAAK,CAACC,EAAE,GAAGF;QACpB;OACJ;IACL,CAAC,CAAC;IACNQ,SAAS,EAAGC,KAAU,IAClB/H,MAAM,CAACyH,KAAK,IAAG;MACX,MAAML,QAAQ,GAAG;QAAE,GAAGK,KAAK,CAACL;MAAQ,CAAE;MACtC,MAAMD,GAAG,GAAG,CAAC,GAAGM,KAAK,CAACN,GAAG,CAAC;MAE1B,KAAK,IAAI/P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2Q,KAAK,CAACzS,MAAM,EAAE8B,CAAC,EAAE,EAAE;QACnC,IAAI+P,GAAG,CAACzG,OAAO,CAACqH,KAAK,CAAC3Q,CAAC,CAAC,CAACmQ,KAAK,CAACC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;UACvCL,GAAG,CAAC9Q,IAAI,CAAC0R,KAAK,CAAC3Q,CAAC,CAAC,CAACmQ,KAAK,CAACC,EAAE,CAAC;QAC9B;QACDJ,QAAQ,CAACW,KAAK,CAAC3Q,CAAC,CAAC,CAACmQ,KAAK,CAACC,EAAE,CAAC,GAAGO,KAAK,CAAC3Q,CAAC,CAAC;MACzC;MAED,OAAO;QACH+P,GAAG;QACHC;OACH;IACL,CAAC,CAAC;IACNY,MAAM,EAAGD,KAAU,IAAI;MACnB,MAAMZ,GAAG,GAAG,EAAE;MACd,MAAMC,QAAQ,GAAG,EAAE;MAEnB,KAAK,IAAIhQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2Q,KAAK,CAACzS,MAAM,EAAE8B,CAAC,EAAE,EAAE;QACnC+P,GAAG,CAAC9Q,IAAI,CAAC0R,KAAK,CAAC3Q,CAAC,CAAC,CAACmQ,KAAK,CAACC,EAAE,CAAC;QAC3BJ,QAAQ,CAACW,KAAK,CAAC3Q,CAAC,CAAC,CAACmQ,KAAK,CAACC,EAAE,CAAC,GAAGO,KAAK,CAAC3Q,CAAC,CAAC;MACzC;MAEDmB,GAAG,CAAC;QAAE4O,GAAG;QAAEC;MAAQ,CAAE,CAAC;KACzB;IACDa,OAAO,EAAEA,CAAA,KAAMjI,MAAM,CAACxK,KAAK,KAAK;MAAE,GAAGA;IAAK,CAAE,CAAC;GAChD;AACL;AAEM,SAAU0S,GAAGA,CAAuB1S,KAAqB;EAC3D,OAAO2Q,OAAO,CAAC3Q,KAAK,EAAE,CAAC;IAAE2R,GAAG;IAAEC;EAAQ,CAAE,KAAI;IACxC,MAAMe,OAAO,GAAG,EAAE;IAClB,KAAK,IAAI/Q,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+P,GAAG,CAAC7R,MAAM,EAAE8B,CAAC,EAAE,EAAE;MACjC+Q,OAAO,CAAC9R,IAAI,CAAC+Q,QAAQ,CAACD,GAAG,CAAC/P,CAAC,CAAC,CAAC,CAAC;IACjC;IACD,OAAO+Q,OAAO;EAClB,CAAC,CAAC;AACN;SAiBgBC,eAAeA,CAAA;EAC3B,MAAMC,SAAS,GAAGnB,iBAAiB,EAAc;EACjD,MAAMoB,QAAQ,GAAGpB,iBAAiB,EAAa;EAC/C,MAAMqB,cAAc,GAAGrB,iBAAiB,EAAmB;EAE3D,MAAMsB,QAAQ,GAAGN,GAAG,CAACG,SAAS,CAAC;EAC/B,MAAMI,OAAO,GAAGP,GAAG,CAACI,QAAQ,CAAC;EAC7B,MAAMI,aAAa,GAAGR,GAAG,CAACK,cAAc,CAAC;EAEzC,MAAMI,YAAY,GAAGxC,OAAO,CAACqC,QAAQ,EAAEI,SAAS,IAAG;IAC/C,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIzR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwR,SAAS,CAACtT,MAAM,EAAE8B,CAAC,EAAE,EAAE;MACvC,MAAM0R,IAAI,GAAGF,SAAS,CAACxR,CAAC,CAAC;MACzB,IAAI,CAACyR,KAAK,CAACC,IAAI,CAACvB,KAAK,CAACwB,UAAU,CAAC,EAAE;QAC/BF,KAAK,CAACC,IAAI,CAACvB,KAAK,CAACwB,UAAU,CAAC,GAAG,EAAE;MACpC;MACDF,KAAK,CAACC,IAAI,CAACvB,KAAK,CAACwB,UAAU,CAAC,CAAC1S,IAAI,CAACyS,IAAI,CAACvB,KAAK,CAACC,EAAE,CAAC;IACnD;IACD,OAAOqB,KAAK;EAChB,CAAC,CAAC;EAEF,MAAMG,iBAAiB,GAAGrD,QAAQ,CAA4B,EAAE,CAAC;EAEjE,OAAO;IACH0C,SAAS;IACTC,QAAQ;IACRC,cAAc;IACdC,QAAQ;IACRC,OAAO;IACPC,aAAa;IACbC,YAAY;IACZK;GACH;AACL;MClJaC,WAAW;EACpBC,aAAa;EAEbC,UAAU;EACVC,WAAW;EAEX7L,YAAY2L,aAA4B;IACpC,IAAI,CAACA,aAAa,GAAGA,aAAa;;EAGtCG,UAAUA,CAAC9B,KAAgB;;;;IAIvBA,KAAK,CAAC+B,UAAU,GAAG/B,KAAK,CAAC+B,UAAU,IAAI,CAAC;;IAExC/B,KAAK,CAACgC,OAAO,GAAGhC,KAAK,CAACgC,OAAO,IAAI,EAAE;;IAEnChC,KAAK,CAACrM,IAAI,GAAGqM,KAAK,CAACrM,IAAI,IAAI,IAAI;;IAE/BqM,KAAK,CAACiC,EAAE,GAAGjC,KAAK,CAACiC,EAAE,IAAI,IAAI;;IAE3BjC,KAAK,CAACkC,KAAK,GAAGlC,KAAK,CAACkC,KAAK,IAAI9T,SAAS;;IAEtC4R,KAAK,CAAC9J,IAAI,GAAG8J,KAAK,CAAC9J,IAAI,IAAI9H,SAAS;;IAEpC4R,KAAK,CAACmC,UAAU,GAAGnC,KAAK,CAACmC,UAAU,IAAI,KAAK;;IAE5CnC,KAAK,CAACoC,aAAa,GAAGpC,KAAK,CAACoC,aAAa,IAAI,EAAE;;IAE/CpC,KAAK,CAACqC,UAAU,GAAGrC,KAAK,CAACqC,UAAU,IAAI,EAAE;;IAEzCrC,KAAK,CAACsC,cAAc,GAAGtC,KAAK,CAACsC,cAAc,KAAKlU,SAAS,GAAG,IAAI,GAAG4R,KAAK,CAACsC,cAAc;IAEvF,MAAMC,IAAI,GAAG,IAAI,CAACZ,aAAa,CAACa,iBAAiB,CAACxC,KAAK,CAACrM,IAAI,CAAC,GAAG,CAAC;IACjE,MAAM8O,KAAK,GAAG,IAAI,CAACd,aAAa,CAACa,iBAAiB,CAACxC,KAAK,CAACiC,EAAE,CAAC,GAAG,CAAC;IAEhE,OAAO;MACHjC,KAAK;MACLuC,IAAI,EAAEA,IAAI;MACVG,KAAK,EAAED,KAAK,GAAGF,IAAI;MACnBI,MAAM,EAAE,IAAI,CAACC,SAAS,CAAC5C,KAAK,CAAC;MAC7B6C,GAAG,EAAE,IAAI,CAACC,OAAO,CAAC9C,KAAK,CAAC;MACxB+C,WAAW,EAAE;KAChB;;EAGLC,WAAWA,CAACC,KAAkB;IAC1B,OAAOA,KAAK,CAAC9G,GAAG,CAACoF,IAAI,IAAI,IAAI,CAACO,UAAU,CAACP,IAAI,CAAC,CAAC;;EAGnD2B,GAAGA,CAAC1B,UAAU;IACV,OAAO,IAAI,CAACK,WAAW,CAACL,UAAU,CAAC;;EAGvCoB,SAASA,CAAC5C,KAAK;IACX,OAAO,IAAI,CAACkD,GAAG,CAAClD,KAAK,CAACwB,UAAU,CAAC,CAACmB,MAAM,GAAG,CAAC,GAAG,IAAI,CAACf,UAAU;;EAGlEkB,OAAOA,CAAC9C,KAAK;IACT,OAAO,IAAI,CAACkD,GAAG,CAAClD,KAAK,CAACwB,UAAU,CAAC,CAAC2B,CAAC,GAAG,IAAI,CAACvB,UAAU;;AAE5D;SAMewB,WAAWA,CAAC7B,IAAgB,EAAE2B,GAAc,EAAEpQ,OAA+B;EACzF,MAAMuQ,WAAW,GAAqB,kBAAA9B,IAAI,CAACvB,KAAK,CAACC,EAAE,IAAIiD,GAAG,CAAClD,KAAK,CAACC,EAAE,EAAE;EAErE,MAAMD,KAAK,GAAG;IACV,GAAGuB,IAAI,CAACvB,KAAK;IACbwB,UAAU,EAAE0B,GAAG,CAAClD,KAAK,CAACC,EAAE;IACxBA,EAAE,EAAEoD,WAAW;IACff,cAAc,EAAE;GACnB;EAED,OAAO;IACH,GAAGf,IAAI;IACPvB,KAAK;IACL6C,GAAG,EAAEK,GAAG,CAACC,CAAC,GAAGrQ,OAAO,CAAC8O,UAAU;IAC/B0B,SAAS,EAAE,IAAI;IACfC,iBAAiB,EAAE,KAAK;IACxBC,gBAAgB,EAAE,IAAI;IACtBC,UAAU,EAAElC,IAAI,CAACvB,KAAK,CAACC;GAC1B;AACL;ACxHM,SAAUyD,WAAWA,CAAC9Q,KAAK;EAC7B,OAAOA,KAAK,CAAC+Q,KAAK,KAAK,CAAC;AAC5B;AAEA;;;;AAIG;AACa,SAAAC,cAAcA,CAACtS,IAAiB,EAAEsB,KAAsC;EACpF,MAAMiR,IAAI,GAAGvS,IAAI,CAACwS,qBAAqB,EAAE;EACzC,MAAMC,CAAC,GAAGnR,KAAK,CAACoR,OAAO,GAAGH,IAAI,CAACtB,IAAI,CAAC;EACpC,MAAMY,CAAC,GAAGvQ,KAAK,CAACqR,OAAO,GAAGJ,IAAI,CAAChB,GAAG,CAAC;EACnC,OAAO;IACHkB,CAAC,EAAEA,CAAC;IACJZ,CAAC,EAAEA;GACN;AACL;AAEA;;;;;;;AAOG;AACG,SAAUe,oBAAoBA,CAChC7S,MAA4B,EAC5BiE,IAAY,EACZ6O,QAAQ,EACRC,UAAW,EACXC,aAAc;EAEdhT,MAAM,CAAC0B,gBAAgB,CAACuC,IAAI,EAAE,SAAS7I,EAAEA,CAAA;IACrC4E,MAAM,CAAC2B,mBAAmB,CAACsC,IAAI,EAAE7I,EAAE,EAAE4X,aAAa,CAAC;IACnDF,QAAQ,CAACG,KAAK,CAAC,IAAI,EAAEC,SAAS,EAAEH,UAAU,CAAC;EAC/C,CAAC,CAAC;AACN;AAEA;;;;AAIG;AACG,SAAUI,SAASA,CAACC,MAAc,EAAEnT,IAAoB,GAAA7D,QAAQ,CAACiX,IAAI;EACvEpT,IAAI,CAAC2C,KAAK,CAACwQ,MAAM,GAAGA,MAAM;AAC9B;AAaM,SAAUE,kBAAkBA,CAAC3C,OAA+B;EAC9D,IAAI,CAACA,OAAO,EAAE;IACV,OAAO,EAAE;EACZ;EACD,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC7B,OAAOA,OAAO;EACjB;EACD,IAAItO,KAAK,CAACsL,OAAO,CAACgD,OAAO,CAAC,EAAE;IACxB,OAAOA,OAAO,CAAC4C,IAAI,CAAC,GAAG,CAAC;EAC3B;EACD,OAAO,EAAE;AACb;AAmBgB,SAAAC,QAAQA,CAA8BC,IAAO,EAAEC,KAAa;EACxE,IAAIC,IAAI,GAAG,KAAK;EAChB,OAAO;IACH,IAAI,CAACA,IAAI,EAAE;MACPF,IAAI,CAACR,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MAC3BS,IAAI,GAAG,IAAI;MACXC,UAAU,CAAC;QACPD,IAAI,GAAG,KAAK;OACf,EAAED,KAAK,CAAC;IACZ;EACL,CAAM;AACV;AC3GA,SAASG,WAAWA,CAACC,GAAG,EAAEC,GAAG,EAAE;EAC7B,IAAKA,GAAG,KAAK,KAAK,CAAC,EAAGA,GAAG,GAAG,EAAE;EAC9B,IAAIC,QAAQ,GAAGD,GAAG,CAACC,QAAQ;EAE3B,IAAI,CAACF,GAAG,IAAI,OAAO1X,QAAQ,KAAK,WAAW,EAAE;IAAE;EAAO;EAEtD,IAAI6X,IAAI,GAAG7X,QAAQ,CAAC6X,IAAI,IAAI7X,QAAQ,CAAC8X,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;EACpE,IAAItR,KAAK,GAAGxG,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;EAC3CuG,KAAK,CAACqB,IAAI,GAAG,UAAU;EAEvB,IAAI+P,QAAQ,KAAK,KAAK,EAAE;IACtB,IAAIC,IAAI,CAACE,UAAU,EAAE;MACnBF,IAAI,CAAC5T,YAAY,CAACuC,KAAK,EAAEqR,IAAI,CAACE,UAAU,CAAC;IAC/C,CAAK,MAAM;MACLF,IAAI,CAAC/T,WAAW,CAAC0C,KAAK,CAAC;IAC7B;EACA,CAAG,MAAM;IACLqR,IAAI,CAAC/T,WAAW,CAAC0C,KAAK,CAAC;EAC3B;EAEE,IAAIA,KAAK,CAACwR,UAAU,EAAE;IACpBxR,KAAK,CAACwR,UAAU,CAACC,OAAO,GAAGP,GAAG;EAClC,CAAG,MAAM;IACLlR,KAAK,CAAC1C,WAAW,CAAC9D,QAAQ,CAAC+E,cAAc,CAAC2S,GAAG,CAAC,CAAC;EACnD;AACA;;;;;;;;;;;;;;MCsQQ3T,MAAyC,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;;;;;;;;;MAGKqC,SAAA,CAAA6R,GAAA,oBAAA1W,GAAK,IAAC8S,UAAU;;;MAA9DvQ,MAAoE,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;QAAtBqC,SAAA,CAAA6R,GAAA,oBAAA1W,GAAK,IAAC8S,UAAU;;;;;;;;;;;;;EAQzD,IAAA6D,OAAA,YAAA3W,GAAK,IAACiT,KAAK;;;;;;;;;;MAAX,IAAA3S,KAAA,oBAAAqW,OAAA,MAAAA,OAAA,YAAA3W,GAAK,IAACiT,KAAK,QAAArO,QAAA,CAAAkC,CAAA,EAAA6P,OAAA;;;;;;;;;;;;;EAFL,IAAAC,SAAA,kBAAA5W,GAAW,eAACA,GAAK;;;;;;;;;;;;;MAAjB,IAAAM,KAAA,oBAAAsW,SAAA,MAAAA,SAAA,kBAAA5W,GAAW,eAACA,GAAK,YAAA6W,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;EAFjB,IAAAA,SAAA,YAAA5W,GAAK,IAACiH,IAAI;;;;;;;;;;;;;MAAV,IAAA3G,KAAA,oBAAAsW,SAAA,MAAAA,SAAA,YAAA5W,GAAK,IAACiH,IAAI,QAAA4P,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;EAUN,IAAAA,SAAA,YAAA5W,GAAK,IAACoT,UAAU;;;;;;;MADEjP,IAAA,CAAA2S,IAAA,WAAAC,gBAAA,gCAAA/W,GAAK,IAACmT,aAAa;;;;;MAAhD5Q,MAEO,CAAAH,MAAA,EAAA0U,IAAA,EAAAtU,MAAA;;;mDAFsDxC,GAAO;;;;;MACzD,IAAAM,KAAA,oBAAAsW,SAAA,MAAAA,SAAA,YAAA5W,GAAK,IAACoT,UAAU,QAAA0D,IAAA,CAAAtP,SAAA,GAAAoP,SAAA;MADE,IAAAtW,KAAA,oBAAAyW,gBAAA,MAAAA,gBAAA,gCAAA/W,GAAK,IAACmT,aAAa;;;;;;;;;;;;;;;;;EAQpB,IAAAwD,OAAA,YAAA3W,GAAK,IAACgX,WAAW;;;;;;;;;MAAjDzU,MAA0D,CAAAH,MAAA,EAAA6Q,KAAA,EAAAzQ,MAAA;;;;MAA1B,IAAAlC,KAAA,oBAAAqW,OAAA,MAAAA,OAAA,YAAA3W,GAAK,IAACgX,WAAW,QAAApS,QAAA,CAAAkC,CAAA,EAAA6P,OAAA;;;;;;;;;;;;;;;;;;;;;2BAzBhD3W,GAAK,IAACqG,IAAI,KAAK,WAAW,IAAA4Q,mBAAA;EAG1B,IAAAC,SAAA,YAAAlX,GAAK,IAAC8S,UAAU,IAAAqE,mBAAA,CAAAnX,GAAA;;IAIZ,cAAAA,GAAK,IAACiH,IAAI,SAAAmQ,mBAAA;wBAELpX,GAAW,aAAAqX,mBAAA;;;;;EAMhB,IAAAC,SAAA,YAAAtX,GAAK,IAACkT,UAAU,IAAAqE,mBAAA,CAAAvX,GAAA;EAQpB,IAAAwX,SAAA,YAAAxX,GAAK,IAACgX,WAAW,IAAAS,iBAAA,CAAAzX,GAAA;;;;;;;;;;;;;;;MApCRmE,IAAA,CAAAuT,IAAA,kBAAAC,uBAAA,YAAA3X,GAAK,IAACgR,EAAE;qEAGNhR,GAAO;MAET6E,SAAA,CAAA6S,IAAA,wBAAA1X,GAAS,IAACyT,KAAK;0CAAazT,GAAM;MAAY6E,SAAA,CAAA6S,IAAA,uBAAA1X,GAAS,IAAC8U,CAAC;MAAWjQ,SAAA,CAAA6S,IAAA,sBAAA1X,GAAS,IAACkU,CAAC;kDADzElU,GAAK,IAACqG,IAAI,KAAK,WAAW;MAEhCJ,YAAA,CAAAyR,IAAA,yBAAA1X,GAAS,oBAAIA,GAAS;;2DAEXA,GAAS;+DACVA,GAAc,aAACA,GAAK,IAACgR,EAAE;4DACzBhR,GAAa;MACZiG,YAAA,CAAAyR,IAAA,8BAAA1X,GAAK,IAAC4X,WAAW;;;MAZ5CrV,MAyCM,CAAAH,MAAA,EAAAsV,IAAA,EAAAlV,MAAA;;;;;MArBFL,MAeM,CAAAuV,IAAA,EAAAG,IAAA;;;;;;;+JAhCW7X,GAAK,M;;;;;oBAWjBA,GAAK,IAACqG,IAAI,KAAK,WAAW;;;;;;;;;;MAG1B,cAAArG,GAAK,IAAC8S,UAAU;;;;;;;;;;;;;;;;;;;;;;MAYZ,cAAA9S,GAAK,IAACkT,UAAU;;;;;;;;;;;;MAQpB,cAAAlT,GAAK,IAACgX,WAAW;;;;;;;;;;;;MApCR,IAAA1W,KAAA,oBAAAqX,uBAAA,MAAAA,uBAAA,YAAA3X,GAAK,IAACgR,EAAE;;;uGAGNhR,GAAO;;;;QAET6E,SAAA,CAAA6S,IAAA,wBAAA1X,GAAS,IAACyT,KAAK;;;4CAAazT,GAAM;;;QAAY6E,SAAA,CAAA6S,IAAA,uBAAA1X,GAAS,IAAC8U,CAAC;;;QAAWjQ,SAAA,CAAA6S,IAAA,sBAAA1X,GAAS,IAACkU,CAAC;;+IAH5ElU,GAAK;;oDAEFA,GAAK,IAACqG,IAAI,KAAK,WAAW;;;QAEhCJ,YAAA,CAAAyR,IAAA,yBAAA1X,GAAS,oBAAIA,GAAS;;;;;;6DAEXA,GAAS;;;iEACVA,GAAc,aAACA,GAAK,IAACgR,EAAE;;;8DACzBhR,GAAa;;;QACZiG,YAAA,CAAAyR,IAAA,8BAAA1X,GAAK,IAAC4X,WAAW;;;;;;;;;;;;;;;;;;;AA7QpC,IAAAE,SAAS,GAAG,IAAI;;;AAqCd,MAAAC,2BAA2B,GAAG,EAAE;;;AAEhC,MAAAC,wBAAwB,GAAG,EAAE;SAG1BC,WAAWA,CAACtU,KAAiB,EAAEiR,IAAa;;IAE7CtB,IAAI,EAAE3P,KAAK,CAACoR,OAAO,GAAGH,IAAI,CAACtB,IAAI,GAAG,CAAC,GAAGyE,2BAA2B;IACjEnE,GAAG,EAAEjQ,KAAK,CAACqR,OAAO,GAAGJ,IAAI,CAAChB,GAAG,GAAG,CAAC,GAAGmE,2BAA2B;IAC/DvE,KAAK,EAAE7P,KAAK,CAACoR,OAAO,GAAGH,IAAI,CAACtB,IAAI,GAAGsB,IAAI,CAACnB,KAAK,GAAGsE,2BAA2B;IAC3EG,MAAM,EAAEvU,KAAK,CAACqR,OAAO,GAAGJ,IAAI,CAAChB,GAAG,GAAGgB,IAAI,CAAClB,MAAM,GAAGqE;;;;;;;;;;IAvD9ChH;EAAgB,IAAAoH,OAAA;;IAChBzE;EAAc,IAAAyE,OAAA;;IACd7E;EAAY,IAAA6E,OAAA;;IACZvE;EAAW,IAAAuE,OAAA;EACX;IAAAC,QAAQ,GAAW;EAAC,IAAAD,OAAA;;IACpB1E;EAAa,IAAA0E,OAAA;EACb;IAAA9D,SAAS,GAAG;EAAK,IAAA8D,OAAA;EAGxB,IAAAE,SAAS,GAAG,KAAK;EACjB,IAAAC,SAAS,GAAG,KAAK;MAEjBC,SAAS;IACTzD,CAAC,EAAExB,IAAI;IACPY,CAAC,EAAEN,GAAG,GAAGwE,QAAQ;IACV3E;EAAA;EAIF,SAAA+E,cAAcA,CAAC1D,CAAC,EAAEZ,CAAC,EAAET,KAAK;IAC1B,KAAA4E,SAAS,KAAKC,SAAS;sBACxBC,SAAS,CAACzD,CAAC,GAAGA,CAAC,EAAAyD,SAAA;sBACfA,SAAS,CAACrE,CAAC,GAAGA,CAAC,EAAAqE,SAAA;sBACfA,SAAS,CAAC9E,KAAK,GAAGA,KAAK,EAAA8E,SAAA;;;EAKvB;IAAA1G,SAAS;IAAEC,QAAQ;IAAEU;EAAiB,CAAK,GAAAnK,UAAU,CAAC,WAAW;;;;EACjE;IAAAoQ,YAAY;IAAEC;EAAa,CAAmB,GAAArQ,UAAU,CAAC,OAAO;EAEpE;IAAAsQ,WAAW;IACXC,iBAAiB;IACjBjG,UAAU;IACVkG,iBAAiB;IACjBC,mBAAmB;IACnBC,kBAAkB;IAClBC;EAAe,CACM,GAAA3Q,UAAU,CAAC,SAAS;;;IACrC4Q,UAAU;IAAEC,GAAG;IAAEC,KAAK;IAAEzG,aAAa;IAAE0G;EAAgB,IAC3D/Q,UAAU,CAAC,UAAU;MAErBgR,aAAa,GAAGD,gBAAgB,CAACC,aAAa;;;;MAO9CC,iBAA0B;EAUxB,MAAAC,mBAAmB,GAAG3D,QAAQ,CAAEjS,KAAiB;;IAE7C,MAAA6V,MAAM,GAAGvB,WAAW,CAACtU,KAAK,EAAE2V,iBAAiB;IAC/C,IAAAE,MAAM,CAAClG,IAAI,IAAIkG,MAAM,CAAChG,KAAK;;MAE3BkF,aAAa,CAACe,QAAQ;QAClBnG,IAAI,EACAoF,aAAa,CAACgB,UAAU,IACvBF,MAAM,CAAClG,IAAI,G,CAAI0E,wBAAwB,GAAGA,wBAAwB;QACvE2B,QAAQ,EAAE;;;IAId,IAAAH,MAAM,CAAC5F,GAAG,IAAI4F,MAAM,CAACtB,MAAM;;MAE3BQ,aAAa,CAACe,QAAQ;QAClB7F,GAAG,EACC8E,aAAa,CAACkB,SAAS,IACtBJ,MAAM,CAAC5F,GAAG,G,CAAIoE,wBAAwB,GAAGA,wBAAwB;QACtE2B,QAAQ,EAAE;;;KAGnB,G;EAEM,SAAAE,IAAIA,CAACra,CAAc;IACf,SAAAsa,MAAMA,CAACnW,KAAK;MACb,IAAAoW,cAAc,GAAG,IAAI;;;MAEnB,MAAAC,SAAS,GAAGC,SAAS,CAACrJ,QAAQ,CAACG,KAAK,CAACwB,UAAU;MACjD,IAAA5O,KAAK,CAACuW,QAAQ;cACRC,SAAS,GAAGlB,UAAU,CAACmB,SAAS,CAAC,KAAK,EAAEzW,KAAK,CAAC0W,UAAU;YAC1DF,SAAS;UACTG,YAAA,IAAAvJ,KAAK,CAACwB,UAAU,GAAG4H,SAAS,CAACpJ,KAAK,CAACC,EAAE,EAAAD,KAAA;UACrCmI,GAAG,CAAClF,KAAK,CAACuG,KAAK,CAACC,SAAS,CAAC,IAAI,EAAEL,SAAS,EAAEH,SAAS;;UAEpDD,cAAc,GAAG,KAAK;;;sBAI9B1B,SAAS,GAAAiC,YAAA,IAAGhC,SAAS,GAAG,KAAK;MAEvB,MAAAhG,IAAI,GAAGmI,UAAU,CAAC7J,QAAQ,CAACG,KAAK,CAACC,EAAE;aAClC0J,kBAAkB,CAAC3J,KAAK,CAACC,EAAE;UAE9B+I,cAAc;cACRY,QAAQ,GAAG5J,KAAK,CAACrM,IAAI;cACrBkW,MAAM,GAAG7J,KAAK,CAACiC,EAAE;QACjB,MAAA6H,OAAO,GAAIP,YAAA,IAAAvJ,KAAK,CAACrM,IAAI,GAAGyU,KAAK,CAAC2B,OAAO,CACvCpI,aAAa,CAACqI,iBAAiB,CAACpX,KAAK,CAACmR,CAAC,IAAA/D,KAAA;QAErC,MAAAiK,KAAK,GAAAV,YAAA,IAAIvJ,KAAK,CAACiC,EAAE,GAAGmG,KAAK,CAAC2B,OAAO,CACnCpI,aAAa,CAACqI,iBAAiB,CAACpX,KAAK,CAACmR,CAAC,GAAGnR,KAAK,CAAC8P,KAAK,IAAA1C,KAAA;QAEnD,MAAAkK,OAAO,GAAGvI,aAAa,CAACa,iBAAiB,CAACsH,OAAO,IAAI,CAAC;QACtD,MAAAK,QAAQ,GAAGxI,aAAa,CAACa,iBAAiB,CAACyH,KAAK,IAAI,CAAC;QAErD,MAAAb,SAAS,GAAGF,SAAS,CAACrJ,QAAQ,CAACG,KAAK,CAACwB,UAAU;QAC/C,MAAAe,IAAI,GAAG2H,OAAO;cACdxH,KAAK,GAAGyH,QAAQ,GAAGD,OAAO;QAC1B,MAAArH,GAAG,GAAGuH,WAAW,GAAGhB,SAAS,CAACjG,CAAC;QAErCsE,cAAc,CAAClF,IAAI,EAAEM,GAAG,GAAGwE,QAAQ,EAAE3E,KAAK;cAEpC2H,OAAO;UAAA,GACN9I,IAAI;UACDgB,IAAI;UACHG,KAAK;UACPG,GAAG;UACR7C;QAAA;cAGEsK,OAAO,GACTV,QAAQ,IAAIE,OAAO,IACnBD,MAAM,IAAII,KAAK,IACdhB,SAAS,IAAIA,SAAS,CAACjJ,KAAK,CAACC,EAAE,KAAKmJ,SAAS,CAACpJ,KAAK,CAACC,EAAE;YACvDqK,OAAO;UACPnC,GAAG,CAAClF,KAAK,CAACuG,KAAK,CAACe,MAAM,CAAG;YAAAhJ,IAAI,EAAE8I,OAAO;YAAEpB,SAAS;YAAEG;UAAS;;QAEhEf,gBAAgB,CAACmC,sBAAsB,CAAC1b,IAAI,CAACub,OAAO;YAEhDC,OAAO;UACPnC,GAAG,CAAClF,KAAK,CAACuG,KAAK,CAACc,OAAO,CAAG;YAAA/I,IAAI,EAAE8I,OAAO;YAAEpB,SAAS;YAAEG;UAAS;;;;QAI7D,IAAAiB,OAAO,CAACtH,WAAW;UACnBsF,gBAAgB,CAACoC,cAAc,CAAC3b,IAAI,CAAI,GAAAub,OAAO,CAACtH,WAAW;;cAGzD2H,cAAc;YAChB1C,kBAAkB,IAAIoB,SAAS,CAACuB,WAAW;UACtC,KAAAN,OAAO,CAACtH,WAAW,EAAEsH,OAAO,CAACtH,WAAW;gBAEvC6H,IAAI;YAAKhJ,UAAU,EAAEwI;UAAW;UACtChB,SAAS,CAACuB,WAAW,CAAC5d,OAAO,CAACwM,CAAC;YACrB,MAAAsR,aAAa,GAAGzH,WAAW,CAACiH,OAAO,EAAE9Q,CAAC,EAAEqR,IAAI;YAClDP,OAAO,CAACtH,WAAW,CAACjU,IAAI,CAAC+b,aAAa,CAAC7K,KAAK,CAACC,EAAE;YAC/CyK,cAAc,CAAC5b,IAAI,CAAC+b,aAAa;;;QAIrC,IAAA9C,mBAAmB,IAAIqB,SAAS,CAAC0B,UAAU,CAAC/c,MAAM,GAAG,CAAC;UACjD,KAAAsc,OAAO,CAACtH,WAAW,EAAEsH,OAAO,CAACtH,WAAW;gBAEvC6H,IAAI;YAAKhJ,UAAU,EAAEwI;UAAW;UACtChB,SAAS,CAAC0B,UAAU,CAAC/d,OAAO,CAACwM,CAAC;YACpB,MAAAsR,aAAa,GAAGzH,WAAW,CAACiH,OAAO,EAAE9Q,CAAC,EAAEqR,IAAI;YAClDP,OAAO,CAACtH,WAAW,CAACjU,IAAI,CAAC+b,aAAa,CAAC7K,KAAK,CAACC,EAAE;YAC/CyK,cAAc,CAAC5b,IAAI,CAAC+b,aAAa;;;YAIrCH,cAAc,CAAC3c,MAAM,GAAG,CAAC;UACzBsa,gBAAgB,CAACmC,sBAAsB,CAAC1b,IAAI,IAAI4b,cAAc;;cAG5DtB,SAAS,CAAC0B,UAAU,CAAC/c,MAAM,GAAG,CAAC,MAAMqb,SAAS,CAACuB,WAAW;UAC5DN,OAAO,CAACtH,WAAW,GAAG,IAAI;;;;wBAI7ByE,SAAS,CAACzD,CAAC,GAAGxC,IAAI,CAACgB,IAAI,EAAAiF,SAAA,GAAA+B,YAAA,IAAI/B,SAAS,CAAC9E,KAAK,GAAGnB,IAAI,CAACmB,KAAK,EAAI8E,SAAA,GAAA+B,YAAA,IAAA/B,SAAS,CAACrE,CAAC,GAAG5B,IAAI,CAACsB,GAAG,EAAA2E,SAAA;;;SAIrFlE,SAAS;;MAEV+E,gBAAgB,CAAC0C,YAAY,CAAC/Z,GAAG,CAACgP,KAAK,CAACC,EAAE,CAAC+K,QAAQ;QAC/CC,MAAM,EAAErY,KAAK;UACT2V,iBAAiB,GAAGZ,aAAa,CAAC7D,qBAAqB;UACnD,IAAAlR,KAAK,CAACuW,QAAQ;YACd3E,SAAS,CAAC,MAAM;;UAEhB,IAAA5R,KAAK,CAACsY,QAAQ;YACd1G,SAAS,CAAC,UAAU;;UAExB1T,eAAA,CAAA2Q,iBAAA,EAAAkI,kBAAkB,CAAC3J,KAAK,CAACC,EAAE,IAAI,IAAI,EAAA0J,kBAAA;;QAEvCwB,SAAS,EAAAA,CAAA;UACL3G,SAAS,CAAC,SAAS;UACnB2D,GAAG,CAAClF,KAAK,CAACuG,KAAK,CAAC4B,OAAO,CAACpL,KAAK;;QAEjCqL,QAAQ,EAAEzY,KAAK;UACX2W,YAAA,IAAA/B,SAAS,CAACzD,CAAC,GAAGnR,KAAK,CAACmR,CAAC,EAAAyD,SAAA;UACrB+B,YAAA,IAAA/B,SAAS,CAAC9E,KAAK,GAAG9P,KAAK,CAAC8P,KAAK,EAAA8E,SAAA;UAC7B+B,YAAA,IAAAhC,SAAS,GAAG,IAAI;UAChBiB,mBAAmB,CAAC5V,KAAK,CAACA,KAAK;;QAEnC0Y,MAAM,EAAE1Y,KAAK;UACT2W,YAAA,IAAA/B,SAAS,CAACzD,CAAC,GAAGnR,KAAK,CAACmR,CAAC,EAAAyD,SAAA;UACrB+B,YAAA,IAAA/B,SAAS,CAACrE,CAAC,GAAGvQ,KAAK,CAACuQ,CAAC,EAAAqE,SAAA;UACrB+B,YAAA,IAAAjC,SAAS,GAAG,IAAI;UAChBa,GAAG,CAAClF,KAAK,CAACuG,KAAK,CAAC+B,IAAI,CAACvL,KAAK;UAC1BwI,mBAAmB,CAAC5V,KAAK,CAACA,KAAK;;QAEnC4Y,WAAW,EAAAA,CAAA;UAEH,OAAAtC,SAAS,CAACrJ,QAAQ,CAACG,KAAK,CAACwB,UAAU,CAAE,CAAAxB,KAAK,CAACsC,cAAc,IACzDtC,KAAK,CAACsC,cAAc;;QAG5BmJ,aAAa,EAAAA,CAAA;UAEL,OAAAzL,KAAK,CAAC1K,IAAI,KAAK,WAAW,IAC1B4T,SAAS,CAACrJ,QAAQ,CAACG,KAAK,CAACwB,UAAU,EAAExB,KAAK,CAACsC,cAAc,IACzDtC,KAAK,CAACsC,cAAc;;QAGpByG,MAAM;QACd2C,SAAS,EAAEhE,YAAY;QACvBG,iBAAiB;QACjB8D,IAAI,EAAAA,CAAA,KAAQnE,SAAS,CAACzD,CAAC;QACvB6H,IAAI,EAAAA,CAAA,KAAQpE,SAAS,CAACrE,CAAC;QACvB0I,QAAQ,EAAAA,CAAA,KAAQrE,SAAS,CAAC9E,KAAK;QAC/BoJ,OAAO,EAAE9L,KAAK,CAACC;;;QAIf9O,OAAO,EAAAA,CAAA,KAAQkX,gBAAgB,CAAC0C,YAAY,CAACnR,MAAM,CAACoG,KAAK,CAACC,EAAE,CAAC+K,QAAQ;;;;WAKxEe,WAAWA,CAACza,IAAI,EAAE0O,KAAK;QACxBiI,eAAe;aACRA,eAAe,CAAC3W,IAAI,EAAE0O,KAAK;;;EAIjC,SAAAgM,OAAOA,CAACpZ,KAAiB;QAC1BkV,iBAAiB;MACjBA,iBAAiB,CAAC9H,KAAK,EAAEpN,KAAK;;;MAIlCoP,OAAO;MAKPiK,aAAsB;;;;;;;;;;;;MAjPvBxE,cAAc,CAAClF,IAAI,EAAEM,GAAG,GAAGwE,QAAQ,EAAE3E,KAAK;;;MA6O5C;QACG6G,YAAA,IAAAvH,OAAO,GAAG2C,kBAAkB,CAAC3E,KAAK,CAACgC,OAAO;;;;MAI7C;wBACGiK,aAAa,GAAGjM,KAAK,CAAC1K,IAAI,KAAK,WAAW,IAAI4T,SAAS,CAACrJ,QAAQ,CAACG,KAAK,CAACwB,UAAU,CAAE,CAAAxB,KAAK,CAACsC,cAAc,IAAItC,KAAK,CAACsC,cAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;yBC5PxHrT,GAAG,IAAC+Q,KAAK,CAACkM,WAAW;;;;;;;;;;;;;gEAArBjd,GAAG,IAAC+Q,KAAK,CAACkM,WAAW,QAAApG,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;wBAD3B5W,GAAG,IAAC+Q,KAAK,CAACkM,WAAW,IAAAC,iBAAA,CAAAld,GAAA;;;;;8DANXA,GAAG,IAAC+Q,KAAK,CAACgC,OAAO;8DACnB/S,GAAG,IAAC+Q,KAAK,CAACC,EAAE;6CAGVhR,GAAU;MAFTiG,YAAA,CAAAyQ,GAAA,6BAAA1W,GAAW,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;MACxB/K,YAAA,CAAAyQ,GAAA,iCAAA1W,GAAY,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;MAJnDzO,MAUM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;kBAHGxC,GAAG,IAAC+Q,KAAK,CAACkM,WAAW;;;;;;;;;;;;wFANXjd,GAAG,IAAC+Q,KAAK,CAACgC,OAAO;;;wFACnB/S,GAAG,IAAC+Q,KAAK,CAACC,EAAE;;;;+CAGVhR,GAAU;;;QAFTiG,YAAA,CAAAyQ,GAAA,6BAAA1W,GAAW,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;QACxB/K,YAAA,CAAAyQ,GAAA,iCAAA1W,GAAY,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;;;;;;;;;;;;;;;;IATpCiD;EAAc,IAAAkE,OAAA;;IACjBgF;EAAS,IAAK9U,UAAU,CAAC,SAAS;;EAClC;IAAA+U,UAAU;IAAEC;EAAW,CAAK,GAAAhV,UAAU,CAAC,OAAO;;;;;;;;;;;;;;;;;;;;;;;ECwBhB,IAAAsO,OAAA,YAAA3W,GAAK,IAACiT,KAAK;;;;;;;;;MAA7C1Q,MAAoD,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;MAAlB,IAAAlC,KAAA,iBAAAqW,OAAA,MAAAA,OAAA,YAAA3W,GAAK,IAACiT,KAAK,QAAArO,QAAA,CAAAkC,CAAA,EAAA6P,OAAA;;;;;;;;;;;;EAD5C,IAAA2G,QAAA,YAAAtd,GAAK,IAACiT,KAAK,IAAAsK,iBAAA,CAAAvd,GAAA;;;;;yEAJMA,GAAO;MAEf6E,SAAA,CAAA6R,GAAA,wBAAA1W,GAAS,IAACyT,KAAK;MAAU5O,SAAA,CAAA6R,GAAA,uBAAA1W,GAAS,IAAC8U,CAAC;8CADpC9U,GAAQ;;;MAF1BuC,MAQM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;MAHG,cAAAxC,GAAK,IAACiT,KAAK;;;;;;;;;;;;uGAJMjT,GAAO;;;;QAEf6E,SAAA,CAAA6R,GAAA,wBAAA1W,GAAS,IAACyT,KAAK;;;QAAU5O,SAAA,CAAA6R,GAAA,uBAAA1W,GAAS,IAAC8U,CAAC;;;gDADpC9U,GAAQ;;;;;;;;;;;;;;;IAtBX+Q;EAAK,IAAAoH,OAAA;;IACL7E;EAAI,IAAA6E,OAAA;;IACJ1E;EAAK,IAAA0E,OAAA;EACL;IAAA8D,QAAQ,GAAG;EAAK,IAAA9D,OAAA;EAErB,MAAAI,SAAS,GACX;IAAA9E,KAAK;IACLqB,CAAC,EAAExB;EAAA;MAOHP,OAAO;;;;;;;;;MALV;wBACGwF,SAAS,CAACzD,CAAC,GAAGxB,IAAI,EAAAiF,SAAA;wBAClBA,SAAS,CAAC9E,KAAK,GAAGA,KAAK,EAAA8E,SAAA;;;;MAI1B;QACG+B,YAAA,IAAAvH,OAAO,GAAG2C,kBAAkB,CAAC3E,KAAK,CAACgC,OAAO;;;;;;;;;;;;;;;;;ACnB3C,MAAMyK,UAAU,GAAG,CAAC;AACpB,MAAMC,UAAU,GAAG,CAAC;;ACmD3B;;AAEG;MACUC,SAAS;EAClBC,cAAc;EACdC,cAAc;EACdC,eAAe;EAEfC,SAAS;EACT5D,QAAQ,GAAG,KAAK;EAChB+B,QAAQ,GAAG,KAAK;EAEhB8B,QAAQ;EACRC,QAAQ;EACRC,QAAQ;EACRC,eAAe,GAAG,KAAK;EAEvBC,QAAQ;EACR9b,IAAI;EAEJ+b,SAAS,GAAc;IAAEtJ,CAAC,EAAE,IAAI;IAAEZ,CAAC,EAAE;EAAI,CAAE;EAC3CmK,WAAW,GAAW,IAAI;EAC1BC,iBAAiB;EAEjBvX,YAAY1E,IAAiB,EAAE8b,QAA2B,EAAEI,UAAuB;IAC/E,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC9b,IAAI,GAAGA,IAAI;IAEhB,IAAI,IAAI,CAAC8b,QAAQ,CAACtB,OAAO,EAAE;MACvB,IAAI,CAACuB,SAAS,GAAGG,UAAU,CAACH,SAAS;MACrC,IAAI,CAACC,WAAW,GAAGE,UAAU,CAACF,WAAW;IAC5C,OAAM;MACHhc,IAAI,CAACyB,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC0a,WAAW,EAAE;QAAEC,OAAO,EAAE;MAAI,CAAE,CAAC;IAC1E;;EAGL,IAAIlC,WAAWA,CAAA;IACX,IAAI,OAAO,IAAI,CAAC4B,QAAQ,CAAC5B,WAAW,KAAK,UAAU,EAAE;MACjD,OAAO,IAAI,CAAC4B,QAAQ,CAAC5B,WAAW,EAAE;IACrC,OAAM;MACH,OAAO,IAAI,CAAC4B,QAAQ,CAAC5B,WAAW;IACnC;;EAGL,IAAIC,aAAaA,CAAA;IACb,IAAI,OAAO,IAAI,CAAC2B,QAAQ,CAAC3B,aAAa,KAAK,UAAU,EAAE;MACnD,OAAO,IAAI,CAAC2B,QAAQ,CAAC3B,aAAa,EAAE;IACvC,OAAM;MACH,OAAO,IAAI,CAAC2B,QAAQ,CAAC3B,aAAa;IACrC;;EAGLgC,WAAW,GAAG7a,KAAK,IAAG;IAClB,MAAM+a,WAAW,GAAG;MAChB3J,OAAO,EAAE,IAAI,CAACqJ,SAAS,CAACtJ,CAAC,GAAGnR,KAAK,CAACoR,OAAO;MACzCC,OAAO,EAAE,IAAI,CAACoJ,SAAS,CAAClK,CAAC,GAAGvQ,KAAK,CAACqR;KACrC;IAED,IAAI,CAACP,WAAW,CAAC9Q,KAAK,CAAC,IAAI,CAAC,IAAI,CAACwa,QAAQ,CAACtB,OAAO,EAAE;MAC/C;IACH;IAED,IAAI,CAAC,IAAI,CAACsB,QAAQ,CAACtB,OAAO,EAAE;MACxBlZ,KAAK,CAACM,eAAe,EAAE;MACvBN,KAAK,CAACgb,cAAc,EAAE;IACzB;IAED,MAAMC,OAAO,GAAG,IAAI,CAACrC,WAAW;IAChC,MAAMsC,SAAS,GAAG,IAAI,CAACrC,aAAa;IAEpC,IAAIoC,OAAO,IAAIC,SAAS,EAAE;MACtB,MAAM/J,CAAC,GAAG,IAAI,CAACqJ,QAAQ,CAACzB,IAAI,EAAE;MAC9B,MAAMxI,CAAC,GAAG,IAAI,CAACiK,QAAQ,CAACxB,IAAI,EAAE;MAC9B,MAAMlJ,KAAK,GAAG,IAAI,CAAC0K,QAAQ,CAACvB,QAAQ,EAAE;MAEtC,IAAI,CAACmB,QAAQ,GAAGW,WAAW,CAAC3J,OAAO;MACnC,IAAI,CAACiJ,QAAQ,GAAGU,WAAW,CAAC1J,OAAO;MAEnC,IAAI,CAAC6I,eAAe,GAAG/I,CAAC,GAAGrB,KAAK;MAEhC,IAAI,CAACkK,cAAc,GAAGhJ,cAAc,CAAC,IAAI,CAACwJ,QAAQ,CAAC1B,SAAS,EAAEiC,WAAW,CAAC,CAAC5J,CAAC,GAAGA,CAAC;MAChF,IAAI,CAAC8I,cAAc,GAAGjJ,cAAc,CAAC,IAAI,CAACwJ,QAAQ,CAAC1B,SAAS,EAAEiC,WAAW,CAAC,CAACxK,CAAC,GAAGA,CAAC;MAEhF,IAAI2K,SAAS,IAAI,IAAI,CAAClB,cAAc,IAAI,IAAI,CAACQ,QAAQ,CAACvF,iBAAiB,EAAE;QACrE,IAAI,CAACkF,SAAS,GAAG,MAAM;QACvB,IAAI,CAAC7B,QAAQ,GAAG,IAAI;MACvB;MAED,IACI4C,SAAS,IACT,IAAI,CAAClB,cAAc,IAAIlK,KAAK,GAAG,IAAI,CAAC4K,WAAW,GAAG,IAAI,CAACF,QAAQ,CAACvF,iBAAiB,EACnF;QACE,IAAI,CAACkF,SAAS,GAAG,OAAO;QACxB,IAAI,CAAC7B,QAAQ,GAAG,IAAI;MACvB;MAED,IAAI2C,OAAO,IAAI,CAAC,IAAI,CAAC3C,QAAQ,EAAE;QAC3B,IAAI,CAAC/B,QAAQ,GAAG,IAAI;MACvB;MAED,IAAI,CAAC,IAAI,CAACA,QAAQ,IAAI,IAAI,CAAC+B,QAAQ,KAAK,IAAI,CAACkC,QAAQ,CAACnC,MAAM,EAAE;QAC1D,IAAI,CAACmC,QAAQ,CAACnC,MAAM,CAAC;UACjB3B,UAAU,EAAEqE,WAAW;UACvB5J,CAAC;UACDrB,KAAK;UACLS,CAAC;UACD+H,QAAQ,EAAE,IAAI,CAACA,QAAQ;UACvB/B,QAAQ,EAAE,IAAI,CAACA;QAClB,EAAC;MACL;MAED,IAAI,CAAC,IAAI,CAACiE,QAAQ,CAACtB,OAAO,EAAE;QACxBxX,MAAM,CAACvB,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACgb,WAAW,EAAE,KAAK,CAAC;QAC7D7J,oBAAoB,CAAC5P,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC0Z,SAAS,CAAC;MAC1D;IACJ;EACL,CAAC;EAEDD,WAAW,GAAInb,KAAiB,IAAI;IAChC,MAAM+a,WAAW,GAAG;MAChB3J,OAAO,EAAE,IAAI,CAACqJ,SAAS,CAACtJ,CAAC,GAAGnR,KAAK,CAACoR,OAAO;MACzCC,OAAO,EAAE,IAAI,CAACoJ,SAAS,CAAClK,CAAC,GAAGvQ,KAAK,CAACqR;KACrC;IAED,IAAI,CAAC,IAAI,CAACkJ,eAAe,EAAE;MACvB,IACIxd,IAAI,CAACuL,GAAG,CAACyS,WAAW,CAAC3J,OAAO,GAAG,IAAI,CAACgJ,QAAQ,CAAC,GAAGP,UAAU,IAC1D9c,IAAI,CAACuL,GAAG,CAACyS,WAAW,CAAC1J,OAAO,GAAG,IAAI,CAACgJ,QAAQ,CAAC,GAAGP,UAAU,EAC5D;QACE,IAAI,CAACS,eAAe,GAAG,IAAI;MAC9B,OAAM;QACH;MACH;IACJ;IAEDva,KAAK,CAACgb,cAAc,EAAE;IAEtB,IAAI,IAAI,CAAC1C,QAAQ,EAAE;MACf,MAAM+C,QAAQ,GAAGrK,cAAc,CAAC,IAAI,CAACwJ,QAAQ,CAAC1B,SAAS,EAAEiC,WAAW,CAAC;MACrE,MAAM5J,CAAC,GAAG,IAAI,CAACqJ,QAAQ,CAACzB,IAAI,EAAE;MAC9B,MAAMjJ,KAAK,GAAG,IAAI,CAAC0K,QAAQ,CAACvB,QAAQ,EAAE;MAEtC,IAAIqC,OAAe;MACnB,IAAIC,WAAmB;MAEvB,IAAI,IAAI,CAACpB,SAAS,KAAK,MAAM,EAAE;;QAE3B,IAAI,IAAI,CAACQ,iBAAiB,KAAK,MAAM,EAAE;UACnCU,QAAQ,CAAClK,CAAC,IAAI,IAAI,CAACuJ,WAAW;QACjC;QAED,IAAI,IAAI,CAACR,eAAe,GAAGmB,QAAQ,CAAClK,CAAC,IAAI,CAAC,EAAE;UACxC,IAAI,CAACgJ,SAAS,GAAG,OAAO;UACxB,IAAI,IAAI,CAACQ,iBAAiB,KAAK,MAAM,EAAE;YACnC,IAAI,CAACA,iBAAiB,GAAG,OAAO;UACnC,OAAM;YACH,IAAI,CAACA,iBAAiB,GAAGnf,SAAS;UACrC;UAED8f,OAAO,GAAG,IAAI,CAACpB,eAAe;UAC9BqB,WAAW,GAAG,IAAI,CAACrB,eAAe,GAAGmB,QAAQ,CAAClK,CAAC;UAC/C,IAAI,CAAC+I,eAAe,GAAG,IAAI,CAACA,eAAe,GAAGpK,KAAK;QACtD,OAAM;UACHwL,OAAO,GAAGD,QAAQ,CAAClK,CAAC;UACpBoK,WAAW,GAAG,IAAI,CAACrB,eAAe,GAAGmB,QAAQ,CAAClK,CAAC;QAClD;MACJ,OAAM,IAAI,IAAI,CAACgJ,SAAS,KAAK,OAAO,EAAE;;QAEnC,IAAI,IAAI,CAACQ,iBAAiB,KAAK,OAAO,EAAE;UACpCU,QAAQ,CAAClK,CAAC,IAAI,IAAI,CAACuJ,WAAW;QACjC;QAED,IAAIW,QAAQ,CAAClK,CAAC,GAAGA,CAAC,GAAG,IAAI,CAACuJ,WAAW,IAAI,CAAC,EAAE;UACxC,IAAI,CAACP,SAAS,GAAG,MAAM;UAEvB,IAAI,IAAI,CAACQ,iBAAiB,KAAK,OAAO,EAAE;YACpC,IAAI,CAACA,iBAAiB,GAAG,MAAM;UAClC,OAAM;YACH,IAAI,CAACA,iBAAiB,GAAGnf,SAAS;UACrC;UAED8f,OAAO,GAAGD,QAAQ,CAAClK,CAAC,GAAG,IAAI,CAACuJ,WAAW;UACvCa,WAAW,GAAGF,QAAQ,CAAClK,CAAC,GAAGA,CAAC,GAAG,IAAI,CAACuJ,WAAW;UAC/C,IAAI,CAACR,eAAe,GAAG/I,CAAC;QAC3B,OAAM;UACHmK,OAAO,GAAGnK,CAAC;UACXoK,WAAW,GAAGF,QAAQ,CAAClK,CAAC,GAAGA,CAAC,GAAG,IAAI,CAACuJ,WAAW;QAClD;MACJ;MAED,IAAI,IAAI,CAACF,QAAQ,CAAC/B,QAAQ,EAAE;QACxB,IAAI,CAAC+B,QAAQ,CAAC/B,QAAQ,CAAC;UACnBtH,CAAC,EAAEmK,OAAO;UACVxL,KAAK,EAAEyL,WAAW;UAClBvb;QACH,EAAC;MACL;IACJ;;IAGD,IAAI,IAAI,CAACuW,QAAQ,IAAI,IAAI,CAACiE,QAAQ,CAAC9B,MAAM,EAAE;MACvC,MAAM2C,QAAQ,GAAGrK,cAAc,CAAC,IAAI,CAACwJ,QAAQ,CAAC1B,SAAS,EAAEiC,WAAW,CAAC;MAErE,IAAI,CAACP,QAAQ,CAAC9B,MAAM,CAAC;QACjBvH,CAAC,EAAEkK,QAAQ,CAAClK,CAAC,GAAG,IAAI,CAAC6I,cAAc;QACnCzJ,CAAC,EAAE8K,QAAQ,CAAC9K,CAAC,GAAG,IAAI,CAAC0J,cAAc;QACnCja;MACH,EAAC;IACL;EACL,CAAC;EAEDob,SAAS,GAAIpb,KAAiB,IAAI;IAC9B,MAAM+a,WAAW,GAAG;MAChB3J,OAAO,EAAE,IAAI,CAACqJ,SAAS,CAACtJ,CAAC,GAAGnR,KAAK,CAACoR,OAAO;MACzCC,OAAO,EAAE,IAAI,CAACoJ,SAAS,CAAClK,CAAC,GAAGvQ,KAAK,CAACqR;KACrC;IAED,MAAMF,CAAC,GAAG,IAAI,CAACqJ,QAAQ,CAACzB,IAAI,EAAE;IAC9B,MAAMxI,CAAC,GAAG,IAAI,CAACiK,QAAQ,CAACxB,IAAI,EAAE;IAC9B,MAAMlJ,KAAK,GAAG,IAAI,CAAC0K,QAAQ,CAACvB,QAAQ,EAAE;IAEtC,IAAI,CAACuB,QAAQ,CAACjC,SAAS,IAAI,IAAI,CAACiC,QAAQ,CAACjC,SAAS,EAAE;IAEpD,IAAI,IAAI,CAACgC,eAAe,IAAI,IAAI,CAACC,QAAQ,CAACrE,MAAM,EAAE;MAC9C,IAAI,CAACqE,QAAQ,CAACrE,MAAM,CAAC;QACjBO,UAAU,EAAEqE,WAAW;QACvB5J,CAAC;QACDZ,CAAC;QACDT,KAAK;QACLyG,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvB+B,QAAQ,EAAE,IAAI,CAACA;MAClB,EAAC;IACL;IAED,IAAI,CAAC0B,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,eAAe,GAAG,IAAI;IAE3B,IAAI,CAAC3D,QAAQ,GAAG,KAAK;IACrB,IAAI,CAAC+B,QAAQ,GAAG,KAAK;IAErB,IAAI,CAAC8B,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,eAAe,GAAG,KAAK;IAE5B,IAAI,CAACE,SAAS,GAAG;MAAEtJ,CAAC,EAAE,IAAI;MAAEZ,CAAC,EAAE;IAAI,CAAE;IACrC,IAAI,CAACmK,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,iBAAiB,GAAGnf,SAAS;IAElC,IAAI,CAAC,IAAI,CAACgf,QAAQ,CAACtB,OAAO,EACtBxX,MAAM,CAACtB,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC+a,WAAW,EAAE,KAAK,CAAC;EACxE,CAAC;EAED5c,OAAOA,CAAA;IACH,IAAI,CAACG,IAAI,CAAC0B,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAACya,WAAW,EAAE,KAAK,CAAC;IACnE,IAAI,CAACnc,IAAI,CAAC0B,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC+a,WAAW,EAAE,KAAK,CAAC;IACnE,IAAI,CAACzc,IAAI,CAAC0B,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACgb,SAAS,EAAE,KAAK,CAAC;;AAEtE;MCjTYI,eAAe;EACxBC,UAAU,GAAmC,EAAE;EAE/CrY,YAAY+K,QAAgC;IACxC,IAAI,CAACuN,QAAQ,CAAC,KAAK,EAAE1b,KAAK,IAAG;MACzB,IAAI2b,QAAQ,GAAG9gB,QAAQ,CAAC+gB,iBAAiB,CAAC5b,KAAK,CAACoR,OAAO,EAAEpR,KAAK,CAACqR,OAAO,CAAC;MACvE,IAAIwK,UAAU,GAAGF,QAAQ,CAACG,IAAI,CAACxc,OAAO,IAAI,CAAC,CAACA,OAAO,CAACqB,YAAY,CAAC,aAAa,CAAC,CAAC;MAChF,IAAIkb,UAAU,KAAKrgB,SAAS,EAAE;QAC1B,MAAMugB,KAAK,GAAGF,UAAU,CAAClb,YAAY,CAAC,aAAa,CAAC;QACpD,MAAM;UAAEsM;QAAQ,CAAE,GAAGtR,eAAG,CAACwS,QAAQ,CAAC;QAClC,MAAMqI,SAAS,GAAGvJ,QAAQ,CAAC8O,KAAK,CAAC;QAEjC,IAAIvF,SAAS,CAACpJ,KAAK,CAACsC,cAAc,EAAE;UAChC,OAAO8G,SAAS;QACnB;MACJ;MACD,OAAO,IAAI;IACf,CAAC,CAAC;;EAGNkF,QAAQA,CAACjd,MAAc,EAAEwB,OAAoB;IACzC,IAAI,CAACwb,UAAU,CAAChd,MAAM,CAAC,GAAGwB,OAAO;;EAGrCwW,SAASA,CAAChY,MAAc,EAAEuB,KAAiB;IACvC,IAAIC,OAAO,GAAG,IAAI,CAACwb,UAAU,CAAChd,MAAM,CAAC;IAErC,IAAIwB,OAAO,EAAE;MACT,OAAOA,OAAO,CAACD,KAAK,CAAC;IACxB;;AAER;;;;;;;;;;;;;;;;;;;;;;mFC0DiC3D,GAAO;MACvB6E,SAAA,CAAA8a,IAAA,wBAAA3f,GAAS,IAACyT,KAAK;MAAU5O,SAAA,CAAA8a,IAAA,uBAAA3f,GAAS,IAAC8U,CAAC;oEACnB9U,GAAW;;;MAH9CuC,MAOM,CAAAH,MAAA,EAAAud,IAAA,EAAAnd,MAAA;MAFFL,MAAsD,CAAAwd,IAAA,EAAA9H,IAAA;;MACtD1V,MAAuD,CAAAwd,IAAA,EAAAjI,IAAA;;;;;;;iHALzB1X,GAAO;;;;QACvB6E,SAAA,CAAA8a,IAAA,wBAAA3f,GAAS,IAACyT,KAAK;;;QAAU5O,SAAA,CAAA8a,IAAA,uBAAA3f,GAAS,IAAC8U,CAAC;;;sEACnB9U,GAAW;;;;;;;;;;;;;;;;IA1FlCyY;EAAY,IAAmBpQ,UAAU,CAAC,OAAO;EACjD;IAAA6Q,GAAG;IAAEC,KAAK;IAAEzG;EAAa,CAA2B,GAAArK,UAAU,CAAC,UAAU;;IACzEuQ;EAAiB,IAA0BvQ,UAAU,CAAC,SAAS;;IAC/D0J;EAAc,IAAK1J,UAAU,CAAC,WAAW;;IAEtC0I;EAAK,IAAAoH,OAAA;;IACL1E;EAAK,IAAA0E,OAAA;;IACL7E;EAAI,IAAA6E,OAAA;EAET,MAAAI,SAAS,GACX;IAAA9E,KAAK;IACLqB,CAAC,EAAExB;EAAA;EAME,SAAAuG,IAAIA,CAACxX,IAAI;IACR,MAAAud,MAAM,GAAGjc,KAAK;YACVkX,OAAO,GAAG1B,KAAK,CAAC2B,OAAO,CAACpI,aAAa,CAACqI,iBAAiB,CAACpX,KAAK,CAACmR,CAAC;MAC/D,MAAAkG,KAAK,GAAG7B,KAAK,CAAC2B,OAAO,CAACpI,aAAa,CAACqI,iBAAiB,CAACpX,KAAK,CAACmR,CAAC,GAAGnR,KAAK,CAAC8P,KAAK;MAC3E,MAAAwH,OAAO,GAAGvI,aAAa,CAACa,iBAAiB,CAACsH,OAAO;MACjD,MAAAK,QAAQ,GAAGxI,aAAa,CAACa,iBAAiB,CAACyH,KAAK;MAEtDtd,MAAM,CAACP,MAAM,CAAC4T,KAAK;QACfrM,IAAI,EAAEmW,OAAO;QACb7H,EAAE,EAAEgI;MAAA;MAGRxR,MAAM;QACF8J,IAAI,EAAE2H,OAAO;QACbxH,KAAK,EAAEyH,QAAQ,GAAGD,OAAO;QACzBlK,KAAK;QACLkL,QAAQ,EAAE;;MAGd5W,MAAM,CAACtB,mBAAmB,CAAC,WAAW,EAAE+a,WAAW,EAAE,KAAK;;IAGrD,SAAAtV,MAAMA,CAACyH,KAAK;MACjBc,cAAc,CAACvI,MAAM,CAACyH,KAAK;MAC3BqJ,YAAA,IAAA/B,SAAS,CAACzD,CAAC,GAAG7D,KAAK,CAACqC,IAAI,EAAAiF,SAAA;MACxB+B,YAAA,IAAA/B,SAAS,CAAC9E,KAAK,GAAGxC,KAAK,CAACwC,KAAK,EAAA8E,SAAA;;UAG3BsH,SAAS,OAAOnC,SAAS,CAACrb,IAAI,E;MAChC2Z,MAAM,EAAErY,KAAK;QACTuV,GAAG,CAAC4G,UAAU,CAACvF,KAAK,CAACwF,OAAO;UAAGhP;QAAK;QACpCvH,MAAM;UACF8J,IAAI,EAAE3P,KAAK,CAACmR,CAAC;UACbrB,KAAK,EAAE9P,KAAK,CAAC8P,KAAK;UAClB1C,KAAK;UACLkL,QAAQ,EAAE;;;MAGlBG,QAAQ,EAAEzY,KAAK;QACXuV,GAAG,CAAC4G,UAAU,CAACvF,KAAK,CAACyF,OAAO;UAAGjP,KAAK;UAAEuC,IAAI,EAAE3P,KAAK,CAACmR,CAAC;UAAErB,KAAK,EAAE9P,KAAK,CAAC8P;QAAK;QACvEjK,MAAM;UACF8J,IAAI,EAAE3P,KAAK,CAACmR,CAAC;UACbrB,KAAK,EAAE9P,KAAK,CAAC8P,KAAK;UAClB1C,KAAK;UACLkL,QAAQ,EAAE;;;MAGlBM,WAAW,EAAE,KAAK;MAClBC,aAAa,EAAAA,CAAA,KAAQyD,WAAW;MAChCnG,MAAM,EAAE8F,MAAM;MACdnD,SAAS,EAAEhE,YAAY;MACvBG,iBAAiB;MACjB8D,IAAI,EAAAA,CAAA,KAAQnE,SAAS,CAACzD,CAAC;MACvB6H,IAAI,EAAAA,CAAA,KAAQ,CAAC;MACbC,QAAQ,EAAAA,CAAA,KAAQrE,SAAS,CAAC9E;;;MAGrBvR,OAAO,EAAAA,CAAA,KAAQ2d,SAAS,CAAC3d,OAAO;IAAA;;WAGpC+d,WAAWA,CAAA;WACTlP,KAAK,CAACmP,SAAS,KAAK/gB,SAAS,GAAG4R,KAAK,CAACmP,SAAS,GAAG,IAAI;;MAG7DnN,OAAO;;;;;;;;MApEV;wBACIwF,SAAS,CAACzD,CAAC,GAAGxB,IAAI,EAAAiF,SAAA,GAAA+B,YAAA,IAAI/B,SAAS,CAAC9E,KAAK,GAAGA,KAAK,EAAA8E,SAAA;;;;MAoEjD;QACG+B,YAAA,IAAAvH,OAAO,GAAG2C,kBAAkB,CAAC3E,KAAK,CAACgC,OAAO;;;;;;;;;;;;;;;;;;SCzBlCoN,WAAWA,CAACC,IAAY,EAAEC,MAAM,GAAG,CAAC;EAChD,QAAQD,IAAI;IACR,KAAK,GAAG;IACR,KAAK,MAAM;MACP,OAAOC,MAAM,GAAG,WAAW;IAC/B,KAAK,OAAO;MACR,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAAC;;IAE7C,KAAK,MAAM;MACP,OAAOA,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAC3C,KAAK,GAAG;IACR,KAAK,KAAK;MACN,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IACvC,KAAK,GAAG;IACR,KAAK,MAAM;MACP,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAClC,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOA,MAAM,GAAG,EAAE,GAAG,IAAI;IAC7B,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOA,MAAM,GAAG,IAAI;IACxB;MACI,MAAM,IAAIxY,KAAK,CAAC,iBAAiBuY,IAAI,EAAE,CAAC;EAC/C;AACL;AA2CA,SAASE,UAAUA,CAACC,IAAU,EAAEF,MAAM,GAAG,CAAC;EACtCE,IAAI,CAACC,UAAU,CAACD,IAAI,CAACE,UAAU,EAAE,GAAGJ,MAAM,CAAC;EAC3C,OAAOE,IAAI;AACf;AAEA,SAASG,UAAUA,CAACH,IAAU,EAAEF,MAAM,GAAG,CAAC;EACtCE,IAAI,CAACI,UAAU,CAACJ,IAAI,CAACK,UAAU,EAAE,GAAGP,MAAM,CAAC;EAC3C,OAAOE,IAAI;AACf;AAEA,SAASM,QAAQA,CAACN,IAAU,EAAEF,MAAM,GAAG,CAAC;EACpCE,IAAI,CAACO,QAAQ,CAACP,IAAI,CAACQ,QAAQ,EAAE,GAAGV,MAAM,CAAC;EACvC,OAAOE,IAAI;AACf;AAEA,SAASS,OAAOA,CAACT,IAAU,EAAEF,MAAM,GAAG,CAAC;EACnCE,IAAI,CAACU,OAAO,CAACV,IAAI,CAACW,OAAO,EAAE,GAAGb,MAAM,CAAC;EACrCE,IAAI,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACtB,OAAOP,IAAI;AACf;AAEA,SAASY,QAAQA,CAACZ,IAAU,EAAEF,MAAM,GAAG,CAAC;EACpC,MAAMrd,CAAC,GAAGud,IAAI;EACd,MAAMa,GAAG,GAAGpe,CAAC,CAACqe,MAAM,EAAE;EACtB,MAAMC,IAAI,GAAGte,CAAC,CAACke,OAAO,EAAE,GAAGE,GAAG,IAAIA,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;EACrDpe,CAAC,CAACie,OAAO,CAACK,IAAI,CAAC;EACfte,CAAC,CAAC8d,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnB9d,CAAC,CAACie,OAAO,CAACje,CAAC,CAACke,OAAO,EAAE,GAAG,CAAC,GAAGb,MAAM,CAAC;EACnC,OAAOrd,CAAC;AACZ;AAEA,SAASue,SAASA,CAAChB,IAAU,EAAEF,MAAM,GAAG,CAAC;EACrCE,IAAI,CAACiB,QAAQ,CAACjB,IAAI,CAACkB,QAAQ,EAAE,GAAGpB,MAAM,CAAC;EACvCE,IAAI,CAACU,OAAO,CAAC,CAAC,CAAC;EACfV,IAAI,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACtB,OAAOP,IAAI;AACf;AAEA,SAASmB,QAAQA,CAACnB,IAAU,EAAEF,MAAM,GAAG,CAAC;EACpCE,IAAI,CAACoB,WAAW,CAACpB,IAAI,CAACqB,WAAW,EAAE,GAAGvB,MAAM,CAAC;EAC7CE,IAAI,CAACiB,QAAQ,CAAC,CAAC,CAAC;EAChBjB,IAAI,CAACU,OAAO,CAAC,CAAC,CAAC;EACfV,IAAI,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACtB,OAAOP,IAAI;AACf;AAEA,SAASsB,WAAWA,CAACtB,IAAI,EAAEH,IAAI,EAAEC,MAAM;EACnC,QAAQD,IAAI;IACR,KAAK,GAAG;IACR,KAAK,MAAM;MACP,OAAOsB,QAAQ,CAACnB,IAAI,EAAEF,MAAM,CAAC;IACjC,KAAK,OAAO;MACR,OAAOkB,SAAS,CAAChB,IAAI,EAAEF,MAAM,CAAC;IAClC,KAAK,MAAM;MACP,OAAOc,QAAQ,CAACZ,IAAI,EAAEF,MAAM,CAAC;IACjC,KAAK,GAAG;IACR,KAAK,KAAK;MACN,OAAOW,OAAO,CAACT,IAAI,EAAEF,MAAM,CAAC;IAChC,KAAK,GAAG;IACR,KAAK,MAAM;MACP,OAAOQ,QAAQ,CAACN,IAAI,EAAEF,MAAM,CAAC;IACjC,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOK,UAAU,CAACH,IAAI,EAAEF,MAAM,CAAC;IACnC,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOC,UAAU,CAACC,IAAI,EAAEF,MAAM,CAAC;EAGtC;AACL;AAEA,MAAMyB,KAAK,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,QAAQ,CAAC;AACnG;;;;;;;;AAQG;AACa,SAAAC,aAAaA,CACzBrd,IAAY,EACZsO,EAAU,EACVoN,IAAY,EACZC,MAAA,GAAiB,CAAC,EAClB2B,oBAAqB;EAErB,IAAIF,KAAK,CAAC5X,OAAO,CAACkW,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5B,IAAI6B,UAAU,GAAG,CAAC;IAClB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,MAAMhT,KAAK,GAAG,IAAIiT,IAAI,CAACzd,IAAI,CAAC,CAAC;IAC7B,MAAM0d,QAAQ,GAAG,IAAID,IAAI,CAACzd,IAAI,CAAC;IAC/B,IAAI2d,QAAQ,GAAGR,WAAW,CAACO,QAAQ,EAAEhC,IAAI,EAAEC,MAAM,CAAC;IAClD,IAAIiC,OAAO,GAAGD,QAAQ,CAACE,OAAO,EAAE;IAChC,MAAMC,aAAa,GAAGH,QAAQ,CAACE,OAAO,EAAE,GAAG7d,IAAI;IAC/C,MAAM+d,WAAW,GAAG,CAChB;;;MAGI/d,IAAI,EAAEA,IAAI;;;MAGVsO,EAAE,EAAEqP,QAAQ,CAACE,OAAO,EAAE;MACtBG,QAAQ,EAAEF,aAAa;;MAEvBG,aAAa,EAAEX,oBAAoB,IAAIY,cAAc,CAAC1T,KAAK,EAAE8S,oBAAoB;IACpF,EACJ;IAED,IAAIM,OAAO,GAAGtP,EAAE,EAAE;MACd,OAAOsP,OAAO,GAAGtP,EAAE,EAAE;QACjBiP,UAAU,GAAGK,OAAO;QACpBD,QAAQ,GAAGR,WAAW,CAAC,IAAIM,IAAI,CAACG,OAAO,CAAC,EAAElC,IAAI,EAAEC,MAAM,CAAC;QACvD6B,iBAAiB,GAAGG,QAAQ,CAACE,OAAO,EAAE,GAAGD,OAAO;QAEhDG,WAAW,CAAC5iB,IAAI,CAAC;UACb6E,IAAI,EAAE4d,OAAO;UACbtP,EAAE,EAAEqP,QAAQ,CAACE,OAAO,EAAE;UACtBG,QAAQ,EAAER,iBAAiB;;UAE3BS,aAAa,EACTX,oBAAoB,IACpBY,cAAc,CAAC,IAAIT,IAAI,CAACG,OAAO,CAAC,EAAEN,oBAAoB;QAC7D,EAAC;QACFM,OAAO,GAAGD,QAAQ,CAACE,OAAO,EAAE;MAC/B;MACD,MAAMM,iBAAiB,GAAG7P,EAAE,GAAGiP,UAAU;MACzCQ,WAAW,CAACA,WAAW,CAAC3jB,MAAM,GAAG,CAAC,CAAC,CAACkU,EAAE,GAAGA,EAAE;MAC3CyP,WAAW,CAACA,WAAW,CAAC3jB,MAAM,GAAG,CAAC,CAAC,CAAC4jB,QAAQ,GAAGG,iBAAiB;;IAEnE;IACD,OAAOJ,WAAW;EACrB;EACD,MAAM,IAAI5a,KAAK,CAAC,iBAAiBuY,IAAI,EAAE,CAAC;AAC5C;AAEA,SAASwC,cAAcA,CAACE,SAAe,EAAEd,oBAAoB;;EAEzD,IAAIe,UAAkB;EAEtB,QAAQf,oBAAoB,CAAC5B,IAAI;IAC7B,KAAK,GAAG;IACR,KAAK,QAAQ;MACT2C,UAAU,GAAGD,SAAS,CAAClC,UAAU,EAAE;MACnC,OAAOoB,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,GAAG;IACR,KAAK,MAAM;MACPA,UAAU,GAAGD,SAAS,CAAC/B,QAAQ,EAAE;MACjC,OAAOiB,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,GAAG;IACR,KAAK,KAAK;MACNA,UAAU,GAAGD,SAAS,CAACzB,MAAM,EAAE;MAC/B,OAAOW,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,MAAM;;MAEP,OAAOf,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,YAAY;MACbA,UAAU,GAAGD,SAAS,CAAC5B,OAAO,EAAE;MAChC,OAAOc,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,OAAO;MACRA,UAAU,GAAGD,SAAS,CAACrB,QAAQ,EAAE;MACjC,OAAOO,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D,KAAK,GAAG;IACR,KAAK,MAAM;MACPA,UAAU,GAAGD,SAAS,CAAClB,WAAW,EAAE;MACpC,OAAOI,oBAAoB,CAACgB,SAAS,CAACC,QAAQ,CAACF,UAAU,CAAC;IAC9D;MACI,MAAM,IAAIlb,KAAK,CAAC,iBAAiBma,oBAAoB,CAAC5B,IAAM,GAAC;EACpE;AACL;MC9Sa8C,UAAU;EACnBxe,IAAI;EACJsO,EAAE;EACFS,KAAK;EACL0P,YAAY;EACZC,UAAU;EACVC,cAAc;EAEdC,WAAW;;EAGX;;;;;;;;;EAWA/P,iBAAiBA,CAACgN,IAAY;IAC1B,OAAOhN,iBAAiB,CAACgN,IAAI,EAAE,IAAI,CAAC7b,IAAI,EAAE,IAAI,CAACsO,EAAE,EAAE,IAAI,CAACS,KAAK,CAAC;;EAGlEsH,iBAAiBA,CAACjG,CAAC;IACf,OAAOiG,iBAAiB,CAACjG,CAAC,EAAE,IAAI,CAACpQ,IAAI,EAAE,IAAI,CAACsO,EAAE,EAAE,IAAI,CAACS,KAAK,CAAC;;EAG/DqH,OAAOA,CAACyF,IAAY;IAChB,IAAI,IAAI,CAAC+C,WAAW,EAAE;MAClB,OAAO,IAAI,CAACA,WAAW,CAACxI,OAAO,CAACyF,IAAI,EAAE,IAAI,CAAC6C,UAAU,EAAE,IAAI,CAACD,YAAY,CAAC;IAC5E;;;;IAKD,OAAO,IAAI;;AAElB;AAEK,SAAU5P,iBAAiBA,CAACgN,IAAY,EAAE7b,IAAY,EAAEsO,EAAU,EAAES,KAAa;EACnF,IAAI,CAAC8M,IAAI,EAAE;IACP,OAAOphB,SAAS;EACnB;EAED,MAAMokB,UAAU,GAAGhD,IAAI,GAAG7b,IAAI;EAC9B,MAAM8e,aAAa,GAAGxQ,EAAE,GAAGtO,IAAI;EAE/B,OAAQ6e,UAAU,GAAGC,aAAa,GAAI/P,KAAK;AAC/C;AAEM,SAAUsH,iBAAiBA,CAACjG,CAAS,EAAEpQ,IAAY,EAAEsO,EAAU,EAAES,KAAa;EAChF,MAAM8P,UAAU,GAAIzO,CAAC,GAAGrB,KAAK,IAAKT,EAAE,GAAGtO,IAAI,CAAC;EAC5C,MAAM+e,cAAc,GAAG/e,IAAI,GAAG6e,UAAU;EACxC,OAAOE,cAAc;AACzB;AAEA;AACA;AACM,SAAUC,cAAcA,CAC1BC,KAAU,EACVpkB,KAAQ,EACRqkB,QAAuB,EACvBC,MAAgB;EAEhB,IAAIC,EAAE,GAAG,CAAC,CAAC;EACX,IAAIC,EAAE,GAAGJ,KAAK,CAAC7kB,MAAM;EACrB,OAAOilB,EAAE,GAAGD,EAAE,GAAG,CAAC,EAAE;IAChB,MAAME,GAAG,GAAGtjB,IAAI,CAACujB,KAAK,CAAC,CAACH,EAAE,GAAGC,EAAE,IAAI,CAAC,CAAC;IACrC,IAAIF,MAAM,GAAGD,QAAQ,CAACD,KAAK,CAACK,GAAG,CAAC,CAAC,GAAGzkB,KAAK,GAAGqkB,QAAQ,CAACD,KAAK,CAACK,GAAG,CAAC,CAAC,IAAIzkB,KAAK,EAAE;MACvEukB,EAAE,GAAGE,GAAG;IACX,OAAM;MACHD,EAAE,GAAGC,GAAG;IACX;EACJ;EACD,IAAI,CAACH,MAAM,IAAIF,KAAK,CAACG,EAAE,CAAC,KAAK3kB,SAAS,IAAIykB,QAAQ,CAACD,KAAK,CAACG,EAAE,CAAC,CAAC,KAAKvkB,KAAK,EAAE;IACrEwkB,EAAE,GAAGD,EAAE;EACV;EACD,OAAO,CAACA,EAAE,EAAEC,EAAE,CAAC;AACnB;AAEM,SAAUzb,GAAGA,CACfqb,KAAU,EACVpkB,KAAQ,EACRqkB,QAAuB,EACvBC,MAAgB;EAEhB,MAAMK,GAAG,GAAGR,cAAc,CAACC,KAAK,EAAEpkB,KAAK,EAAEqkB,QAAQ,EAAEC,MAAM,CAAC;EAC1D,OAAO,CAACF,KAAK,CAACO,GAAG,CAAC,CAAC,CAAC,CAAC,EAAEP,KAAK,CAACO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC;;;;;;;;;;;;;;;;8BC9BmDlkB,GAAO,KAACiT,KAAK,IAAI,KAAK;;;;;;;;;;;;;;;;;;MAHhDpO,SAAA,CAAA6S,IAAA,qBAAA1X,GAAO,KAACsT,IAAI;MAAWzO,SAAA,CAAA6S,IAAA,sBAAA1X,GAAO,KAACyT,KAAK;MADnCxN,YAAA,CAAAyR,IAAA,sBAAA1X,GAAM,IAACmkB,MAAM;;;MAJ/B5hB,MASM,CAAAH,MAAA,EAAAsV,IAAA,EAAAlV,MAAA;MADFL,MAAoE,CAAAuV,IAAA,EAAAG,IAAA;;;;;;;;;;uEAA7B7X,GAAO,KAACiT,KAAK,IAAI,KAAK,SAAArO,QAAA,CAAAwf,EAAA,EAAAC,QAAA;;QAHhDxf,SAAA,CAAA6S,IAAA,qBAAA1X,GAAO,KAACsT,IAAI;;;QAAWzO,SAAA,CAAA6S,IAAA,sBAAA1X,GAAO,KAACyT,KAAK;;;QADnCxN,YAAA,CAAAyR,IAAA,sBAAA1X,GAAM,IAACmkB,MAAM;;;;;;;;;;;;;;EAN5B,IAAAG,UAAA,GAAAxZ,iBAAA,YAAA9K,GAAM,IAACukB,OAAO;;iCAAnBzlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;MADV2B,MAcM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;QAbK8hB,UAAA,GAAAxZ,iBAAA,YAAA9K,GAAM,IAACukB,OAAO;;mCAAnBzlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;wCAAJ9B,MAAI;;;;;;;;;;;;;;;;;EAlDA,MAAA0lB,QAAQ,GAAGvc,qBAAqB;EAM9B;IAAAvD,IAAI;IAAEsO,EAAE;IAAES;EAAK,CAA6B,GAAApL,UAAU,CAAC,YAAY;;;;;IACnEib;EAAW,IAA8Cjb,UAAU,CAAC,SAAS;;IAE1Eoc;EAAM,IAAAtM,OAAA;;IAENuM;EAAgB,IAAAvM,OAAA;;IAChBwM;EAAa,IAAAxM,OAAA;EAgCf,SAAAyM,aAAaA,CAACC,OAAO;IAC1BL,QAAQ,CAAC,cAAc;MAAI9f,IAAI,EAAEmgB,OAAO,CAACngB,IAAI;MAAEsO,EAAE,EAAE6R,OAAO,CAAC7R,EAAE;MAAEoN,IAAI,EAAEqE,MAAM,CAACrE;;;EAaxD,MAAA0E,aAAA,GAAAD,OAAA,IAAAD,aAAa,CAACC,OAAO;;;;;;;;MA5C5C;YACOJ,MAAM,CAACrE,IAAI,KAAKuE,aAAa;0BAC7BF,MAAM,CAACF,OAAO,GAAGG,gBAAgB,CAACxX,GAAG,CAAC6X,MAAM;eACrCA,MAAM;YACT9R,KAAK,EAAEqQ,WAAW,CAAC0B,MAAM,CAACD,MAAM,CAACrgB,IAAI,EAAE+f,MAAM,CAACO,MAAM;;;UAGlD,MAAAC,OAAO,GAAGlD,aAAa,CAACmD,KAAK,CAACC,OAAO,EAAI,EAAAC,GAAG,CAACD,OAAO,EAAI,EAAAV,MAAM,CAACrE,IAAI;UACrE,IAAAiF,cAAc,GAAG,CAAC;UAClB,IAAA/R,IAAI,GAAG,CAAC;0BAEZmR,MAAM,CAACF,OAAO,GAAGU,OAAO,CAAC/X,GAAG,CAACoY,MAAM;YAC/BhS,IAAI,GAAG+R,cAAc;YACrBA,cAAc,GAAG9R,iBAAiB,CAC9B+R,MAAM,CAACtS,EAAE,EACTkS,KAAK,CAACC,OAAO,EACb,EAAAC,GAAG,CAACD,OAAO,IACXI,MAAM;;cAGN9R,KAAK,EAAE/S,IAAI,CAAC8kB,GAAG,CAACH,cAAc,GAAG/R,IAAI,EAAEiS,MAAM;cAC7CtS,KAAK,EAAEqQ,WAAW,CAAC0B,MAAM,CAACM,MAAM,CAAC5gB,IAAI,EAAE+f,MAAM,CAACO,MAAM;cACpDtgB,IAAI,EAAE4gB,MAAM,CAAC5gB,IAAI;cACjBsO,EAAE,EAAEsS,MAAM,CAACtS,EAAE;cACPM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDC9BnBtT,GAAO;;iCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;mDAACZ,GAAO;;mCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;4BAAJ9B,MAAI,EAAA8B,CAAA,GAAA6kB,WAAA,CAAA3mB,MAAA,EAAA8B,CAAA;;;;;;;;qCAAJ9B,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;IALS8kB;EAAO,IAAAvN,OAAA;;IACPuM;EAAgB,IAAAvM,OAAA;;IAChBwM;EAAa,IAAAxM,OAAA;;;;;;;;;;;;;;;;;;;;;ACNZ,SAAAwN,gBAAgBA,CAC5BpB,OAAiB,EACjB5I,IAA8C;EAE9C,MAAMiK,MAAM,GAAGpnB,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC/CmnB,MAAM,CAACnS,KAAK,GAAG,CAAC8Q,OAAO,CAACzlB,MAAM,GAAG,CAAC,IAAIylB,OAAO,CAAC,CAAC,CAAC,CAAC9Q,KAAK;EACtDmS,MAAM,CAAClS,MAAM,GAAG,EAAE;EAClB,MAAM1T,GAAG,GAAG4lB,MAAM,CAACvd,UAAU,CAAC,IAAI,CAAC;EACnCrI,GAAG,CAAC6lB,WAAW,GAAG,uBAAuB;EACzC7lB,GAAG,CAAC8lB,aAAa,GAAG,CAAC;EACrB9lB,GAAG,CAAC+lB,aAAa,GAAG,CAAC;EACrB/lB,GAAG,CAACgmB,UAAU,GAAG,GAAG;EACpBhmB,GAAG,CAACimB,SAAS,GAAGtK,IAAI,CAACuK,iBAAiB;EACtClmB,GAAG,CAACmmB,OAAO,GAAG,QAAQ;EACtBnmB,GAAG,CAAComB,WAAW,GAAGzK,IAAI,CAAC0K,iBAAiB;EACxCrmB,GAAG,CAACsmB,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC;EACvB/B,OAAO,CAACzmB,OAAO,CAACinB,MAAM,IAAG;IACrBwB,MAAM,CAACvmB,GAAG,EAAE+kB,MAAM,CAACzR,IAAI,CAAC;EAC5B,CAAC,CAAC;EACF,MAAMkT,OAAO,GAAGZ,MAAM,CAACa,SAAS,EAAE;EAClC,OAAO,QAAQD,OAAO,IAAI;AAC9B;AAEA,SAASD,MAAMA,CAACvmB,GAAG,EAAE8U,CAAC;EAClB9U,GAAG,CAAC0mB,SAAS,EAAE;EACf1mB,GAAG,CAAC2mB,MAAM,CAAC7R,CAAC,EAAE,CAAC,CAAC;EAChB9U,GAAG,CAAC4mB,MAAM,CAAC9R,CAAC,EAAE,EAAE,CAAC;EACjB9U,GAAG,CAAC6mB,MAAM,EAAE;AAChB;;;;;;;;;;;;;;;iDCDe7mB,GAAO;;iCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;MADV2B,MAaM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;mDAZKxC,GAAO;;mCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;wCAAJ9B,MAAI;;;;;;;;;;;;;;;;;;;4DAH6DkB,GAAe;;;MAAtFuC,MAA8F,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;8DAAvBxC,GAAe;;;;;;;;;;;;;;;;;;MAO3D6E,SAAA,CAAA6R,GAAA,8BAAA1W,GAAM,IAAC8mB,gBAAgB,GAChC,CAAC,GACD,qBAAA9mB,GAAiB,CAAW,gCAAAA,GAAM,CAAC,GAAA8mB,gBAAgB,yBAAI9mB,GAAiB;MACvE6E,SAAA,CAAA6R,GAAA,oBAAA1W,GAAM,IAACsT,IAAI;MACVzO,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,IAACyT,KAAK;mDACDzT,GAAM,IAAC8mB,gBAAgB,0BAAI9mB,GAAkB;;;MARpEuC,MASO,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;QANYqC,SAAA,CAAA6R,GAAA,8BAAA1W,GAAM,IAAC8mB,gBAAgB,GAChC,CAAC,GACD,qBAAA9mB,GAAiB,CAAW,gCAAAA,GAAM,CAAC,GAAA8mB,gBAAgB,yBAAI9mB,GAAiB;;;QACvE6E,SAAA,CAAA6R,GAAA,oBAAA1W,GAAM,IAACsT,IAAI;;;QACVzO,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,IAACyT,KAAK;;;qDACDzT,GAAM,IAAC8mB,gBAAgB,0BAAI9mB,GAAkB;;;;;;;;;;;;;6BAb3EA,GAAgB,YAAA+mB,iBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAnBNxC;EAAO,IAAApM,OAAA;EAEP;IAAA6O,gBAAgB,GAAG;EAAI,IAAA7O,OAAA;;IACvB+N;EAAiB,IAAA/N,OAAA;;IACjBkO;EAAiB,IAAAlO,OAAA;EACjB;IAAA8O,kBAAkB,GAAG;EAAS,IAAA9O,OAAA;MAErC+O,eAAe;;;;;;;;;;MAClB;;;wBAGGA,eAAe,GAAGvB,gBAAgB,CAACpB,OAAO;;UAEtC8B,iBAAiB;UACjBH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCCoBwBlmB,GAAC;;;MAArCuC,MAA4D,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;oCAAxBxC,GAAC;;;;;;;;;;;;;;;EArC3B,MAAAwkB,QAAQ,GAAGvc,qBAAqB;;IAK3B6M;EAAC,IAAAqD,OAAA;;IACDsE;EAAS,IAAAtE,OAAA;QAGdgP,WAAW;IACb9K,MAAM,EAAE1Y,KAAK;MACR2W,YAAA,IAAAxF,CAAC,GAAGnR,KAAK,CAACmR,CAAC,CAAmB;MAC/B0P,QAAQ,CAAC,QAAQ,EAAI;QAAAlR,IAAI,EAAEwB;MAAC;MAC5BS,SAAS,CAAC,YAAY;;IAE1BuE,MAAM,EAAEnW,KAAK;MACR2W,YAAA,IAAAxF,CAAC,GAAGnR,KAAK,CAACmR,CAAC,CAAoB;MAChC0P,QAAQ,CAAC,QAAQ,EAAI;QAAAlR,IAAI,EAAEwB;MAAC;MAC5BS,SAAS,CAAC,SAAS;;IAEvBgH,WAAW,EAAE,IAAI;IACjBC,aAAa,EAAE,KAAK;IACTC,SAAS;IACpBC,IAAI,EAAAA,CAAA,KAAQ5H,CAAC;IACb6H,IAAI,EAAAA,CAAA,KAAQ,CAAC;IACbC,QAAQ,EAAAA,CAAA,KAAQ;;EAKX,SAAAwK,OAAOA,CAAC/kB,IAAI;IACX,MAAAwd,SAAS,OAAOnC,SAAS,CAACrb,IAAI,EAAE8kB,WAAW,EAAE,SAAS;;MAEnDjlB,OAAO,EAAAA,CAAA,KAAQ2d,SAAS,CAAC3d,OAAO;IAAA;;;;;;;;MAL1CilB,WAAW,CAAC1K,SAAS,GAAGA,SAAS;;;;;;;;;;;;;;MC/B3B4K,QAAQ;EACjBC,SAAS;EACTC,YAAY;EACZvT,KAAK;EACL8L,UAAU;EAEV/Y,YAAA;IACI,IAAI,CAACugB,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,YAAY,GAAG,EAAE;;EAG1BC,aAAaA,CAACC,WAAW,EAAEC,SAAS;IAChC,IAAI,CAAC,IAAI,CAACD,WAAW,CAAC,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC,GAAG,EAAE;IACzB;IAED,MAAME,OAAO,GAAG,IAAI,CAACF,WAAW,CAAC;IACjC,IAAI,CAACE,OAAO,CAACC,EAAE,EAAE;MACbD,OAAO,CAACC,EAAE,GAAG,EAAE;MACfD,OAAO,CAACpN,KAAK,GAAG,EAAE;IACrB;IAED,IAAIsN,OAAO,GAAG,KAAK,GAAGJ,WAAW,GAAG,GAAG,GAAGC,SAAS;IAEnDC,OAAO,CAACpN,KAAK,CAACmN,SAAS,CAAC,GAAG,CAAC,GAAGI,MAAM,KAAI;;MAErC,IAAI,CAACR,SAAS,CAACxpB,OAAO,CAACoX,QAAQ,IAAG;QAC9B,IAAIA,QAAQ,CAAC2S,OAAO,KAAKA,OAAO,EAAE;UAC9B3S,QAAQ,CAACtR,OAAO,CAACkkB,MAAM,CAAC;QAC3B;MACL,CAAC,CAAC;IACN,CAAC;;IAGDH,OAAO,CAACC,EAAE,CAACF,SAAS,CAAC,GAAG9jB,OAAO,IAAG;;MAE9B,IAAIsR,QAAQ,GAAG;QACXtR,OAAO,EAAEA,OAAO;QAChBikB,OAAO,EAAEA;OACZ;MACD,IAAI,CAACN,YAAY,CAACM,OAAO,CAAC,GAAG3S,QAAQ;MACrC,IAAI,CAACoS,SAAS,CAACznB,IAAI,CAACqV,QAAQ,CAAC;MAE7B,MAAM6S,cAAc,GAAGA,CAAA,KAAK;QACxB,MAAMrZ,KAAK,GAAG,IAAI,CAAC4Y,SAAS,CAACpd,OAAO,CAACgL,QAAQ,CAAC;QAC9C,IAAI,CAACoS,SAAS,CAAC3Y,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;MACnC,CAAC;MAED,OAAOqZ,cAAc;IACzB,CAAC;;AAER;MClBYC,UAAU;EACnB7K,SAAS;EAETpW,YAAA;EAEAkhB,SAASA,CAAChU,GAAa,EAAEC,CAAS;;;;;IAK9BD,GAAG,CAAClB,OAAO,GAAGkB,GAAG,CAAClB,OAAO,IAAI,EAAE;;IAE/BkB,GAAG,CAACgJ,WAAW,GAAGhJ,GAAG,CAACgJ,WAAW,IAAI9d,SAAS;;IAE9C8U,GAAG,CAACZ,cAAc,GAAGY,GAAG,CAACZ,cAAc,KAAKlU,SAAS,GAAG,IAAI,GAAG8U,GAAG,CAACZ,cAAc;;IAEjF,MAAMK,MAAM,GAAGO,GAAG,CAACP,MAAM,IAAI,IAAI,CAACyJ,SAAS;IAE3C,OAAO;MACHpM,KAAK,EAAEkD,GAAG;MACVC,CAAC;MACDR,MAAM;MACNwU,QAAQ,EAAE;KACb;;EAGLC,UAAUA,CAACC,IAAgB;IACvB,MAAMpoB,GAAG,GAAG;MAAEkU,CAAC,EAAE,CAAC;MAAE3S,MAAM,EAAE;IAAE,CAAE;IAChC,IAAI,CAAC8mB,eAAe,CAACD,IAAI,EAAEpoB,GAAG,CAAC;IAC/B,OAAOA,GAAG,CAACuB,MAAM;;EAGrB8mB,eAAeA,CACXC,SAAqB,EACrBtoB,GAAuC,EACvCsF,MAAA,GAAoB,IAAI,EACxBijB,KAAgB,IAAC,EACjBC,OAAA,GAAuB,EAAE;IAEzB,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMxW,OAAO,GAAG,EAAE;IAElB,IAAI3M,MAAM,EAAE;MACRkjB,OAAO,GAAG,CAAC,GAAGA,OAAO,EAAEljB,MAAM,CAAC;IACjC;IAEDgjB,SAAS,CAACxqB,OAAO,CAAC4qB,QAAQ,IAAG;MACzB,MAAMzU,GAAG,GAAG,IAAI,CAACgU,SAAS,CAACS,QAAQ,EAAE1oB,GAAG,CAACkU,CAAC,CAAC;MAC3ClU,GAAG,CAACuB,MAAM,CAAC1B,IAAI,CAACoU,GAAG,CAAC;MACpBwU,WAAW,CAAC5oB,IAAI,CAACoU,GAAG,CAAC;MACrBhC,OAAO,CAACpS,IAAI,CAACoU,GAAG,CAAC;MAEjBA,GAAG,CAAC0U,UAAU,GAAGJ,KAAK;MACtBtU,GAAG,CAAC3O,MAAM,GAAGA,MAAM;MACnB2O,GAAG,CAAC4H,UAAU,GAAG2M,OAAO;MAExBxoB,GAAG,CAACkU,CAAC,IAAID,GAAG,CAACP,MAAM;MAEnB,IAAIgV,QAAQ,CAAClkB,QAAQ,EAAE;QACnB,MAAMokB,SAAS,GAAG,IAAI,CAACP,eAAe,CAClCK,QAAQ,CAAClkB,QAAQ,EACjBxE,GAAG,EACHiU,GAAG,EACHsU,KAAK,GAAG,CAAC,EACTC,OAAO,CACV;QACDvU,GAAG,CAACzP,QAAQ,GAAGokB,SAAS,CAACR,IAAI;QAC7BnU,GAAG,CAACyH,WAAW,GAAGkN,SAAS,CAAC3W,OAAO;QACnCA,OAAO,CAACpS,IAAI,CAAC,GAAG+oB,SAAS,CAAC3W,OAAO,CAAC;MACrC;IACL,CAAC,CAAC;IACF,OAAO;MACHmW,IAAI,EAAEK,WAAW;MACjBxW;KACH;;AAER;MC1FY4W,gBAAgB;EACzBnW,aAAa;EAEb3L,YAAY2L,aAA4B;IACpC,IAAI,CAACA,aAAa,GAAGA,aAAa;;EAGtC/U,MAAMA,CAACoT,KAAqB;;IAExBA,KAAK,CAAC+X,cAAc,GAAG/X,KAAK,CAAC+X,cAAc,KAAK3pB,SAAS,GAAG,IAAI,GAAG4R,KAAK,CAAC+X,cAAc;IAEvF,MAAMxV,IAAI,GAAG,IAAI,CAACZ,aAAa,CAACa,iBAAiB,CAACxC,KAAK,CAACrM,IAAI,CAAC;IAC7D,MAAM8O,KAAK,GAAG,IAAI,CAACd,aAAa,CAACa,iBAAiB,CAACxC,KAAK,CAACiC,EAAE,CAAC;IAE5D,OAAO;MACHjC,KAAK;MACLuC,IAAI,EAAEA,IAAI;MACVG,KAAK,EAAED,KAAK,GAAGF,IAAI;MACnB2I,QAAQ,EAAE;KACb;;AAER;MC3BY8M,gBAAgB;EASLlX,SAAA;;EAPpB2J,cAAc,GAAG,EAAE;EACnBD,sBAAsB,GAAG,EAAE;EAE3BO,YAAY,GAAG,IAAIjQ,GAAG,EAA6B;EACnDmd,gBAAgB,GAAG,IAAInd,GAAG,EAAwB;EAClDwN,aAAa,GAAGlK,QAAQ,CAAC,EAAE,CAAC;EAE5BpI,YAAoB8K,SAAkC;IAAlC,IAAS,CAAAA,SAAA,GAATA,SAAS;;EAE7BoX,YAAYA,CAACC,MAAM,EAAE7mB,IAAI;IACrB,IAAI,CAAC,IAAI,CAAC2mB,gBAAgB,CAACrnB,GAAG,CAACunB,MAAM,CAAC,EAAE;MACpC,IAAI,CAACC,aAAa,EAAE;MACpB,IAAI,CAACC,eAAe,CAACF,MAAM,EAAE7mB,IAAI,CAAC;IACrC;IACD,IAAI,CAACgX,aAAa,CAACtX,GAAG,CAAC;MAAE,CAACmnB,MAAM,GAAG;IAAI,CAAE,CAAC;;EAG9CE,eAAeA,CAACF,MAAM,EAAE7mB,IAAI;IACxB,IAAI,CAAC2mB,gBAAgB,CAACjnB,GAAG,CAACmnB,MAAM,EAAE;MAC9BG,WAAW,EAAEhnB,IAAI;MACjBkc,UAAU,EAAEpf,SAAS;MACrB0gB,SAAS,EAAE1gB;IACd,EAAC;IACF,IAAI,CAACka,aAAa,CAAC7P,MAAM,CAAC8f,UAAU,KAAK;MACrC,GAAGA,UAAU;MACb,CAACJ,MAAM,GAAG,CAACI,UAAU,CAACJ,MAAM;IAC/B,EAAC,CAAC;;EAGPC,aAAaA,CAAA;IACT,IAAI,CAAC9P,aAAa,CAACtX,GAAG,CAAC,EAAE,CAAC;IAC1B,IAAI,CAACinB,gBAAgB,CAACrf,KAAK,EAAE;;EAGjC4f,sBAAsBA,CAACL,MAAM,EAAEvlB,KAAK;IAChC,MAAM6lB,WAAW,GAAG,IAAI,CAAC1N,YAAY,CAACxT,GAAG,CAAC4gB,MAAM,CAAC;IACjD,MAAMpU,CAAC,GAAG0U,WAAW,CAAC9M,IAAI,EAAE;IAC5B,MAAMxI,CAAC,GAAGsV,WAAW,CAAC7M,IAAI,EAAE;IAC5B,MAAMlJ,KAAK,GAAG+V,WAAW,CAAC5M,QAAQ,EAAE;IAEpC,KAAK,MAAM,CAAC6M,KAAK,EAAEC,YAAY,CAAC,IAAI,IAAI,CAACV,gBAAgB,CAACW,OAAO,EAAE,EAAE;MACjE,IAAIF,KAAK,KAAKP,MAAM,EAAE;QAClB,MAAMU,eAAe,GAAG,IAAI,CAAC9N,YAAY,CAACxT,GAAG,CAACmhB,KAAK,CAAC;QACpDC,YAAY,CAACnL,UAAU,GAAG;UACtBH,SAAS,EAAE;YACPtJ,CAAC,EAAE8U,eAAe,CAAClN,IAAI,EAAE,GAAG5H,CAAC;YAC7BZ,CAAC,EAAE0V,eAAe,CAACjN,IAAI,EAAE,GAAGzI;UAC/B;UACDmK,WAAW,EAAEuL,eAAe,CAAChN,QAAQ,EAAE,GAAGnJ;SAC7C;MACJ,OAAM;QACHiW,YAAY,CAACnL,UAAU,GAAG;UACtBH,SAAS,EAAE;YACPtJ,CAAC,EAAE,IAAI;YACPZ,CAAC,EAAE;UACN;UACDmK,WAAW,EAAE;SAChB;MACJ;IACJ;IACD,IAAI,CAACwL,qBAAqB,CAAClmB,KAAK,CAAC;;EAGrCkmB,qBAAqB,GAAGlmB,KAAK,IAAG;IAC5B,KAAK,MAAM,CAAC8lB,KAAK,EAAEC,YAAY,CAAC,IAAI,IAAI,CAACV,gBAAgB,CAACW,OAAO,EAAE,EAAE;MACjE,MAAM9J,SAAS,GAAG,IAAInC,SAAS,CAC3BgM,YAAY,CAACL,WAAW,EACxB,IAAI,CAACvN,YAAY,CAACxT,GAAG,CAACmhB,KAAK,CAAC,EAC5BC,YAAY,CAACnL,UAAU,CAC1B;MACDsB,SAAS,CAACrB,WAAW,CAAC7a,KAAK,CAAC;MAC5B,IAAI,CAACqlB,gBAAgB,CAACjnB,GAAG,CAAC0nB,KAAK,EAAE;QAAE,GAAGC,YAAY;QAAE7J,SAAS,EAAEA;MAAS,CAAE,CAAC;IAC9E;IAEDxa,MAAM,CAACvB,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACgmB,uBAAuB,EAAE,KAAK,CAAC;IACzE7U,oBAAoB,CAAC5P,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC0kB,gBAAgB,CAAC;EAClE,CAAC;EAEDD,uBAAuB,GAAGnmB,KAAK,IAAG;IAC9B,KAAK,MAAM,GAAG+lB,YAAY,CAAC,IAAI,IAAI,CAACV,gBAAgB,CAACW,OAAO,EAAE,EAAE;MAC5D,MAAM;QAAE9J;MAAS,CAAE,GAAG6J,YAAY;MAClC7J,SAAS,CAACf,WAAW,CAACnb,KAAK,CAAC;IAC/B;EACL,CAAC;EAEDomB,gBAAgB,GAAGpmB,KAAK,IAAG;IACvB0B,MAAM,CAACtB,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC+lB,uBAAuB,EAAE,KAAK,CAAC;IAC5E,KAAK,MAAM,GAAGJ,YAAY,CAAC,IAAI,IAAI,CAACV,gBAAgB,CAACW,OAAO,EAAE,EAAE;MAC5D,MAAM;QAAE9J;MAAS,CAAE,GAAG6J,YAAY;MAClC7J,SAAS,CAACd,SAAS,CAACpb,KAAK,CAAC;IAC7B;IAED,IAAI,IAAI,CAAC6X,cAAc,CAAC1c,MAAM,EAAE,IAAI,CAAC+S,SAAS,CAACX,SAAS,CAAC,IAAI,CAACsK,cAAc,CAAC;IAC7E,IAAI,IAAI,CAACD,sBAAsB,CAACzc,MAAM,EAClC,IAAI,CAAC+S,SAAS,CAACP,SAAS,CAAC,IAAI,CAACiK,sBAAsB,CAAC;IAEzD,IAAI,CAACA,sBAAsB,CAAC5M,MAAM,CAAC,CAAC,CAAC;IACrC,IAAI,CAAC6M,cAAc,CAAC7M,MAAM,CAAC,CAAC,CAAC;EACjC,CAAC;AACJ;AAED;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AC7JgB,SAAAqb,cAAcA,CAACzF,OAAiB,EAAEzP,CAAS;EACvD,MAAMvT,MAAM,GAAG+G,GAAG,CAASic,OAAO,EAAEzP,CAAC,EAAE9N,CAAC,IAAIA,CAAC,CAACsM,IAAI,CAAC;EACnD,OAAO/R,MAAM;AACjB;AAEgB,SAAA0oB,UAAUA,CAAC1F,OAAiB,EAAEzP,CAAS;EACnD,MAAMvT,MAAM,GAAG+G,GAAG,CAASic,OAAO,EAAEzP,CAAC,EAAE9N,CAAC,IAAIA,CAAC,CAACtC,IAAI,CAAC;EACnD,OAAOnD,MAAM;AACjB;SC1BgB2oB,8BAA8BA,CAAA;EAC1C,MAAMjrB,SAAS,GAA8D,EAAE;EAE/E,OAAO;IACHkrB,gBAAgBA,CAAC9jB,IAAI,EAAElC,IAAI,EAAEjF,QAA2B;MACpD,IAAI,CAACD,SAAS,CAACoH,IAAI,CAAC,EAAEpH,SAAS,CAACoH,IAAI,CAAC,GAAG,EAAE;MAC1CpH,SAAS,CAACoH,IAAI,CAAC,CAAClC,IAAI,CAAC,GAAGjF,QAAQ;KACnC;IAEDkrB,iBAAiBA,CAAC/jB,IAAI,EAAElC,IAAI;MACxB,OAAOlF,SAAS,CAACoH,IAAI,CAAC,CAAClC,IAAI,CAAC;KAC/B;IAEDkmB,OAAOA,CAACzjB,CAAa;MACjB,MAAM;QAAEP,IAAI;QAAEjE;MAAM,CAAE,GAAGwE,CAAC;MAC1B,MAAM0jB,GAAG,GAAGrrB,SAAS,CAACoH,IAAI,CAAC;MAC3B,IAAI,CAACikB,GAAG,EAAE;MAEV,IAAIC,KAAK;MACT,IAAItnB,OAAO,GAAGb,MAAiB;MAC/B,OAAOa,OAAO,IAAIA,OAAO,IAAI2D,CAAC,CAAC4jB,aAAa,EAAE;QAC1C,IAAKD,KAAK,GAAGE,OAAO,CAACH,GAAG,EAAErnB,OAAO,CAAC,EAAG;UACjC;QACH;QACDA,OAAO,GAAGA,OAAO,CAACynB,aAAa;MAClC;MACD,IAAIH,KAAK,IAAID,GAAG,CAACC,KAAK,CAACpmB,IAAI,CAAC,EAAE;QAC1BmmB,GAAG,CAACC,KAAK,CAACpmB,IAAI,CAAC,CAACyC,CAAC,EAAE2jB,KAAK,CAACjnB,IAAI,EAAEL,OAAO,CAAC;MAC1C,OAAM,IAAIqnB,GAAG,CAAC,OAAO,CAAC,EAAE;QACrBA,GAAG,CAAC,OAAO,CAAC,CAAC1jB,CAAC,EAAE,IAAI,EAAE3D,OAAO,CAAC;MACjC;;GAER;AACL;AAEA,SAASwnB,OAAOA,CAACH,GAAG,EAAErnB,OAAO;EACzB,IAAIK,IAAI;EACR,KAAK,MAAMa,IAAI,IAAImmB,GAAG,EAAE;IACpB,IAAKhnB,IAAI,GAAGL,OAAO,CAACqB,YAAY,CAACH,IAAI,CAAC,EAAG;MACrC,OAAO;QAAEA,IAAI;QAAEb;MAAI,CAAE;IACxB;EACJ;AACL;MC1CaqnB,6BAA6B;EACtC3F,MAAMA,CAACzE,IAAY,EAAEyE,MAAc;IAC/B,MAAMhiB,CAAC,GAAG,IAAImf,IAAI,CAAC5B,IAAI,CAAC;IACxB,QAAQyE,MAAM;MACV,KAAK,GAAG;QACJ,OAAOhiB,CAAC,CAAC+d,QAAQ,EAAE,GAAG,EAAE;MAC5B,KAAK,IAAI;QACL,OAAO6J,GAAG,CAAC5nB,CAAC,CAAC+d,QAAQ,EAAE,CAAC;MAC5B,KAAK,MAAM;QACP,OAAU,GAAA/d,CAAC,CAAC+d,QAAQ,EAAM,IAAA6J,GAAG,CAAC5nB,CAAC,CAAC4d,UAAU,EAAE,CAAC,EAAE;MACnD,KAAK,OAAO;QACR,OAAO,GAAGgK,GAAG,CAAC5nB,CAAC,CAAC+d,QAAQ,EAAE,CAAK,IAAA6J,GAAG,CAAC5nB,CAAC,CAAC4d,UAAU,EAAE,CAAC,EAAE;MACxD,KAAK,UAAU;QACX,OAAO,GAAG5d,CAAC,CAAC+d,QAAQ,EAAM,IAAA6J,GAAG,CAAC5nB,CAAC,CAAC4d,UAAU,EAAE,CAAC,IAAIgK,GAAG,CAAC5nB,CAAC,CAACyd,UAAU,EAAE,CAAC,EAAE;MAC1E,KAAK,YAAY;QACb,OAAO,GAAGzd,CAAC,CAACke,OAAO,EAAE,IAAIle,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAK,IAAAze,CAAC,CAAC4e,WAAW,EAAE,EAAE;MAClE,KAAK,kBAAkB;QACnB,OAAU,GAAA5e,CAAC,CAACke,OAAO,EAAE,IACjBle,CAAC,CAACye,QAAQ,EAAE,GAAG,CACf,IAAAze,CAAC,CAAC4e,WAAW,EAAE,IAAI5e,CAAC,CAAC+d,QAAQ,EAAM,IAAA/d,CAAC,CAAC4d,UAAU,EAAE,EAAE;MAC3D,KAAK,qBAAqB;QACtB,OAAU,GAAA5d,CAAC,CAACke,OAAO,EACf,IAAAle,CAAC,CAACye,QAAQ,EAAE,GAAG,CACnB,IAAIze,CAAC,CAAC4e,WAAW,EAAE,IAAI5e,CAAC,CAAC+d,QAAQ,EAAE,IAAI/d,CAAC,CAAC4d,UAAU,EAAE,IAAI5d,CAAC,CAACyd,UAAU,EAAE,EAAE;;MAE7E,KAAK,MAAM;QACP,OAAO,GAAGzd,CAAC,CAAC4e,WAAW,EAAE,EAAE;MAC/B,KAAK,GAAG;QACJ,OAAU,GAAAlhB,IAAI,CAACujB,KAAK,CAACjhB,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChD,KAAK,MAAM;QACP,OAAW,IAAA/gB,IAAI,CAACujB,KAAK,CAACjhB,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACjD,KAAK,UAAU;QACX,OAAO,GAAGze,CAAC,CAAC4e,WAAW,EAAM,IAAAlhB,IAAI,CAACujB,KAAK,CAACjhB,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACnE,KAAK,IAAI;QAAE;;UAEP,IAAIoJ,KAAK,GAAGC,MAAM,CAAC9nB,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAC,CAAC;UACpC,IAAIoJ,KAAK,CAAC/rB,MAAM,IAAI,CAAC,EAAE+rB,KAAK,GAAG,IAAIA,KAAK,EAAE;UAC1C,OAAO,GAAGA,KAAK,EAAE;QACpB;MACD,KAAK,MAAM;QAAE;UACT,MAAMA,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAM,CAAE,CAAC;UAC5D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,EAAE;QACjE;MACD,KAAK,aAAa;QAAE;UAChB,MAAML,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAM,CAAE,CAAC;UAC5D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,IAAIloB,CAAC,CAAC4e,WAAW,EAAE,EAAE;QACpF;MACD,KAAK,WAAW;QAAE;UACd,MAAMiJ,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAM,CAAE,CAAC;UAC5D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,IAAIloB,CAAC,CAAC4e,WAAW,EAAE,EAAE;QACpF;MACD,KAAK,KAAK;QAAE;UACR,MAAMiJ,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAO,CAAE,CAAC;UAC7D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,EAAE;QACjE;MACD,KAAK,YAAY;QAAE;UACf,MAAML,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAO,CAAE,CAAC;UAC7D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,MAAMloB,CAAC,CAAC4e,WAAW,EAAE,EAAE;QACtF;MACD,KAAK,UAAU;QAAE;UACb,MAAMiJ,KAAK,GAAG7nB,CAAC,CAAC+nB,cAAc,CAAC,SAAS,EAAE;YAAEF,KAAK,EAAE;UAAO,CAAE,CAAC;UAC7D,OAAO,GAAGA,KAAK,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGJ,KAAK,CAACK,SAAS,CAAC,CAAC,CAAC,IAAIloB,CAAC,CAAC4e,WAAW,EAAE,EAAE;QACpF;MACD,KAAK,GAAG;QACJ,OAAO,GAAGuJ,aAAa,CAACnoB,CAAC,CAAC,EAAE;MAChC,KAAK,IAAI;QAAE;UACP,MAAMooB,UAAU,GAAGD,aAAa,CAACnoB,CAAC,CAAC;UACnC,OAAO,GAAGooB,UAAU,CAACrP,QAAQ,EAAE,CAACjd,MAAM,IAAI,CAAC,GAAG,GAAG,GAAG,EAAK,GAAAssB,UAAU,EAAE;QACxE;MACD;QACIC,OAAO,CAACC,IAAI,CAAC,gBAAgBtG,MAAM,+CAA+C,CAAC;QACnF,OAAO,GAAGhiB,CAAC,CAACke,OAAO,EAAE,IAAIle,CAAC,CAACye,QAAQ,EAAE,GAAG,CAAK,IAAAze,CAAC,CAAC4e,WAAW,EAAE,EAAE;IACrE;;EAGL;;;;AAIG;EACH9G,OAAOA,CAACyF,IAAY,EAAEH,IAAY,EAAEC,MAAc;IAC9C,MAAMgD,cAAc,GAAGkI,iBAAiB,CAACnL,IAAI,EAAEC,MAAM,CAAC;IACtD,MAAM9gB,KAAK,GAAGmB,IAAI,CAAC8qB,KAAK,CAACjL,IAAI,GAAG8C,cAAc,CAAC,GAAGA,cAAc,CAAC;IACjE,OAAO9jB,KAAK;;AAEnB;AAED,SAASqrB,GAAGA,CAACrrB,KAAa;EACtB,IAAIgC,MAAM,GAAGhC,KAAK,CAACwc,QAAQ,EAAE;EAC7B,KAAK,IAAInb,CAAC,GAAGW,MAAM,CAACzC,MAAM,EAAE8B,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACpCW,MAAM,GAAG,GAAG,GAAGA,MAAM;EACxB;EACD,OAAOA,MAAM;AACjB;AAEA,SAAS4pB,aAAaA,CAACnoB,CAAO;;EAE1BA,CAAC,GAAG,IAAImf,IAAI,CAACA,IAAI,CAACsJ,GAAG,CAACzoB,CAAC,CAAC4e,WAAW,EAAE,EAAE5e,CAAC,CAACye,QAAQ,EAAE,EAAEze,CAAC,CAACke,OAAO,EAAE,CAAC,CAAC;;;EAGlEle,CAAC,CAAC0oB,UAAU,CAAC1oB,CAAC,CAAC2oB,UAAU,EAAE,GAAG,CAAC,IAAI3oB,CAAC,CAAC4oB,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;;EAEvD,MAAMC,SAAS,GAAG,IAAI1J,IAAI,CAACA,IAAI,CAACsJ,GAAG,CAACzoB,CAAC,CAAC8oB,cAAc,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;EAE9D,MAAMC,MAAM,GAAGrrB,IAAI,CAACsrB,IAAI,CAAC,CAAC,CAAChpB,CAAC,CAACmiB,OAAO,EAAE,GAAG0G,SAAS,CAAC1G,OAAO,EAAE,IAAI,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC;;EAElF,OAAO4G,MAAM;AACjB;AAEA;;AAEG;AACH,SAASR,iBAAiBA,CAACnL,IAAY,EAAEC,MAAc;EACnD,QAAQD,IAAI;IACR,KAAK,GAAG;IACR,KAAK,MAAM;;MAEP,OAAOC,MAAM,GAAG,WAAW;IAAC;IAChC,KAAK,OAAO;;MAER,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAAC;IAC7C,KAAK,MAAM;MACP,OAAOA,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAC3C,KAAK,GAAG;IACR,KAAK,KAAK;MACN,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IACvC,KAAK,GAAG;IACR,KAAK,MAAM;MACP,OAAOA,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;IAClC,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOA,MAAM,GAAG,EAAE,GAAG,IAAI;IAC7B,KAAK,GAAG;IACR,KAAK,QAAQ;MACT,OAAOA,MAAM,GAAG,IAAI;IACxB;MACI,MAAM,IAAIxY,KAAK,CAAC,iBAAiBuY,IAAI,EAAE,CAAC;EAC/C;AACL;;AC1IA;;;;;;;;AAQG;AACa,SAAA6L,MAAMA,CAACjY,KAAmB,EAAE8T,MAAoC;EAC5E,IAAI,CAAC9T,KAAK,CAAClV,MAAM,EAAE;IACf;EACH;EAED,IAAIkV,KAAK,CAAClV,MAAM,KAAK,CAAC,EAAE;IACpB,MAAMwT,IAAI,GAAG0B,KAAK,CAAC,CAAC,CAAC;IACrB1B,IAAI,CAAC4Z,IAAI,GAAG,CAAC;IACb5Z,IAAI,CAAC6Z,cAAc,GAAG,EAAE;IACxB7Z,IAAI,CAACoB,MAAM,GAAGoU,MAAM,CAACsE,gBAAgB;IACrC9Z,IAAI,CAAC8F,QAAQ,GAAI9F,IAAI,CAAC4Z,IAAI,GAAG5Z,IAAI,CAACoB,MAAO,CAAC;EAC7C;EAEDM,KAAK,CAACqY,IAAI,CAACC,2BAA2B,CAAC;EAEvC,KAAI,MAAMhZ,IAAI,IAAIU,KAAK,EAAE;IACrBV,IAAI,CAAC4Y,IAAI,GAAG,CAAC,CAAC;IACd5Y,IAAI,CAAC6Y,cAAc,GAAG,EAAE;IACxB,KAAI,MAAM3Y,KAAK,IAAIQ,KAAK,EAAE;MACtB,IAAGV,IAAI,KAAKE,KAAK,IAAI+Y,WAAW,CAACjZ,IAAI,EAAEE,KAAK,CAAC,EAAE;QAC3CF,IAAI,CAAC6Y,cAAc,CAACtsB,IAAI,CAAC2T,KAAK,CAAC;MAClC;IACJ;EACJ;EAED,KAAI,MAAMlB,IAAI,IAAI0B,KAAK,EAAE;IACrB1B,IAAI,CAACka,SAAS,GAAGC,2BAA2B,CAACna,IAAI,CAAC;IAClD,KAAK,IAAI1R,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0R,IAAI,CAACka,SAAU,EAAE5rB,CAAC,EAAE,EAAE;MACtC,IAAG,CAAC0R,IAAI,CAAC6Z,cAAe,CAACO,IAAI,CAACC,SAAS,IAAIA,SAAS,CAACT,IAAI,KAAKtrB,CAAC,CAAC,EAAE;QAC9D0R,IAAI,CAAC4Z,IAAI,GAAGtrB,CAAC;QACb0R,IAAI,CAACoB,MAAM,GAAIoU,MAAM,CAACsE,gBAAgB,GAAG9Z,IAAI,CAACka,SAAW;QACzDla,IAAI,CAAC8F,QAAQ,GAAI9F,IAAI,CAAC4Z,IAAI,GAAG5Z,IAAI,CAACoB,MAAO,CAAC;QAC1C;MACH;IACJ;EACJ;AACL;AAEA;AACA,SAAS6Y,WAAWA,CAACjZ,IAAgB,EAAEE,KAAiB;EACpD,OAAQF,IAAI,CAACA,IAAI,GAAGA,IAAI,CAACG,KAAK,GAAID,KAAK,CAACF,IAAI,IAAIA,IAAI,CAACA,IAAI,GAAIE,KAAK,CAACF,IAAI,GAAGE,KAAK,CAACC,KAAM;AAC1F;AAEA,SAAS6Y,2BAA2BA,CAACpuB,CAAa,EAAEC,CAAa;EAC7D,OAAQD,CAAC,CAACoV,IAAI,GAAGnV,CAAC,CAACmV,IAAI,IAAOnV,CAAC,CAACmV,IAAI,GAAGnV,CAAC,CAACsV,KAAK,IAAKvV,CAAC,CAACoV,IAAI,GAAGpV,CAAC,CAACuV,KAAK,CAAE;AACzE;AAEA;;;;;;;AAOG;AACH,SAASgZ,2BAA2BA,CAACna,IAAgB,EAAEsa,IAAO,OAAI/gB,GAAG,EAAuB;EACxF+gB,IAAI,CAAC7qB,GAAG,CAACuQ,IAAI,EAAE,IAAI,CAAC;;;;EAIpB,IAAI7R,GAAG,GAAG6R,IAAI,CAAC6Z,cAAe,CAACrtB,MAAM,GAAG,CAAC;EACzC,KAAK,MAAM6tB,SAAS,IAAIra,IAAI,CAAC6Z,cAAe,CAAChf,MAAM,CAACvM,CAAC,IAAI,CAACgsB,IAAI,CAACjrB,GAAG,CAACf,CAAC,CAAC,CAAC,EAAE;IACpE,MAAMisB,QAAQ,GAAGJ,2BAA2B,CAACE,SAAS,EAAEC,IAAI,CAAC;IAC7D,IAAGC,QAAQ,GAAGpsB,GAAG,EAAE;MACfA,GAAG,GAAGosB,QAAQ;IACjB;EACJ;EACD,OAAOpsB,GAAG;AACd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBC0pBgBT,GAAW,M;;;+BALTA,GAAM;;;;;;;;;;;;gFAKRA,GAAW,O;;;;;;;;;;;;;;gCACN8sB,YAAY;;;;uBAIb9sB,GAAU;iCAAkCA,GAAY;;;oCAAjCA,GAAQ;;;;;;;;;;;;;;2FAVjCA,GAAM;;;;;;;;;;;sCAMH8sB,YAAY;;;;;;;;;;;;;;;;kFADjB9sB,GAAW,O;;;;;;wEAKPA,GAAU;uFAAkCA,GAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAc/BA,GAAS;;;;;;;;;;;;;;;;;;;;;;;gKAATA,GAAS,W;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAgCfA,GAAS;;;;;;;;;;;;;;;;;;;;;;;oJAATA,GAAS,W;;;;;;;;;;;;;;;;;;;;;;;;;;gCAKb;IAAA+Q,KAAA,UAAA/Q,GAAI,MAAC+Q;EAAK,GACX;IAAAuC,IAAA,UAAAtT,GAAI,MAACsT;EAAI,GACR;IAAAG,KAAA,UAAAzT,GAAI,MAACyT;EAAK,GACT;IAAAC,MAAA,UAAA1T,GAAI,MAAC0T;EAAM,GACd;IAAAE,GAAA,UAAA5T,GAAI,MAAC4T;EAAG,G,QACT5T,GAAI,M;;;;;;;;;;;;;;;;;;;;;;;2GALD;QAAA+Q,KAAA,UAAA/Q,GAAI,MAAC+Q;MAAK,GACX;QAAAuC,IAAA,UAAAtT,GAAI,MAACsT;MAAI,GACR;QAAAG,KAAA,UAAAzT,GAAI,MAACyT;MAAK,GACT;QAAAC,MAAA,UAAA1T,GAAI,MAAC0T;MAAM,GACd;QAAAE,GAAA,UAAA5T,GAAI,MAAC4T;MAAG,G,2BACT5T,GAAI,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAURA,GAAW,K;+BAJTA,GAAM;;;;;;;;;;gFAIRA,GAAW,M;;;;;;;;;;;;gCACN8sB,YAAY;;;;;;;;;;;;;0FALf9sB,GAAM;;;;;;;;;;;sCAKH8sB,YAAY;;;;;;;;;;;;;;kFADjB9sB,GAAW,M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DA9E5BA,GAAiB;;mCAAtBlB,MAAI,EAAA8B,CAAA;;;;;;;;;mCAqBgCZ,GAAO;mCACVA,GAAU;;;qDACRA,GAAc;0DAE5BA,GAAc;sCAAeA,GAAS,MAAC+Q,KAAK,CAACC,EAAE;mCAApDlS,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;uDAyBKZ,GAAW;kCAASA,GAAG,MAAC+Q,KAAK,CAACC,EAAE;mCAArClS,MAAI,EAAA8B,CAAA;;;;;0DAOHZ,GAAc;wCAAeA,GAAS,MAAC+Q,KAAK,CAACC,EAAE;mCAApDlS,MAAI,EAAA8B,CAAA;;;;;wDAICZ,GAAY;mCAAUA,GAAI,MAAC+Q,KAAK,CAACC,EAAE;mCAAxClS,MAAI,EAAA8B,CAAA;;;;;0DAWHZ,GAAgB;;iCAArBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAtDsCZ,GAAO;;;;6EAF8DA,GAAqB;iEAiC/FA,GAAU;;sDAF9BA,GAAkB;;;0CANNA,GAAO;;;;;sEAlDjCA,GAAO;uEACKA,GAAiB;;;MAFlDuC,MA+FM,CAAAH,MAAA,EAAA2qB,IAAA,EAAAvqB,MAAA;;;;;;;MAtEFL,MAqEM,CAAA4qB,IAAA,EAAAC,IAAA;MApEF7qB,MAcM,CAAA6qB,IAAA,EAAArN,IAAA;MAbFxd,MAYM,CAAAwd,IAAA,EAAAjI,IAAA;MAXFvV,MAUM,CAAAuV,IAAA,EAAAG,IAAA;;;;;;;;;;;;;MAId1V,MAmDM,CAAA6qB,IAAA,EAAAC,IAAA;MA1CF9qB,MAyCM,CAAA8qB,IAAA,EAAAC,IAAA;;;MAtCF/qB,MAUM,CAAA+qB,IAAA,EAAAC,IAAA;MALFhrB,MAIM,CAAAgrB,IAAA,EAAAC,IAAA;;;;;;;;;;MAGVjrB,MAeM,CAAA+qB,IAAA,EAAAG,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;wLAlCArtB,GAAO,O,uDA3CKA,GAAO,Q,mDACXA,GAAO,Q,oCACpBA,GAAO,O,qCACNA,GAAO,O,sCACNA,GAAO,M;;;;;;+DAEfA,GAAiB;;qCAAtBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;8BAAJ9B,MAAI,EAAA8B,CAAA,GAAA0sB,aAAA,CAAAxuB,MAAA,EAAA8B,CAAA;;;;;;;2FAqBgCZ,GAAO;yFACVA,GAAU;;;4DAGtBA,GAAc;;;;;;4CAPmBA,GAAO;;;+EAF8DA,GAAqB;;;;;;;;;yDAkCvHA,GAAW;;;;;;mEADaA,GAAU;;;wDAF9BA,GAAkB;;;4DAU1BA,GAAc;;;;;;0DAIdA,GAAY;;;;;;4DAWhBA,GAAgB;;mCAArBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;4BAAJ9B,MAAI,EAAA8B,CAAA,GAAA6kB,WAAA,CAAA3mB,MAAA,EAAA8B,CAAA;;;;;;4CA/ByBZ,GAAO;;;;;mHAlDjCA,GAAO;;;;yEACKA,GAAiB;;;;;uCAQ5ClB,MAAI,EAAA8B,CAAA;;;;uCAyBY9B,MAAI,EAAA8B,CAAA;;;;uCAyBA9B,MAAI,EAAA8B,CAAA;;;uCAOR9B,MAAI,EAAA8B,CAAA;;;uCAIJ9B,MAAI,EAAA8B,CAAA;;;qCAWR9B,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzwBT,SAAA2sB,SAASA,CAACld,MAAM;EACV,WAAAnN,IAAI,IAAImN,MAAM;QACjBA,MAAM,CAACnN,IAAI,KAAK,IAAI;MACV,UAAA2E,KAAK,KAAK3E,IAAI;;;;AAqB3B,SAAAsqB,SAASA,CAACjN,IAAmB;EAC3B,OAAAA,IAAI,YAAY4B,IAAI,GAAG5B,IAAI,CAAC4E,OAAO,KAAK5E,IAAI;;AA8a9C,SAAAuM,YAAYA,CAACW,MAAM,G;;;;;;;;;;;;;;;;;;;;;;;MApexBC,YAAyB;MACzBC,mBAAgC;MAChCjV,aAAa;MACbD,YAAyB;MACzBmV,WAAW;EACX,IAAAC,OAAO,GAAG,KAAK;;IAgCRzF;EAAI,IAAAjQ,OAAA;;IACJnE,KAAK;EAAA,IAAAmE,OAAA;;IACL2V,UAAU;EAAA,IAAA3V,OAAA;EAErBoV,SAAS;IAAGnF;EAAI;EAKL;IAAAzV,UAAU,GAAG;EAAC,IAAAwF,OAAA;EACd;IAAAgF,SAAS,GAAG;EAAE,IAAAhF,OAAA;QACnB4V,UAAU,GAAG5e,QAAQ,CAACgO,SAAS;;QAC/B6Q,WAAW,GAAG7e,QAAQ,CAACwD,UAAU;;;IAQ5BjO;EAAI,IAAAyT,OAAA;;IACJnF;EAAE,IAAAmF,OAAA;EACboV,SAAS;IAAG7oB,IAAI;IAAEsO;EAAE;EACd,MAAAib,KAAK,GAAG9e,QAAQ,CAACqe,SAAS,CAAC9oB,IAAI;;EAC/B,MAAAwpB,GAAG,GAAG/e,QAAQ,CAACqe,SAAS,CAACxa,EAAE;;EAItB;IAAAmb,QAAQ,GAAG;EAAG,IAAAhW,OAAA;EACd;IAAAiW,QAAQ,GAAG;EAAK,IAAAjW,OAAA;QACrBkW,SAAS,GAAGlf,QAAQ,CAACgf,QAAQ;;QAC7BG,SAAS,GAAGnf,QAAQ,CAACif,QAAQ;;;IAMxBrb,OAAO;EAAA,IAAAoF,OAAA;EACP;IAAAuN,OAAO,GACZ;MAAAtF,IAAI,EAAE,KAAK;MAAE4E,MAAM,EAAE;IAAS;MAC9B5E,IAAI,EAAE,MAAM;MAAE4E,MAAM,EAAE;IAAM;EAAA,IAAA7M,OAAA;;IAEvBoW,UAAU,I;MAEb7I,OAAO,EACD;QAAAtF,IAAI,EAAE,KAAK;QAAE4E,MAAM,EAAE;MAAY;QACjC5E,IAAI,EAAE,MAAM;QAAE4E,MAAM,EAAE;MAAI;MAEhCmJ,QAAQ,EAAE,GAAG;MACbC,QAAQ,EAAE;;MAGV1I,OAAO,GACD;QAAAtF,IAAI,EAAE,MAAM;QAAE4E,MAAM,EAAE;MAAc,G;QACpC5E,IAAI,EAAE,QAAQ;QAAE4E,MAAM,EAAE,IAAI;QAAE3E,MAAM,EAAE;MAAE,E;MAE9C8N,QAAQ,EAAE,IAAI;MACdC,QAAQ,EAAE;;;EAGP;IAAAzV,WAAW,GAAG;EAAI,IAAAR,OAAA;EAClB;IAAAqW,UAAU,GAAG;EAAG,IAAArW,OAAA;EAChB;IAAAS,iBAAiB,GAAG;EAAE,IAAAT,OAAA;EACtB;IAAAU,iBAAiB,GAAG;EAAI,IAAAV,OAAA;EAExB;IAAAmL,WAAW,OAA+BqH,6BAA6B;EAAA,IAAAxS,OAAA;EAEvE;IAAAiL,UAAU,GAAG;EAAQ,IAAAjL,OAAA;EACrB;IAAAgL,YAAY,GAAG;EAAE,IAAAhL,OAAA;MACxBkL,cAAc;EAElBoL,iBAAiB,CAACrL,UAAU,EAAED,YAAY;WAEjCsL,iBAAiBA,CAACrO,IAAI,EAAEC,MAAM;IAC/B,IAAAD,IAAI,IAAIC,MAAM;MACd/F,YAAA,KAAA+I,cAAc,GAAGlD,WAAW,CAACC,IAAI,EAAEC,MAAM;;;EAItC;IAAAqO,UAAU,GAAG;EAAQ,IAAAvW,OAAA;EACrB;IAAAwW,YAAY,GAAG;EAAE,IAAAxW,OAAA;;IAGjByW,iBAAiB;EAAA,IAAAzW,OAAA;;IACjB0W,gBAAgB;EAAA,IAAA1W,OAAA;EAEhB;IAAAW,mBAAmB,GAAG;EAAI,IAAAX,OAAA;EAC1B;IAAAY,kBAAkB,GAAG;EAAK,IAAAZ,OAAA;EAM1B;IAAA6O,gBAAgB,GAAG;EAAI,IAAA7O,OAAA;EACvB;IAAAkO,iBAAiB,GAAG;EAAS,IAAAlO,OAAA;EAC7B;IAAA+N,iBAAiB,GAAG;EAAC,IAAA/N,OAAA;;IAErB6J;EAA0C,IAAA7J,OAAA;EAC1C;IAAA2W,cAAc,GAAG;EAAS,IAAA3W,OAAA;EAG1B;IAAAa,eAAe,GAAG;EAAI,IAAAb,OAAA;EAGtB;IAAA8T,MAAA,EAAA8C,QAAM,GAAuB;EAAS,IAAA5W,OAAA;QAE3C6W,YAAY,GAAG7f,QAAQ,CAAS,IAAI;;QACpC8f,aAAa,GAAG9f,QAAQ,CAAS,IAAI;;QACrC+f,YAAY,GAAG/f,QAAQ,CAAS,IAAI;;EACpC,MAAAggB,MAAM,GAAGxf,OAAO,CAAE,CAAAqf,YAAY,EAAEX,SAAS,EAAEC,SAAS,CAAK,IAAAc,OAAO,EAAE5J,GAAG,EAAE6J,OAAO;IACzE,OAAAA,OAAO,IAAID,OAAO,GAAG5J,GAAG,GAAG4J,OAAO,GAAG5J,GAAG;;;EAG7C,MAAA8J,SAAS,GAAG1d,eAAe;EACjCzJ,UAAU,CAAC,WAAW,EAAEmnB,SAAS;EAE7B;IAAAxd,QAAQ;IACRD,SAAS;IACTE,cAAc;IACdC,QAAQ;IACRC,OAAO;IACPC,aAAa;IACbC,YAAY;IACZK;EAAiB,IACjB8c,SAAS;;;;;;;;QAEA5c,aAAa;IACtB6c,eAAeA,CAAChP,IAAY;MAClB,MAAAiP,IAAI,GAAGvF,UAAU,CAAC1F,OAAO,EAAEhE,IAAI;cAC7BiP,IAAI,CAAC,CAAC,CAAI,GAAAA,IAAI,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC;;IAEtCC,mBAAmBA,CAAC3a,CAAS;MACnB,MAAA0a,IAAI,GAAGxF,cAAc,CAACzF,OAAO,EAAEzP,CAAC;cAC9B0a,IAAI,CAAC,CAAC,CAAI,GAAAA,IAAI,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC;;IAEtCjc,iBAAiBA,CAACgN,IAAY;MACrB,KAAAA,IAAI,SAAS,IAAI;MAChB,MAAAwE,MAAM,GAAG,IAAI,CAACwK,eAAe,CAAChP,IAAI;MAEpC,IAAAgD,UAAU,GAAGhD,IAAI,GAAGwE,MAAM,CAACrgB,IAAI;YAC7BiB,QAAQ,GAAI4d,UAAU,GAAGwB,MAAM,CAACrC,QAAQ,GAAIqC,MAAM,CAACtR,KAAK;;;aAGvDsR,MAAM,CAACzR,IAAI,GAAG3N,QAAQ;;IAEjCoV,iBAAiBA,CAACjG,CAAS;MACjB,MAAAiQ,MAAM,GAAG,IAAI,CAAC0K,mBAAmB,CAAC3a,CAAC;MACzCA,CAAC,GAAGA,CAAC,GAAGiQ,MAAM,CAACzR,IAAI;UAEfoc,gBAAgB,GAAI3K,MAAM,CAACrC,QAAQ,GAAGqC,MAAM,CAACtR,KAAK,GAAIqB,CAAC;MACrD,MAAAyL,IAAI,GAAGwE,MAAM,CAACrgB,IAAI,GAAGgrB,gBAAgB;aAEpCnP,IAAI;;;;;;;IAOfzF,OAAOA,CAACyF,IAAY;UACZhhB,KAAK,GAAGmB,IAAI,CAAC8qB,KAAK,CAACjL,IAAI,GAAG8C,cAAc,IAAIA,cAAc;aACvD9jB,KAAK;;;EAIhB,IAAAowB,iBAAiB,GAAG,KAAK;iBAEdC,wBAAwBA,CAAA;IACnCtV,YAAA,KAAAqV,iBAAiB,GAAG,IAAI;UAClBxmB,IAAI;IACVukB,YAAY,CAACmC,YAAY;IACzBvV,YAAA,KAAAqV,iBAAiB,GAAG,KAAK;;MAGzBpL,OAAkB;WAQbuL,YAAYA,CACjBprB,IAAmB,EACnBsO,EAAiB,EACjBoN,IAAY,EACZC,MAAc,EACd5M,KAAa;;IAIT,IAAA/O,IAAI,YAAYyd,IAAI,EAAEzd,IAAI,GAAGA,IAAI,CAACygB,OAAO;IACzC,IAAAnS,EAAE,YAAYmP,IAAI,EAAEnP,EAAE,GAAGA,EAAE,CAACmS,OAAO;QAEnC4K,IAAI;IACF,MAAA9K,OAAO,GAAGlD,aAAa,CACzBrd,IAAI,CAACygB,OAAO,IACZnS,EAAE,CAACmS,OAAO,EACV,EAAA/E,IAAI,EACJC,MAAM,EACN2B,oBAAoB;IAEpB,IAAA1O,IAAI,GAAG,CAAC;IACR,IAAA+R,cAAc,GAAG,CAAC;IACtBJ,OAAO,CAACnnB,OAAO,WAAWwnB,MAAM;MAC5BhS,IAAI,GAAG+R,cAAc;MACrBA,cAAc,GAAG9R,iBAAiB,CAAC+R,MAAM,CAACtS,EAAE,EAAEgd,MAAM,EAAEC,IAAI,EAAEC,OAAO;MACnEH,IAAI,CAAClwB,IAAI;QACL4T,KAAK,EAAE4R,cAAc,GAAG/R,IAAI;QAC5B5O,IAAI,EAAE4gB,MAAM,CAAC5gB,IAAI;QACjBsO,EAAE,EAAEsS,MAAM,CAACtS,EAAE;QACPM,IAAI;QACVoP,QAAQ,EAAE4C,MAAM,CAAC5C,QAAQ;QACrB,IAAA4C,MAAM,CAAC3C,aAAa,IAAM;UAAAmE,gBAAgB,EAAEgI;QAAc;;;WAG/DiB,IAAI;;EAGf5nB,UAAU,CAAC,YAAY;IACnBzD,IAAI,EAAEupB,KAAK;IACXjb,EAAE,EAAEkb,GAAG;IACPza,KAAK,EAAE0b,MAAM;IACbH,YAAY;IACZC,aAAa;IACbC;;EAGJ/mB,UAAU,CAAC,SAAS;IAChBmb,WAAW;IACXtK,eAAe;IACfL,WAAW;IACXhG,UAAU,EAAEqb,WAAW;IACvB7Q,SAAS,EAAE4Q,UAAU;IACFnV,iBAAiB;IACpCE,mBAAmB;IACnBC,kBAAkB;IAClBF;;QAGEuE,UAAU,GAAGjO,QAAQ,CAAkB,IAAI;;QAC3CkO,WAAW,GAAGlO,QAAQ,CAAkB,IAAI;;EAE5C,MAAAghB,YAAY,GACd;IAAAvC,WAAW;IACXxQ,UAAU;IACVC;EAAA;EAEJlV,UAAU,CAAC,OAAO,EAAEgoB,YAAY;EAEhCroB,OAAO;IACHpK,MAAM,CAACP,MAAM,CAACgzB,YAAY;MACtB1X,YAAY;MACZC,aAAa;MACbiV;;IAGJzU,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,MAAM;IACjCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,QAAQ;IACnCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,WAAW;IACtCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,SAAS;IACpCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,QAAQ;IACnCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,SAAS;IACpCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,aAAa;IACxCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,cAAc;IACzCtO,GAAG,CAACsO,aAAa,CAAC,OAAO,EAAE,YAAY;IACvCtO,GAAG,CAACsO,aAAa,CAAC,YAAY,EAAE,SAAS;IACzCtO,GAAG,CAACsO,aAAa,CAAC,YAAY,EAAE,SAAS;IAEzClN,YAAA,KAAAuT,OAAO,GAAG,IAAI;;EAGV;IAAA1D,gBAAgB;IAAEC,iBAAiB;IAAEC;EAAO,IAAKH,8BAA8B;EAEvFC,gBAAgB,CAAC,WAAW,EAAE,cAAc,GAAGxmB,KAAK,EAAEL,IAAI,EAAElB,MAAM;IACxD,MAAA8mB,MAAM,GAAG5lB,IAAI;QACfmR,WAAW,CAAC9Q,KAAK,CAAM,KAAAvB,MAAM,CAAC+D,SAAS,CAACiqB,QAAQ,CAAC,mBAAmB;MAChE,IAAAzsB,KAAK,CAAC0sB,OAAO;QACbjX,gBAAgB,CAACgQ,eAAe,CAACF,MAAM,EAAE9mB,MAAM;;QAE/CgX,gBAAgB,CAAC6P,YAAY,CAACC,MAAM,EAAE9mB,MAAM;;MAEhDgX,gBAAgB,CAACmQ,sBAAsB,CAACL,MAAM,EAAEvlB,KAAK;;IAEzDuV,GAAG,CAAC,OAAO,EAAEqB,KAAK,CAAC+V,MAAM,CAAC7V,UAAU,CAAC7J,QAAQ,CAACsY,MAAM;;EAGxDiB,gBAAgB,CAAC,WAAW,EAAE,aAAa,GAAGxmB,KAAK,EAAEL,IAAI,EAAElB,MAAM;IAC7DP,eAAA,CAAAub,UAAA,EAAAmT,WAAW,GAAGjtB,IAAI,EAAAitB,WAAA;;EAGtBpG,gBAAgB,CAAC,OAAO,EAAE,aAAa,GAAGxmB,KAAK,EAAEL,IAAI,EAAElB,MAAM;IACzDgX,gBAAgB,CAAC+P,aAAa;IAC1B,IAAAqH,YAAY,IAAIltB,IAAI;MACpBzB,eAAA,CAAAwb,WAAA,EAAAmT,YAAY,GAAG,IAAI,EAAAA,YAAA;;;IAGvB3uB,eAAA,CAAAwb,WAAA,EAAAmT,YAAY,GAAGltB,IAAI,EAAAktB,YAAA;;EAGvBrG,gBAAgB,CAAC,UAAU,EAAE,cAAc,GAAGxmB,KAAK,EAAEL,IAAI,EAAElB,MAAM;IACvD,MAAA8mB,MAAM,GAAG5lB,IAAI;IACnB4V,GAAG,CAAC,OAAO,CAAE,CAAAqB,KAAK,CAACkW,UAAU,CAAChW,UAAU,CAAC7J,QAAQ,CAACsY,MAAM,GAAGvlB,KAAK;;EAGpEwmB,gBAAgB,CAAC,YAAY,EAAE,OAAO,GAAGxmB,KAAK,EAAEL,IAAI,EAAElB,MAAM;IACxDP,eAAA,CAAAub,UAAA,EAAAmT,WAAW,GAAG,IAAI,EAAAA,WAAA;;EAGtBvoB,SAAS;IACLoiB,iBAAiB,CAAC,OAAO,EAAE,cAAc;IACzCA,iBAAiB,CAAC,OAAO,EAAE,aAAa;IACxCA,iBAAiB,CAAC,WAAW,EAAE,cAAc;IAC7CA,iBAAiB,CAAC,UAAU,EAAE,cAAc;IAE5ChR,gBAAgB,CAAC+P,aAAa;;EAG9B,IAAAuH,WAAW,GAAG,CAAC;EAEV,SAAAC,UAAUA,CAACtuB,IAAI;IACd,MAAAuuB,QAAQ,GAAGjtB,KAAK;;QACViW,SAAS;QAAEF;MAAU,IAAKrX,IAAI;MAEtCurB,WAAW,CAAC9vB,OAAO,CAAC6yB,UAAU;YACtBA,UAAU,CAACE,WAAW,KAAK,YAAY;UACvCF,UAAU,CAACtuB,IAAI,CAACqX,UAAU,GAAGA,UAAU;;UAEvCiX,UAAU,CAACtuB,IAAI,CAACuX,SAAS,GAAGA,SAAS;;;MAI7CU,YAAA,KAAAoW,WAAW,GAAG9W,SAAS;;IAI3BvX,IAAI,CAACyB,gBAAgB,CAAC,QAAQ,EAAE8sB,QAAQ;;MAEpC1uB,OAAOA,CAAA;QACHG,IAAI,CAAC0B,mBAAmB,CAAC,QAAQ,EAAE6sB,QAAQ,EAAE,KAAK;;;;EAKrD,SAAAE,wBAAwBA,CAACzuB,IAAI;IAClCurB,WAAW,CAAC/tB,IAAI;MAAGwC,IAAI;MAAEwuB,WAAW,EAAE;IAAY;;EAG7C,SAAAzU,QAAQA,CAACzY,KAAK;IACnB2W,YAAA,IAAAkU,UAAU,GAAG7qB,KAAK,CAAC2C,MAAM,CAACgN,IAAI;;EAG9B,IAAAyd,SAAS,GAAG,CAAC;EACb,IAAAC,OAAO,GAAG,KAAK;EACJ,eAAAC,OAAOA,CAACttB,KAAiB;IAChC,IAAAA,KAAK,CAAC0sB,OAAO;MACb1sB,KAAK,CAACgb,cAAc;MAEd,MAAAuS,aAAa,GAAGH,SAAS;UAC3BptB,KAAK,CAACwtB,MAAM,GAAG,CAAC;QAChBJ,SAAS,GAAGrwB,IAAI,CAACC,GAAG,CAACowB,SAAS,GAAG,CAAC,EAAE,CAAC;;QAErCA,SAAS,GAAGrwB,IAAI,CAAC8kB,GAAG,CAACuL,SAAS,GAAG,CAAC,EAAExC,UAAU,CAACzvB,MAAM,GAAG,CAAC;;MAGzD,IAAAoyB,aAAa,IAAIH,SAAS,IAAIxC,UAAU,CAACwC,SAAS;cAC5CltB,OAAO;UACG6qB,UAAU;UACRC,YAAY;UAC1BR,QAAQ,EAAEiD,UAAU;UACjB,GAAA7C,UAAU,CAACwC,SAAS;;QAGrB,MAAAM,KAAK,GAAGxtB,OAAO,CAACsqB,QAAQ,GAAG+B,OAAO;QAClC,MAAA7tB,IAAI,GAAGqW,aAAa;QACpB,MAAA4Y,QAAQ,GAAG3c,cAAc,CAACtS,IAAI,EAAEsB,KAAK;QACrC,MAAA4tB,MAAM,GAAGlvB,IAAI,CAACqX,UAAU,GAAG4X,QAAQ,CAACxc,CAAC;cACrC0c,KAAK,GAAGD,MAAM,GAAGF,KAAK;cACtB3X,UAAU,GAAG8X,KAAK,GAAGF,QAAQ,CAACxc,CAAC,GAAGzS,IAAI,CAACovB,WAAW,GAAG,CAAC;wBAE5D/C,UAAU,GAAG7qB,OAAO,CAAC6qB,UAAU;yBAC/BC,YAAY,GAAG9qB,OAAO,CAAC8qB,YAAY;mCACnCyC,UAAU,GAAGvtB,OAAO,CAACsqB,QAAQ,EAAAiD,UAAA;QAEzB,IAAAvtB,OAAO,CAAC6hB,OAAO,EAAApL,YAAA,IAAEoL,OAAO,GAAG7hB,OAAO,CAAC6hB,OAAO;QAE1C,IAAA7hB,OAAO,CAACuqB,QAAQ,EAAAvsB,eAAA,CAAAysB,SAAA,EAAEoD,UAAU,GAAG7tB,OAAO,CAACuqB,QAAQ,EAAAsD,UAAA;QAEnDxY,GAAG,CAAC,OAAO,CAAE,CAAAqB,KAAK,CAACoX,WAAW;QAC9BrX,YAAA,KAAA0W,OAAO,GAAG,IAAI;cACR7nB,IAAI;QACV9G,IAAI,CAACqX,UAAU,GAAGA,UAAU;QAC5BY,YAAA,KAAA0W,OAAO,GAAG,KAAK;;;;EAKlB,SAAAY,cAAcA,CAACjuB,KAAK;IACzB9B,eAAA,CAAAosB,KAAA,EAAA+B,MAAM,GAAGrsB,KAAK,CAAC2C,MAAM,CAAC5B,IAAI,EAAAsrB,MAAA;IAC1BnuB,eAAA,CAAAqsB,GAAA,EAAA+B,IAAI,GAAGtsB,KAAK,CAAC2C,MAAM,CAAC0M,EAAE,EAAAid,IAAA;IACtB/W,GAAG,CAAC,OAAO,CAAE,CAAAqB,KAAK,CAACsX,YAAY,CAAG;MAAAntB,IAAI,EAAEsrB,MAAM;MAAEhd,EAAE,EAAEid;IAAI;;EAGnD,SAAA6B,QAAQA,CAACC,QAAQ;;IAEhB,MAAA3J,IAAI,GAAG4J,UAAU,CAAC7J,UAAU,CAAC4J,QAAQ;IAC3CjgB,QAAQ,CAACN,MAAM,CAAC4W,IAAI;;EAGT,eAAA6J,SAASA,CAACC,QAAQ;UACvB/oB,IAAI;UAEJ6K,KAAK;UACL2H,IAAI;MAAKhJ,UAAU,EAAEwf;IAAY;IACvCD,QAAQ,CAACp0B,OAAO,CAACgJ,CAAC;MACR,MAAAwL,IAAI,GAAG8f,WAAW,CAACvf,UAAU,CAAC/L,CAAC;YAC/BmN,GAAG,GAAGgG,SAAS,CAACrJ,QAAQ,CAAC0B,IAAI,CAACvB,KAAK,CAACwB,UAAU;MACpDD,IAAI,CAACwB,WAAW;UAEZiF,kBAAkB,IAAI9E,GAAG,CAACyH,WAAW;QACrCzH,GAAG,CAACyH,WAAW,CAAC5d,OAAO,CAACwM,CAAC;UACf,MAAAsR,aAAa,GAAGzH,WAAW,CAAC7B,IAAI,EAAEhI,CAAC,EAAEqR,IAAI;UAC/CrJ,IAAI,CAACwB,WAAW,CAACjU,IAAI,CAAC+b,aAAa,CAAC7K,KAAK,CAACC,EAAE;UAC5CgD,KAAK,CAACnU,IAAI,CAAC+b,aAAa;;;MAI5B,IAAA9C,mBAAmB,IAAI7E,GAAG,CAAC4H,UAAU,CAAC/c,MAAM,GAAG,CAAC;QAChDmV,GAAG,CAAC4H,UAAU,CAAC/d,OAAO,CAACwM,CAAC;UACd,MAAAsR,aAAa,GAAGzH,WAAW,CAAC7B,IAAI,EAAEhI,CAAC,EAAEqR,IAAI;UAC/CrJ,IAAI,CAACwB,WAAW,CAACjU,IAAI,CAAC+b,aAAa,CAAC7K,KAAK,CAACC,EAAE;UAC5CgD,KAAK,CAACnU,IAAI,CAAC+b,aAAa;;;MAIhC5H,KAAK,CAACnU,IAAI,CAACyS,IAAI;;IAEnBT,SAAS,CAACL,MAAM,CAACwC,KAAK;;EAGjB,SAAAqe,cAAcA,CAACC,aAAa;IAC3B,MAAAxE,UAAU,GAAGwE,aAAa,CAACplB,GAAG,CAACqlB,SAAS;aACnCC,gBAAgB,CAAC70B,MAAM,CAAC40B,SAAS;;IAE5CxgB,cAAc,CAACP,MAAM,CAACsc,UAAU;;EAKvB,MAAA5U,GAAG,OAAOmO,QAAQ;QACzBjO,gBAAgB,OAAO2P,gBAAgB,CAAClX,SAAS;QAE1CugB,WAAW,OAAO3f,WAAW,CAACC,aAAa;EAM3C,MAAAsf,UAAU,OAAOhK,UAAU;QAG3B/O,UAAU,OAAOkG,eAAe,CAACrN,QAAQ;QACzC0gB,gBAAgB,OAAO3J,gBAAgB,CAACnW,aAAa;EAErD,MAAAyG,KAAK,OAAO+J,UAAU;EAanC/a,UAAU,CAAC,UAAU;IACjBgR,KAAK;IACLD,GAAG;IACHD,UAAU;IACVG,gBAAgB;IAChB1G;;WAGY+f,iBAAiBA,CAAA;IAC7B1gB,cAAc,CAAClB,OAAO,CAAI;MAAAF,GAAG;MAAEC;IAAQ;MACnCD,GAAG,CAAC7S,OAAO,CAACkT,EAAE;cACJuhB,SAAS,GAAG3hB,QAAQ,CAACI,EAAE;cACvBiK,OAAO,GAAGvI,aAAa,CAACa,iBAAiB,CAACgf,SAAS,CAACxhB,KAAK,CAACrM,IAAI,IAAI,CAAC;cACnEwW,QAAQ,GAAGxI,aAAa,CAACa,iBAAiB,CAACgf,SAAS,CAACxhB,KAAK,CAACiC,EAAE,IAAI,CAAC;QAExEuf,SAAS,CAACjf,IAAI,GAAG2H,OAAO;QACxBsX,SAAS,CAAC9e,KAAK,GAAGyH,QAAQ,GAAGD,OAAO;;MAE/B;QAAAtK,GAAG;QAAEC;MAAQ;;;WAId8hB,YAAYA,CAAA;IACxBtgB,SAAS,CAACtU,OAAO,CAACwU,IAAI;YACZ2I,OAAO,GAAGvI,aAAa,CAACa,iBAAiB,CAACjB,IAAI,CAACvB,KAAK,CAACrM,IAAI,IAAI,CAAC;YAC9DwW,QAAQ,GAAGxI,aAAa,CAACa,iBAAiB,CAACjB,IAAI,CAACvB,KAAK,CAACiC,EAAE,IAAI,CAAC;MAEnEV,IAAI,CAACgB,IAAI,GAAG2H,OAAO;MACnB3I,IAAI,CAACmB,KAAK,GAAGyH,QAAQ,GAAGD,OAAO;;IAEnCpJ,SAAS,CAACJ,OAAO;;WAGLkhB,eAAeA,CAAA;WACpBla,YAAY;;EAGP,SAAAma,UAAUA,CAAC5hB,EAAE;IACnB,MAAAsB,IAAI,GAAGmI,UAAU,CAAC7J,QAAQ,CAACI,EAAE;QAC/BsB,IAAI;MACJ8G,gBAAgB,CAAC6P,YAAY,CAACjY,EAAE,EAAE0c,YAAY,CAACmF,aAAa,kBAAkB7hB,EAAE;;;WAIxE8hB,aAAaA,CAAA;IACzB1Z,gBAAgB,CAAC+P,aAAa;;EAGlB,SAAA4J,WAAWA,CAAC/hB,EAAE,EAAEgiB,cAAc,GAAG,MAAM;;MAC3CpZ,SAAS;MAAEqZ;IAAY,IAAKva,aAAa;IAE3C,MAAAhK,KAAK,GAAGwkB,QAAQ,CAACC,SAAS,CAAC7oB,CAAC,IAAIA,CAAC,CAACyG,KAAK,CAACC,EAAE,IAAIA,EAAE;IAClD,IAAAtC,KAAK,MAAM,CAAC;UACV0kB,SAAS,GAAG1kB,KAAK,GAAGyO,SAAS;IAE/B,IAAAiW,SAAS,GAAGxZ,SAAS;MACrBlB,aAAa,CAACe,QAAQ,CAClB;QAAA7F,GAAG,EAAEwf,SAAS;QACdzZ,QAAQ,EAAEqZ;MAAA;;QAIdI,SAAS,GAAGxZ,SAAS,GAAGqZ,YAAY;MACpCva,aAAa,CAACe,QAAQ;QAClB7F,GAAG,EAAEwf,SAAS,GAAGjW,SAAS,GAAG8V,YAAY;QACzCtZ,QAAQ,EAAEqZ;;;;EAKN,SAAAK,YAAYA,CAACriB,EAAE,EAAEgiB,cAAc,GAAG,MAAM;IAC5C;MAAAtZ,UAAU;MAAEE,SAAS;MAAE6X,WAAW;MAAEwB;IAAY,IAAKva,aAAa;IAEpE,MAAApG,IAAI,GAAGmI,UAAU,CAAC7J,QAAQ,CAACI,EAAE;SAC9BsB,IAAI;UACHghB,UAAU,GAAGhhB,IAAI,CAACgB,IAAI;IACtB,MAAAigB,QAAQ,GAAGL,QAAQ,CAACC,SAAS,CAAC7oB,CAAC,IAAIA,CAAC,CAACyG,KAAK,CAACC,EAAE,IAAIsB,IAAI,CAACvB,KAAK,CAACwB,UAAU;UACtE6gB,SAAS,GAAGG,QAAQ,GAAGpW,SAAS;UAEhCtZ,OAAO;MACT+P,GAAG,EAAEzU,SAAS;MACdmU,IAAI,EAAEnU,SAAS;MACfwa,QAAQ,EAAEqZ;;IAGV,IAAAM,UAAU,GAAG5Z,UAAU;MACvB7V,OAAO,CAACyP,IAAI,GAAGggB,UAAU;;QAGzBA,UAAU,GAAG5Z,UAAU,GAAG+X,WAAW;MACrC5tB,OAAO,CAACyP,IAAI,GAAGggB,UAAU,GAAGhhB,IAAI,CAACmB,KAAK,GAAGge,WAAW;;IAGpD,IAAA2B,SAAS,GAAGxZ,SAAS;MACrB/V,OAAO,CAAC+P,GAAG,GAAGwf,SAAS;;QAGvBA,SAAS,GAAGxZ,SAAS,GAAGqZ,YAAY;MACpCpvB,OAAO,CAAC+P,GAAG,GAAGwf,SAAS,GAAGjW,SAAS,GAAG8V,YAAY;;IAGtDva,aAAa,CAACe,QAAQ,CAAC5V,OAAO;;EAGlB,SAAA2vB,UAAUA,CAACziB,KAAK;IACtB,MAAAuB,IAAI,GAAG8f,WAAW,CAACvf,UAAU,CAAC9B,KAAK;IACzCc,SAAS,CAACT,MAAM,CAACkB,IAAI;;EAGT,SAAAmhB,WAAWA,CAACC,UAAU;UAC5B1f,KAAK,GAAG0f,UAAU,CAACxmB,GAAG,CAAC6D,KAAK,IAAIqhB,WAAW,CAACvf,UAAU,CAAC9B,KAAK;IAClEc,SAAS,CAACP,SAAS,CAAC0C,KAAK;;EAGb,SAAA2f,SAASA,CAAC5iB,KAAK;IACrB,MAAAkD,GAAG,GAAG+d,UAAU,CAAC/J,SAAS,CAAClX,KAAK,EAAE,IAAI;IAC5Ce,QAAQ,CAACV,MAAM,CAAC6C,GAAG;;EAGP,SAAA2f,UAAUA,CAACtL,SAAS;IAC1B,MAAAF,IAAI,GAAGE,SAAS,CAACpb,GAAG,CAAC6D,KAAK,IAAIihB,UAAU,CAAC/J,SAAS,CAAClX,KAAK,EAAE,IAAI;IACpEe,QAAQ,CAACR,SAAS,CAAC8W,IAAI;;EAGX,SAAAyL,MAAMA,CAACthB,UAAU;WACtB0H,SAAS,CAACrJ,QAAQ,CAAC2B,UAAU;;EAGxB,SAAAuhB,OAAOA,CAAC9iB,EAAE;WACfyJ,UAAU,CAAC7J,QAAQ,CAACI,EAAE;;EAGjB,SAAA+iB,QAAQA,CAACxhB,UAAU;IAC3B,IAAAyhB,aAAa,CAACzhB,UAAU;aACjByhB,aAAa,CAACzhB,UAAU,EAAErF,GAAG,CAAC8D,EAAE,IAAIyJ,UAAU,CAAC7J,QAAQ,CAACI,EAAE;;WAE9D,IAAI;;MAGXijB,YAAY;MAGZC,qBAA8B;MAG9BC,kBAAkB;MAGlBC,UAAU;MAGVC,QAAQ;EAMR,IAAAC,UAAU,GAAG,CAAC;EAGd,IAAAC,aAAa,GAAG,CAAC;MAGjBC,WAAW;MAGXC,YAA0B;;;MAsEQ9G,mBAAmB,GAAA+G,OAAA;;;;;IAAqBC,aAAa,QAAA1B,YAAA;;;;;MA8BhExa,YAAY,GAAAic,OAAA;;;;;;MAZpBhc,aAAa,GAAAgc,OAAA;;;;;IAILE,cAAc,QAAA3B,YAAA;;IACf4B,aAAa,QAAApD,WAAA;;;;;MA9C5B/D,YAAY,GAAAgH,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA7qBhB,IAAA7G,OAAO,EAAEiE,QAAQ,CAAC1J,IAAI;;;MACtB,IAAAyF,OAAO,EAAEoE,SAAS,CAACje,KAAK;;;MACxB,IAAA6Z,OAAO,EAAEwE,cAAc,CAACvE,UAAU;;;MAMxCjsB,eAAA,CAAAksB,UAAA,EAAE+G,WAAW,GAAG3X,SAAS,EAAA2X,WAAA;;;MACzBjzB,eAAA,CAAAmsB,WAAA,EAAEmE,YAAY,GAAGxf,UAAU,EAAAwf,YAAA;;;MAWzBtwB,eAAA,CAAAosB,KAAA,EAAA+B,MAAM,GAAGxC,SAAS,CAAC9oB,IAAI,GAAAsrB,MAAA;;;MACvBnuB,eAAA,CAAAqsB,GAAA,EAAA+B,IAAI,GAAGzC,SAAS,CAACxa,EAAE,GAAAid,IAAA;;;MAMrB;QACGpuB,eAAA,CAAAwsB,SAAA,EAAA+C,UAAU,GAAGjD,QAAQ,EAAAiD,UAAA;QACrBvvB,eAAA,CAAAysB,SAAA,EAAAoD,UAAU,GAAGtD,QAAQ,EAAAsD,UAAA;;;;MAoCtBjD,iBAAiB,CAACrL,UAAU,EAAED,YAAY;;;MAyG5C;yBACGoB,OAAO,GAAGuL,YAAY,CAACE,MAAM,EAAEC,IAAI,EAAEvB,UAAU,EAAEC,YAAqB;QACtEiB,wBAAwB;QACxB6C,iBAAiB;QACjBC,YAAY;;;;MAkRf;yBACGN,WAAW,CAACzf,UAAU,GAAGwf,YAAY,EAAAC,WAAA;QACrC9X,YAAA,KAAA8X,WAAW,CAACxf,WAAW,GAAGqH,SAAS,CAACrJ,QAAQ,EAAAwhB,WAAA;;;;MAI7C9X,YAAA,KAAA0X,UAAU,CAAC7U,SAAS,GAAGA,SAAS,EAAA6U,UAAA;;;MAMlC;yBACG7Y,KAAK,CAACzU,IAAI,GAAGsrB,MAAM,EAAA7W,KAAA;yBACnBA,KAAK,CAACnG,EAAE,GAAGid,IAAI,EAAA9W,KAAA;yBACfA,KAAK,CAAC1F,KAAK,GAAGyc,OAAO,EAAA/W,KAAA;yBACrBA,KAAK,CAACgK,YAAY,GAAGA,YAAY,EAAAhK,KAAA;yBACjCA,KAAK,CAACiK,UAAU,GAAGA,UAAU,EAAAjK,KAAA;yBAC7BA,KAAK,CAACkK,cAAc,GAAGA,cAAc,EAAAlK,KAAA;yBACrCA,KAAK,CAACmK,WAAW,GAAGA,WAAW,EAAAnK,KAAA;;;;;MAiJlCmB,YAAA,MAAE2Z,YAAY,GAAGf,QAAQ,CAAC/lB,MAAM,CAAC8G,GAAG,KAAKA,GAAG,CAAC8gB,MAAM;;;MAMpDza,YAAA,IAAG6Z,kBAAkB,GAAGF,YAAY,CAACn1B,MAAM,GAAGqe,SAAS;;;MAHpD7C,YAAA,KAAA4Z,qBAAqB,GAAGC,kBAAkB,GAAGS,cAAc;;;MAM7Dta,YAAA,MAAE8Z,UAAU,GAAG1zB,IAAI,CAACujB,KAAK,CAACyM,WAAW,GAAGvT,SAAS;;;MAGjD7C,YAAA,MAAE+Z,QAAQ,GAAG3zB,IAAI,CAAC8kB,GAAG,CAClB4O,UAAU,GAAG1zB,IAAI,CAACsrB,IAAI,CAAC4I,cAAc,GAAGzX,SAAS,GACjD8W,YAAY,CAACn1B,MAAM,GAAG,CAAC;;;MAIxBwb,YAAA,KAAAga,UAAU,GAAGF,UAAU,GAAGjX,SAAS;;;MAGrC7C,YAAA,KAAEia,aAAa,IAAIN,YAAY,CAACn1B,MAAM,GAAGu1B,QAAQ,GAAG,CAAC,IAAIlX,SAAS;;;MAGlE7C,YAAA,KAAEka,WAAW,GAAGP,YAAY,CAAC7zB,KAAK,CAACg0B,UAAU,EAAEC,QAAQ,GAAG,CAAC;;;MAG3D;cACSrgB,KAAK;cACLghB,QAAQ;iBACLp0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4zB,WAAW,CAAC11B,MAAM,EAAE8B,CAAC;gBAC/BqT,GAAG,GAAGugB,WAAW,CAAC5zB,CAAC;UACrB,IAAAozB,aAAa,CAAC/f,GAAG,CAAClD,KAAK,CAACC,EAAE;YACjB,SAAAikB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,aAAa,CAAC/f,GAAG,CAAClD,KAAK,CAACC,EAAE,CAAE,CAAAlS,MAAM,EAAEm2B,CAAC;oBAC/CjkB,EAAE,GAAGgjB,aAAa,CAAC/f,GAAG,CAAClD,KAAK,CAACC,EAAE,EAAEikB,CAAC;cACxCjhB,KAAK,CAACnU,IAAI,CAAC4a,UAAU,CAAC7J,QAAQ,CAACI,EAAE;cACjCgkB,QAAQ,CAAChkB,EAAE,IAAI,IAAI;;;;;;QAMpB,WAAAA,EAAE,IAAI0J,kBAAkB;UAC1B,KAAAsa,QAAQ,CAAChkB,EAAE;YACZgD,KAAK,CAACnU,IAAI,CAAC4a,UAAU,CAAC7J,QAAQ,CAACI,EAAE;YACjCgkB,QAAQ,CAAChkB,EAAE,IAAI,IAAI;;;QAI3BsJ,YAAA,KAAAma,YAAY,GAAGzgB,KAAK;;;;MAGvB;QACO,IAAA+a,QAAM,KAAK,MAAM;qBACNrP,KAAK,IAAIzF,SAAS,CAACtJ,GAAG;;kBAEvBukB,OAAO,GAAGlB,aAAa,CAACtU,KAAK;gBAC/BwV,OAAO;oBACDlhB,KAAK,GAAGkhB,OAAO,CAAChoB,GAAG,CAACgc,MAAM,IAAIzO,UAAU,CAAC7J,QAAQ,CAACsY,MAAM;cAC9D+C,MAAiB,CAACjY,KAAK;gBACnBoY,gBAAgB,EAAEjP,SAAS,GAAGxK,UAAU,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICzrBlD,YAAA3S,GAAG,IAACkoB,QAAQ,SAAAiN,mBAAA;;;;;;;;;;;;MADrB5yB,MAMM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;yDANkCxC,GAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAI9CuC,MAAkC,CAAAH,MAAA,EAAAxB,CAAA,EAAA4B,MAAA;;;;;;;;;;;;;;;;;;;MAFlCD,MAAiC,CAAAH,MAAA,EAAAxB,CAAA,EAAA4B,MAAA;;;;;;;;;;;;;EAHxC,IAAA8a,QAAA,UAAAtd,GAAG,IAACwE,QAAQ,IAAA4wB,iBAAA,CAAAp1B,GAAA;;;;;;;;;;4CAD4BA,GAAG,IAAC2oB,UAAU,GAAG,CAAC;;;MAAnEpmB,MAWM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;MAVG,YAAAxC,GAAG,IAACwE,QAAQ;;;;;;;;;;;;;;;;;;8CAD4BxE,GAAG,IAAC2oB,UAAU,GAAG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;IAbpD1U;EAAc,IAAAkE,OAAA;EAEnB,MAAAqM,QAAQ,GAAGvc,qBAAqB;WAE7BotB,cAAcA,CAAA;IACf,IAAAphB,GAAG,CAACiU,QAAQ;MACZ1D,QAAQ,CAAC,cAAc;QAAIvQ;MAAG;;MAE9BuQ,QAAQ,CAAC,aAAa;QAAIvQ;MAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBCuCpBjU,GAAG,IAAC+Q,KAAK,CAACukB,SAAS,IAAAC,iBAAA,CAAAv1B,GAAA;;gBAMnBA,GAAG,IAAC+Q,KAAK,CAACykB,UAAU,SAAAC,iBAAA;IAEf,eAAAz1B,GAAM,KAAC01B,QAAQ,SAAAC,iBAAA;mBAEf31B,GAAM,KAACqG,IAAI,KAAK,cAAc,SAAAuvB,iBAAA;;;;;;;;;;;;;;;;;;;kBAVnC51B,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mEAENt1B,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;MADjC/yB,MAEM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;MADFL,MAAmC,CAAAuU,GAAA,EAAA9V,CAAA;;;6FAAzBZ,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;;;;;;;;;;;EAchC,IAAA3e,OAAA,UAAA3W,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ;;;;;;;;;;MAAzB,IAAAv1B,KAAA,wBAAAqW,OAAA,MAAAA,OAAA,UAAA3W,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ,SAAAjxB,QAAA,CAAAkC,CAAA,EAAA6P,OAAA;;;;;;;;;;;;;;;;EAHrB,IAAAmf,QAAA,UAAA91B,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ;;;;;;;;;yDAFM71B,GAAG,IAAC+Q,KAAK,CAACglB,QAAQ,GAAA5xB,IAAA,CAAA6xB,GAAA,SAAAC,aAAA;;;;;MAAtD1zB,MAAiE,CAAAH,MAAA,EAAA4zB,GAAA,EAAAxzB,MAAA;;MACjED,MAEM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;6EAH8BxC,GAAG,IAAC+Q,KAAK,CAACglB,QAAQ;;;MAEjD,IAAAz1B,KAAA,wBAAAw1B,QAAA,MAAAA,QAAA,UAAA91B,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ,SAAAjxB,QAAA,CAAAsxB,EAAA,EAAAJ,QAAA;;;;;;;;;;;;;;;4BAJvB91B,GAAM,KAAC01B,QAAQ,SAAC11B,GAAG;;;;;;;;;;;;;4EAAnBA,GAAM,KAAC01B,QAAQ,SAAC11B,GAAG,YAAA6W,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;yBAFnB5W,GAAG,IAAC+Q,KAAK,CAACykB,UAAU;;;;;;;;;;;;;gEAApBx1B,GAAG,IAAC+Q,KAAK,CAACykB,UAAU,QAAA3e,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;;;;;;;mEApBT5W,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;MADjC/yB,MAEM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;MADFL,MAAmC,CAAAuU,GAAA,EAAA9V,CAAA;;;6FAAzBZ,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;;;;;;;;;;;EAShC,IAAA3e,OAAA,UAAA3W,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ;;;;;;;;;;MAAzB,IAAAv1B,KAAA,wBAAAqW,OAAA,MAAAA,OAAA,UAAA3W,GAAG,CAAC,GAAA+Q,KAAK,WAAC/Q,GAAM,KAAC61B,QAAQ,SAAAjxB,QAAA,CAAAkC,CAAA,EAAA6P,OAAA;;;;;;;;;;;;;4BAFnB3W,GAAM,KAAC01B,QAAQ,SAAC11B,GAAG;;;;;;;;;;;;;4EAAnBA,GAAM,KAAC01B,QAAQ,SAAC11B,GAAG,YAAA6W,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;yBAFnB5W,GAAG,IAAC+Q,KAAK,CAACykB,UAAU;;;;;;;;;;;;;gEAApBx1B,GAAG,IAAC+Q,KAAK,CAACykB,UAAU,QAAA3e,QAAA,CAAA1V,CAAA,CAAAyV,SAAA;;;;;;;;;;;;;;;yBAP1B5W,GAAG,IAAC+Q,KAAK,CAACukB,SAAS,IAAAa,iBAAA,CAAAn2B,GAAA;;gBAMnBA,GAAG,IAAC+Q,KAAK,CAACykB,UAAU,SAAAY,iBAAA;IAEf,eAAAp2B,GAAM,KAAC01B,QAAQ,SAAAW,iBAAA;;;;;;;;;;;;;;;;;;;kBARpBr2B,GAAG,IAAC+Q,KAAK,CAACukB,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAF3Bt1B,GAAM,KAACqG,IAAI,IAAI,MAAM;;;;;;;;;;;MAD8BxB,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,KAACyT,KAAK;;;MAAxElR,MAqCM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;QArCsDqC,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,KAACyT,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;iDADrEzT,GAAO;;iCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;8DAPOZ,GAAG,IAAC+Q,KAAK,CAACC,EAAE;6CACVhR,GAAU;MACJmE,IAAA,CAAAuS,GAAA,WAAA4f,eAAA,8BAAAt2B,GAAG,CAAC,GAAA+Q,KAAK,CAACgC,OAAO,IAAI,EAAE;MACrB9M,YAAA,CAAAyQ,GAAA,4BAAA1W,GAAG,IAACkoB,QAAQ;MACnBjiB,YAAA,CAAAyQ,GAAA,6BAAA1W,GAAW,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;MACxB/K,YAAA,CAAAyQ,GAAA,iCAAA1W,GAAY,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;MANnDzO,MAgDM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;;mDAxCKxC,GAAO;;mCAAZlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;4BAAJ9B,MAAI,EAAA8B,CAAA,GAAA6kB,WAAA,CAAA3mB,MAAA,EAAA8B,CAAA;;;;;oGAPOZ,GAAG,IAAC+Q,KAAK,CAACC,EAAE;;;;+CACVhR,GAAU;;MACJ,KAAAu2B,OAAA,IAAAj2B,KAAA,eAAAg2B,eAAA,MAAAA,eAAA,8BAAAt2B,GAAG,CAAC,GAAA+Q,KAAK,CAACgC,OAAO,IAAI,EAAE;;;;QACrB9M,YAAA,CAAAyQ,GAAA,4BAAA1W,GAAG,IAACkoB,QAAQ;;;QACnBjiB,YAAA,CAAAyQ,GAAA,6BAAA1W,GAAW,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;QACxB/K,YAAA,CAAAyQ,GAAA,iCAAA1W,GAAY,CAAI,aAAAA,GAAG,CAAC,GAAA+Q,KAAK,CAACC,EAAE;;;;;qCAE7ClS,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;EA1BK;IAAA8kB,OAAO,GAAkB;EAAI,IAAAvN,OAAA;EAC7B;IAAAlE,GAAG,GAAc;EAAI,IAAAkE,OAAA;;IAExBgF;EAAS,IAAK9U,UAAU,CAAC,SAAS;;EAClC;IAAA+U,UAAU;IAAEC;EAAW,CAAK,GAAAhV,UAAU,CAAC,OAAO;;;EAEhD,MAAAmc,QAAQ,GAAGvc,qBAAqB;EAOtCH,OAAO;QACCmM,GAAG,CAAClD,KAAK,CAACmX,QAAQ,IAAI,KAAK,EAAE1D,QAAQ,CAAC,cAAc;MAAIvQ;IAAG;;;;;;;;;;;;;;MALlE;QAC0BA,GAAG,CAAC3O,MAAM,G,iBAAoB2O,GAAG,CAAC0U,UAAU,GAAG,CAAC,QAAQ,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECmGxE,IAAAtE,QAAA,aAAArkB,GAAM,KAACw2B,KAAK;;;;;;;;;MAD6C3xB,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,KAACyT,KAAK;;;MAA1ElR,MAEM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;MADD,IAAAlC,KAAA,4BAAA+jB,QAAA,MAAAA,QAAA,aAAArkB,GAAM,KAACw2B,KAAK,QAAA5xB,QAAA,CAAAwf,EAAA,EAAAC,QAAA;;QAD6Cxf,SAAA,CAAA6R,GAAA,qBAAA1W,GAAM,KAACyT,KAAK;;;;;;;;;;;;;;;;;;+BAerDzT,GAAY;;;+CACLA,GAAa;iDACZA,GAAc;;;;;;;;;;;;oFAFtBA,GAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAhB9BA,GAAY;;mCAAjBlB,MAAI,EAAA8B,CAAA;;;qDAaSZ,GAAW;;iCAAhBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;iDAd0BZ,GAAa;;mDAYzBA,GAAU;yDAAoBA,GAAa;sDAAYA,GAAkB;;;+EAJ9CA,GAAsB;;6CATzCA,GAAU;;;MAAtDuC,MA0BM,CAAAH,MAAA,EAAA+qB,IAAA,EAAA3qB,MAAA;MAzBFL,MAMM,CAAAgrB,IAAA,EAAAtV,IAAA;;;;;;;;;;MAEN1V,MAgBM,CAAAgrB,IAAA,EAAAC,IAAA;MAfFjrB,MAcM,CAAAirB,IAAA,EAAAzN,IAAA;MAbFxd,MAYM,CAAAwd,IAAA,EAAAjI,IAAA;;;;;;;;;;;;;;0DArBH1X,GAAY;;qCAAjBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;4CAAJ9B,MAAI;;;mDADkCkB,GAAa;;;uDActCA,GAAW;;mCAAhBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;4BAAJ9B,MAAI,EAAA8B,CAAA,GAAA6kB,WAAA,CAAA3mB,MAAA,EAAA8B,CAAA;;;;;;qDAFcZ,GAAU;;;2DAAoBA,GAAa;;;wDAAYA,GAAkB;;;iFAJ9CA,GAAsB;;;+CATzCA,GAAU;;;;;qCAepClB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;AApCT,SAAA61B,IAAIA,CAACjyB,QAAQ;EAClBA,QAAQ,CAAC1G,OAAO,CAACmW,GAAG;IACZ,IAAAA,GAAG,CAACzP,QAAQ,EAAEiyB,IAAI,CAACxiB,GAAG,CAACzP,QAAQ;IACnCyP,GAAG,CAAC8gB,MAAM,GAAG,IAAI;;;AAIhB,SAAA2B,IAAIA,CAAClyB,QAAQ,EAAEuwB,MAAM,GAAG,KAAK;EAClCvwB,QAAQ,CAAC1G,OAAO,CAACmW,GAAG;QACZA,GAAG,CAACzP,QAAQ,EAAEkyB,IAAI,CAACziB,GAAG,CAACzP,QAAQ,GAAGyP,GAAG,CAACiU,QAAQ;IAClDjU,GAAG,CAAC8gB,MAAM,GAAGA,MAAM;;;;;;;;;;;EA9FrB,MAAAvQ,QAAQ,GAAGvc,qBAAqB;;IAO3BumB;EAAU,IAAArW,OAAA;;IACVmc;EAAU,IAAAnc,OAAA;;IACVoc;EAAa,IAAApc,OAAA;;IACbgc;EAAkB,IAAAhc,OAAA;;IAClBqc;EAAwB,IAAArc,OAAA;;IAKxBwe,YAAY,I;MAAqBH,KAAK,EAAE,MAAM;MAAEX,QAAQ,EAAE,OAAO;MAAEpiB,KAAK,EAAE;;;;IAE7E/O,IAAI;IAAEsO,EAAE;IAAES,KAAK;IAAEub,YAAY;IAAEE;EAAY,IAAK7mB,UAAU,CAAC,YAAY;;;;EACvE;IAAAsK,UAAU;IAAEwK;EAAS,CAAK,GAAA9U,UAAU,CAAC,SAAS;;;EAC9C;IAAAyJ,QAAQ;IAAED;EAAS,CAAK,GAAAxJ,UAAU,CAAC,WAAW;;;;IAC9CulB;EAAW,IAAKvlB,UAAU,CAAC,OAAO;EAE1CP,OAAO;IACH0c,QAAQ,CAAC,MAAM,EAAI;MAAAiJ,MAAM,EAAE;IAAI;;MAG/BmJ,eAAe;EACV,SAAAC,cAAcA,CAACx0B,IAAI;IACxBurB,WAAW,CAAC/tB,IAAI;MAAGwC,IAAI;MAAEwuB,WAAW,EAAE;IAAU;IAEvC,SAAAiG,QAAQA,CAACnzB,KAAK;MACnB2W,YAAA,IAAAsc,eAAe,CAACld,UAAU,GAAGrX,IAAI,CAACqX,UAAU,EAAAkd,eAAA;;IAGhDv0B,IAAI,CAACyB,gBAAgB,CAAC,QAAQ,EAAEgzB,QAAQ;;MAGpC50B,OAAOA,CAAA;QACHG,IAAI,CAAC0B,mBAAmB,CAAC,QAAQ,EAAE+yB,QAAQ;;;;MAKnDC,WAAW;EASN,SAAAC,aAAaA,CAACrzB,KAAK;IAClB,MAAAsQ,GAAG,GAAGtQ,KAAK,CAAC2C,MAAM,CAAC2N,GAAG;IAC5BA,GAAG,CAACiU,QAAQ,GAAG,IAAI;IACf,IAAAjU,GAAG,CAACzP,QAAQ,EAAEkyB,IAAI,CAACziB,GAAG,CAACzP,QAAQ;IACnCyyB,gBAAgB;;EAGX,SAAAC,cAAcA,CAACvzB,KAAK;IACnB,MAAAsQ,GAAG,GAAGtQ,KAAK,CAAC2C,MAAM,CAAC2N,GAAG;IAC5BA,GAAG,CAACiU,QAAQ,GAAG,KAAK;IAChB,IAAAjU,GAAG,CAACzP,QAAQ,EAAEiyB,IAAI,CAACxiB,GAAG,CAACzP,QAAQ;IACnCyyB,gBAAgB;;WAGXA,gBAAgBA,CAAA;IACjB,IAAA/iB,CAAC,GAAG,CAAC;IACT+F,SAAS,CAACtJ,GAAG,CAAC7S,OAAO,CAACkT,EAAE;MACd,MAAAiD,GAAG,GAAGgG,SAAS,CAACrJ,QAAQ,CAACI,EAAE;MAC5B,KAAAiD,GAAG,CAAC8gB,MAAM;QACXlzB,eAAA,CAAAiQ,QAAA,EAAAmI,SAAS,CAACrJ,QAAQ,CAACI,EAAE,CAAE,CAAAkD,CAAC,GAAGA,CAAC,EAAA+F,SAAA;QAC5B/F,CAAC,IAAIijB,UAAU;;;IAIvB1c,UAAU,CAAC9J,GAAG,CAAC7S,OAAO,CAACkT,EAAE;MACf,MAAAsB,IAAI,GAAGmI,UAAU,CAAC7J,QAAQ,CAACI,EAAE;YAC7BiD,GAAG,GAAGgG,SAAS,CAACrJ,QAAQ,CAAC0B,IAAI,CAACvB,KAAK,CAACwB,UAAU;iCACpDkI,UAAU,CAAC7J,QAAQ,CAACI,EAAE,EAAE4C,GAAG,GAAGK,GAAG,CAACC,CAAC,GAAGiH,WAAW,EAAAV,UAAA;;;;;MAmBrD2c,sBAAsB;;;MAO+CR,eAAe,GAAAlC,OAAA;;;;;;;;;;;;;;MA7DvF;QACO,IAAA2C,GAAG,GAAG,CAAC;QACXV,YAAY,CAAC74B,OAAO,CAAC2mB,MAAM;UACvB4S,GAAG,IAAI5S,MAAM,CAAChR,KAAK;;QAEvB6G,YAAA,KAAAyc,WAAW,GAAGM,GAAG;;;;MAkDpB;QACG/c,YAAA,IAAA8c,sBAAsB,GAAG7R,MAAM,GAAGsP,aAAa,IAAIkC,WAAW,IAAIvI,UAAU;;;;;;;;;;;;;;;;;;;ACzGhF,IAAA8I,gBAAgB,GAAGC,KAAA;;;;;;;;;;;;;;;;;;+BC2FJv3B,GAAI;;iDAEOA,GAAW;;oCAGpBA,GAAS;oCAAQA,GAAM;;;;;;;;;4CAf4BA,GAAE;;;MAAtEuC,MAiBM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;MAhBFL,MAeM,CAAAuU,GAAA,EAAA8gB,GAAA;MARFr1B,MAME,CAAAq1B,GAAA,EAAAC,KAAA;MACFt1B,MAAoC,CAAAq1B,GAAA,EAAAE,KAAA;;;;iCAL7B13B,GAAI;;;;;;mDAEOA,GAAW;;;sCAGpBA,GAAS;;;sCAAQA,GAAM;;;8CAf4BA,GAAE;;;;;;;;;;;;EADnE,IAAAsd,QAAA,yBAAAtd,GAAe,CAAK,yBAAAA,GAAa,CAAK,yBAAAA,GAAe,yBAAKA,GAAa,QAAA23B,eAAA,CAAA33B,GAAA;;;;;;;;;;;MAAvE,yBAAAA,GAAe,CAAK,yBAAAA,GAAa,CAAK,yBAAAA,GAAe,yBAAKA,GAAa;;;;;;;;;;;;;;;;;;;;;;;AAxEpE,MAAA43B,OAAO,GAAG,EAAE;AACZ,MAAAC,UAAU,GAAG,CAAC;;;;EATZ;IAAA/lB,QAAQ;IAAED;EAAS,CAAK,GAAAxJ,UAAU,CAAC,WAAW;;;;IAE3C2I;EAAE,IAAAmH,OAAA;;IACF2f;EAAM,IAAA3f,OAAA;;IACN4f;EAAI,IAAA5f,OAAA;EACJ;IAAA0O,MAAM,GAAG;EAAK,IAAA1O,OAAA;EACd;IAAA6f,WAAW,GAAG;EAAC,IAAA7f,OAAA;MAKtB8f,SAAS;MACTC,IAAI;MAEJC,QAAQ;MACRC,eAAe;MACfC,MAAM;MACNC,aAAa;;;;;;;;;;MAEhB;QACGhe,YAAA,KAAA6d,QAAQ,GAAG1d,UAAU,CAAC7J,QAAQ,CAACknB,MAAM;wBACrCM,eAAe,GAAGne,SAAS,CAACrJ,QAAQ,CAACunB,QAAQ,CAACpnB,KAAK,CAACwB,UAAU,EAAEwiB,MAAM;QACtEza,YAAA,KAAA+d,MAAM,GAAG5d,UAAU,CAAC7J,QAAQ,CAACmnB,IAAI;wBACjCO,aAAa,GAAGre,SAAS,CAACrJ,QAAQ,CAACynB,MAAM,CAACtnB,KAAK,CAACwB,UAAU,EAAEwiB,MAAM;YAE9DwD,MAAM,GAAGJ,QAAQ,CAACvkB,GAAG,GAAGukB,QAAQ,CAACzkB,MAAM,GAAG,CAAC;QAC3C,IAAA8kB,MAAM,GAAGL,QAAQ,CAAC7kB,IAAI,GAAG6kB,QAAQ,CAAC1kB,KAAK;YACvCglB,IAAI,GAAGJ,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC;YACrCglB,IAAI,GAAGL,MAAM,CAAC/kB,IAAI;YAClBG,KAAK,GAAGilB,IAAI,GAAGF,MAAM;YACrB9kB,MAAM,GAAG+kB,IAAI,GAAGF,MAAM;YAEtBH,eAAe;0BACfF,IAAI,OAAOQ,IAAI,IAAID,IAAI;UACnB,IAAAD,MAAM,GAAGZ,OAAO,IAAIc,IAAI,IAAIH,MAAM,IAAIE,IAAI;YAC1Cne,YAAA,IAAA4d,IAAI,SAASQ,IAAI,GAAG,GAAG,GAAGd,OAAO,IAAIa,IAAI;;4BAEzCP,IAAI,SAASQ,IAAI,GAAG,GAAG,GAAGjlB,KAAK,GAAG,CAAC,IAAIglB,IAAI;;0BAE/CP,IAAI;UACJ5d,YAAA,IAAA2d,SAAS,OAAOI,MAAM,CAAC/kB,IAAI,GAAGukB,UAC1B,KAAAQ,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC,GAAGmkB,UACrC;+BACmBQ,MAAM,CAAC/kB,IAAI,IAAI+kB,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC;AAC7C,+BAAA2kB,MAAM,CAAC/kB,IAAI,GAAGukB,UAAU,IACvBQ,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC,GAAGmkB,UACrC;mBACTS,aAAa;0BACpBJ,IAAI,OAAOM,MAAM,IAAID,MAAM;UACvB,IAAAC,MAAM,GAAGZ,OAAO,IAAIc,IAAI,IAAIH,MAAM,IAAIE,IAAI;YAC1Cne,YAAA,IAAA4d,IAAI,SAASM,MAAM,GAAG,GAAG,GAAGZ,OAAO,IAAIW,MAAM;;4BAE7CL,IAAI,SAASM,MAAM,GAAG,GAAG,GAAG/kB,KAAK,GAAG,CAAC,IAAI8kB,MAAM;;0BAEnDL,IAAI;0BACJD,SAAS;QACD,YAAAG,eAAe,KAAKE,aAAa;0BACzCJ,IAAI,OAAOM,MAAM,IAAID,MAAM;UACvB,IAAAC,MAAM,GAAGZ,OAAO,IAAIc,IAAI,IAAIH,MAAM,IAAIE,IAAI;YAC1Cne,YAAA,IAAA4d,IAAI,IAAS,KAAAM,MAAM,GAAGZ,OAAO,IAAIW,MAAM;AACvB,gCAAAC,MAAM,GAAGZ,OAAO,IAAIW,MAAM,GAAG7kB,MAAM,GAAG,CAAC;AACvC,gCAAAglB,IAAI,GAAGd,OAAO,IAAIW,MAAM,GAAG7kB,MAAM,GAAG,CAAC;gCACrCglB,IAAI,GAAGd,OAAO,IAAIa,IAAI;gCACtBC,IAAI,GAAG,CAAC,IAAID,IAAI;;YAEhCne,YAAA,IAAA4d,IAAI,SAASM,MAAM,GAAG/kB,KAAK,GAAG,CAAC,IAAI8kB,MAAM;AACzB,gCAAAC,MAAM,GAAG/kB,KAAK,GAAG,CAAC,IAAIglB,IAAI;gCAC1BC,IAAI,GAAG,CAAC,IAAID,IAAI;;UAEpCne,YAAA,IAAA2d,SAAS,OAAOI,MAAM,CAAC/kB,IAAI,GAAGukB,UAC1B,IAAAQ,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC,GAAGmkB,UACrC;+BACmBQ,MAAM,CAAC/kB,IAAI,IAAI+kB,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC;AAC7C,+BAAA2kB,MAAM,CAAC/kB,IAAI,GAAGukB,UAAU,IACvBQ,MAAM,CAACzkB,GAAG,GAAGykB,MAAM,CAAC3kB,MAAM,GAAG,CAAC,GAAGmkB,UACrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDC1CJ73B,GAAU;;;;;;;;;;;;;;;;;;;;;;;sJAAVA,GAAU,S;;;;;;;;;;;;;;;;;;;;;;;;;6DADvBA,GAAmB;EAAgB,MAAAoL,OAAA,GAAApL,GAAA,kBAAAA,GAAU,IAACgR,EAAE;iCAArDlS,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;MADV2B,MAIM,CAAAH,MAAA,EAAAsU,GAAA,EAAAlU,MAAA;;;;;;;;;;+DAHKxC,GAAmB;;;;;;;;qCAAxBlB,MAAI,EAAA8B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;IA7BEquB;EAAa,IAAK5mB,UAAU,CAAC,YAAY;;;IACzCwJ;EAAS,IAAKxJ,UAAU,CAAC,WAAW;;;IAEjCisB;EAAU,IAAAnc,OAAA;;IACVwgB,YAAY;EAAA,IAAAxgB,OAAA;MAEnBygB,mBAAmB;;;;;;;MACtB;cACSr3B,MAAM;iBACHX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+3B,YAAY,CAAC75B,MAAM,EAAE8B,CAAC;gBAChCi4B,UAAU,GAAGF,YAAY,CAAC/3B,CAAC;gBAC3BsM,GAAG,GAAGuN,UAAU,CAAC7J,QAAQ;UAEzB,MAAAunB,QAAQ,GAAGjrB,GAAG,CAAC2rB,UAAU,CAACf,MAAM;UAChC,MAAAO,MAAM,GAAGnrB,GAAG,CAAC2rB,UAAU,CAACd,IAAI;UAE9B,IAAAI,QAAQ,IACRE,MAAM,IACN33B,IAAI,CAAC8kB,GAAG,CAAC2S,QAAQ,CAACvkB,GAAG,EAAEykB,MAAM,CAACzkB,GAAG,KAAK0gB,UAAU,GAAGM,cAAc,IACjEl0B,IAAI,CAACC,GAAG,CAACw3B,QAAQ,CAACvkB,GAAG,EAAEykB,MAAM,CAACzkB,GAAG,KAAK0gB,UAAU;YAEhD/yB,MAAM,CAAC1B,IAAI,CAACg5B,UAAU;;;QAG9Bve,YAAA,IAAAse,mBAAmB,GAAGr3B,MAAM;;;;;;;;;;;;;;;AC1B9B,MAAAu3B,uBAAuB,GAAGC,iBAAA;ACgBhC,MAAMC,QAAQ,GAAG;EACbC,OAAO,EAAE,IAAI;EACbC,cAAc,EAAEA,CAAA,KAAK;IACjB,MAAMj2B,OAAO,GAAGzE,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC7CwE,OAAO,CAACuE,SAAS,GAAG,UAAU;IAC9B9J,MAAM,CAACP,MAAM,CAAC8F,OAAO,CAAC+B,KAAK,EAAE;MACzBW,QAAQ,EAAE,UAAU;MACpBwzB,UAAU,EAAE,MAAM;MAClBC,OAAO,EAAE,WAAW;MACpBC,QAAQ,EAAE,MAAM;MAChBC,aAAa,EAAE;IAClB,EAAC;IACF,OAAOr2B,OAAO;;CAErB;MAEYs2B,mBAAmB;EAC5B1Z,SAAS;EACT5c,OAAO;EACAY,OAAO;EAEdkD,WAAYA,CAAA1E,IAAiB,EAAEwB,OAAoB;IAC/C,IAAI,CAACA,OAAO,GAAGnG,MAAM,CAACP,MAAM,CAAC,EAAE,EAAE67B,QAAQ,EAAEn1B,OAAO,CAAC;IACnD,IAAI,CAACgc,SAAS,GAAG,IAAInC,SAAS,CAACrb,IAAI,EAAE;MACjCga,MAAM,EAAE,IAAI,CAACA,MAAM,CAACmd,IAAI,CAAC,IAAI,CAAC;MAC9Bjd,WAAW,EAAEA,CAAA,KAAM,IAAI,CAAC1Y,OAAO,CAACo1B,OAAO;MACvCzc,aAAa,EAAE,KAAK;MACpB1C,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC0f,IAAI,CAAC,IAAI,CAAC;MAC9B/c,SAAS,EAAEje,QAAQ,CAACiX,IAAI;MACxBiH,IAAI,EAAG/Y,KAAiB,IAAKA,KAAK,CAAC81B,KAAK;MACxC9c,IAAI,EAAGhZ,KAAiB,IAAKA,KAAK,CAAC+1B,KAAK;MACxC9c,QAAQ,EAAEA,CAAA,KAAM;IACnB,EAAC;;EAGNP,MAAMA,CAAC;IAAEvH,CAAC;IAAEZ;EAAC,CAAE;IACX,IAAI,CAAC,IAAI,CAACjR,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAG,IAAI,CAACY,OAAO,CAACq1B,cAAc,EAAE;MAC5C16B,QAAQ,CAACiX,IAAI,CAACnT,WAAW,CAAC,IAAI,CAACW,OAAO,CAAC;MACvC,IAAI,CAACY,OAAO,CAACqW,QAAQ,GAAG,IAAI;IAC/B;IAED,IAAI,CAACjX,OAAO,CAAC+B,KAAK,CAAC4O,GAAG,GAAGM,CAAC,GAAG,IAAI;IACjC,IAAI,CAACjR,OAAO,CAAC+B,KAAK,CAACsO,IAAI,GAAGwB,CAAC,GAAG,IAAI;;EAGtCgF,MAAMA,CAACnW,KAAK;IACR,MAAMg2B,KAAK,GAAG,IAAI,CAAC91B,OAAO,CAAC81B,KAAK;IAChC,MAAMxf,SAAS,GAAGwf,KAAK,CAAC1gB,UAAU,CAACmB,SAAS,CAAC,KAAK,EAAEzW,KAAK,CAAC0W,UAAU,CAAC;IACrE,IAAIF,SAAS,EAAE;MACX,MAAM6E,QAAQ,GAAGrK,cAAc,CAACglB,KAAK,CAAChH,eAAe,EAAE,EAAEhvB,KAAK,CAAC0W,UAAU,CAAC;MAC1E,MAAMkG,IAAI,GAAGoZ,KAAK,CAACxgB,KAAK,CAAC4B,iBAAiB,CAACiE,QAAQ,CAAClK,CAAC,CAAC;MAEtD,IAAI,CAACjR,OAAO,CAAC+1B,SAAS,GAAGzf,SAAS,EAAEoG,IAAI,EAAEoZ,KAAK,CAAC;IACnD,OAAM;MACH,IAAI,CAAC91B,OAAO,CAACg2B,MAAM,IAAI;IAC1B;IAEDr7B,QAAQ,CAACiX,IAAI,CAAC7S,WAAW,CAAC,IAAI,CAACK,OAAO,CAAC;IACvC,IAAI,CAACY,OAAO,CAACqW,QAAQ,GAAG,KAAK;IAC7B,IAAI,CAACjX,OAAO,GAAG,IAAI;;AAE1B;;AChFD;;AAEG;MACU62B,4BAA4B;EACrCC,MAAM;EAENhzB,YAAYgzB,MAAM;IACd,IAAI,CAACA,MAAM,GAAGA,MAAM;;EAGxB/U,MAAMA,CAACzE,IAAY,EAAEyE,MAAc;IAC/B,OAAO,IAAI,CAAC+U,MAAM,CAACxZ,IAAI,CAAC,CAACyE,MAAM,CAACA,MAAM,CAAC;;EAG3ClK,OAAOA,CAACyF,IAAY,EAAEH,IAAY,EAAEC,MAAc;IAC9C,MAAMlZ,CAAC,GAAG,IAAI,CAAC4yB,MAAM,CAACxZ,IAAI,CAAC;IAC3ByZ,WAAW,CAAC7yB,CAAC,EAAEkZ,MAAM,EAAED,IAAI,CAAC;IAC5B,OAAOjZ,CAAC,CAACge,OAAO,EAAE;;AAEzB;AAED,MAAM8U,OAAO,GAAG;EACZC,IAAI,EAAE,OAAO;EACbC,MAAM,EAAE,SAAS;EACjBC,MAAM,EAAE,SAAS;EACjBC,WAAW,EAAE;CAChB;AAED;AACA,SAASL,WAAWA,CAAC7yB,CAAC,EAAEmzB,SAAS,EAAEx1B,GAAG,EAAEgZ,SAAS,GAAG,OAAO;EACvD,IAAIwc,SAAS,KAAK,CAAC,IAAIx1B,GAAG,KAAK,KAAK,EAAE;IAClCw1B,SAAS,GAAG,EAAE;IACdx1B,GAAG,GAAG,OAAO;EAChB;EAED,IAAIm1B,OAAO,CAACn1B,GAAG,CAAC,EAAE;IACdA,GAAG,GAAGm1B,OAAO,CAACn1B,GAAG,CAAC;EACrB;EAED,MAAMy1B,OAAO,GAAG;IACZC,KAAK,EAAE,EAAE;IACTC,OAAO,EAAE,EAAE;IACXC,OAAO,EAAE,EAAE;IACXC,YAAY,EAAE;GACjB;EAED,IAAI,CAACJ,OAAO,CAACz1B,GAAG,CAAC,EAAE;IACfumB,OAAO,CAACC,IAAI,CAAC,qBAAqBxmB,GAAG,mBAAmB,CAAC;EAC5D;EAED,IAAIvF,KAAK,GAAG,CAAC;EACb,IAAIq7B,OAAO,GAAG,KAAK;EACnB,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,QAAQ;EAEZ,KAAK,MAAMx9B,CAAC,IAAIi9B,OAAO,EAAE;IACrB,IAAIj9B,CAAC,KAAKwH,GAAG,EAAE;MACXvF,KAAK,GAAG4H,CAAC,CAACmB,GAAG,CAACxD,GAAG,CAAC;MAClBg2B,QAAQ,GAAGP,OAAO,CAACj9B,CAAC,CAAC;MACrBs9B,OAAO,GAAG,IAAI;IACjB,OAAM,IAAIA,OAAO,EAAE;MAChBC,QAAQ,IAAIN,OAAO,CAACj9B,CAAC,CAAC;MACtBiC,KAAK,IAAI4H,CAAC,CAACmB,GAAG,CAAChL,CAAC,CAAC,GAAGu9B,QAAQ;MAC5B1zB,CAAC,CAACpF,GAAG,CAACzE,CAAC,EAAE,CAAC,CAAC;IACd;EACJ;EAEDiC,KAAK,GAAGmB,IAAI,CAACod,SAAS,CAAC,CAACve,KAAK,GAAG+6B,SAAS,CAAC,GAAGA,SAAS,CAAC;EACvD/6B,KAAK,GAAGmB,IAAI,CAAC8kB,GAAG,CAACjmB,KAAK,EAAEu7B,QAAQ,CAAC;EACjC3zB,CAAC,CAACpF,GAAG,CAAC+C,GAAG,EAAEvF,KAAK,CAAC;EACjB,OAAO4H,CAAC;AACZ;AChEM,MAAA4zB,WAAW,GAAGC,KAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}